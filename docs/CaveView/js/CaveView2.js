(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CV2 = {}));
})(this, (function (exports) { 'use strict';

	const VERSION = '2.6.0-beta';

	const CAMERA_NONE         = 0;
	const CAMERA_ORTHOGRAPHIC = 1;
	const CAMERA_PERSPECTIVE  = 2;
	const CAMERA_ANAGLYPH     = 3;

	const CAMERA_OFFSET       = 600;

	// preset camera views

	const VIEW_NONE           = 0;
	const VIEW_PLAN           = 1;
	const VIEW_ELEVATION_N    = 2;
	const VIEW_ELEVATION_S    = 3;
	const VIEW_ELEVATION_E    = 4;
	const VIEW_ELEVATION_W    = 5;

	// mouse selection operation mode

	const MOUSE_MODE_NORMAL     = 0;
	const MOUSE_MODE_ROUTE_EDIT = 1;
	const MOUSE_MODE_DISTANCE   = 2;
	const MOUSE_MODE_TRACE_EDIT = 3;
	const MOUSE_MODE_ENTRANCES  = 4;

	// shading types

	const SHADING_HEIGHT       = 1;
	const SHADING_LENGTH       = 2;
	const SHADING_INCLINATION  = 3;
	const SHADING_CURSOR       = 4;
	const SHADING_SINGLE       = 5;
	const SHADING_SURVEY       = 6;
	const SHADING_OVERLAY      = 7;
	const SHADING_SHADED       = 8;
	const SHADING_RELIEF       = 8;
	const SHADING_DEPTH        = 9;
	const SHADING_PATH         = 10;
	const SHADING_DEPTH_CURSOR = 11;
	const SHADING_DISTANCE     = 13;
	const SHADING_CONTOURS     = 15;
	const SHADING_SURFACE      = 17;
	const SHADING_DUPLICATE    = 18;
	const SHADING_CUSTOM       = 19;

	// layer tags for scene objects

	const FEATURE_SURVEY        = 0;
	const LEG_CAVE              = 1;
	const LEG_SPLAY             = 2;
	const LEG_SURFACE           = 3;
	const FEATURE_BOX           = 4;
	const FEATURE_SELECTED_BOX  = 5;
	const FEATURE_ENTRANCES     = 6;
	const FEATURE_TERRAIN       = 7;
	const FEATURE_STATIONS      = 8;
	const FEATURE_TRACES        = 9;
	const FACE_WALLS            = 11;
	const FACE_SCRAPS           = 12;
	const LABEL_STATION         = 13;
	const SURVEY_WARNINGS       = 14;
	const LABEL_STATION_COMMENT = 15;
	const CLUSTER_MARKERS       = 16;
	const FEATURE_ENTRANCE_DOTS = 17;
	const FEATURE_GRID          = 18;
	const LEG_DUPLICATE         = 19;

	const WALL_OVAL             = 1; // based on Therion .lox types
	const WALL_SQUARE           = 2;
	const WALL_DIAMOND          = 3;

	// bit mask
	const STATION_NORMAL = 1;
	const STATION_ENTRANCE = 2;
	const STATION_XSECT = 4;

	// lighting modes
	const LM_NONE = 0;
	const LM_SINGLE = 1;
	const LM_MULTIPLE = 2;

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	class EventDispatcher {

		addEventListener( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		}

		hasEventListener( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		}

		removeEventListener( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		}

		dispatchEvent( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

				event.target = null;

			}

		}

	}

	const REVISION = '143';
	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const SRGBColorSpace = 'srgb';
	const LinearSRGBColorSpace = 'srgb-linear';
	const KeepStencilOp = 7680;
	const IncrementStencilOp = 7682;
	const EqualStencilFunc = 514;
	const AlwaysStencilFunc = 519;

	const StaticDrawUsage = 35044;
	const GLSL3 = '300 es';

	const _SRGBAFormat = 1035; // fallback for WebGL 1

	const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];


	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI;

	// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	function generateUUID() {

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toLowerCase() here flattens concatenated strings to save heap memory space.
		return uuid.toLowerCase();

	}

	function clamp( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	}

	// compute euclidean modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation
	function euclideanModulo( n, m ) {

		return ( ( n % m ) + m ) % m;

	}

	// https://en.wikipedia.org/wiki/Linear_interpolation
	function lerp( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	}

	function degToRad$1( degrees ) {

		return degrees * DEG2RAD;

	}

	function radToDeg$1( radians ) {

		return radians * RAD2DEG;

	}

	function isPowerOfTwo( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	function floorPowerOfTwo( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	}

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			Vector2.prototype.isVector2 = true;

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;

		}

	}

	class Matrix3 {

		constructor() {

			Matrix3.prototype.isMatrix3 = true;

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		scale( sx, sy ) {

			const te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		}

		rotate( theta ) {

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			const te = this.elements;

			const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		}

		translate( tx, ty ) {

			const te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	function arrayNeedsUint32( array ) {

		// assumes larger values usually on last

		for ( let i = array.length - 1; i >= 0; -- i ) {

			if ( array[ i ] > 65535 ) return true;

		}

		return false;

	}

	function createElementNS( name ) {

		return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	// JavaScript RGB-to-RGB transforms, defined as
	// FN[InputColorSpace][OutputColorSpace] callback functions.
	const FN = {
		[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
		[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
	};

	const ColorManagement = {

		legacyMode: true,

		get workingColorSpace() {

			return LinearSRGBColorSpace;

		},

		set workingColorSpace( colorSpace ) {

			console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

		},

		convert: function ( color, sourceColorSpace, targetColorSpace ) {

			if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

				return color;

			}

			if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

				const fn = FN[ sourceColorSpace ][ targetColorSpace ];

				color.r = fn( color.r );
				color.g = fn( color.g );
				color.b = fn( color.b );

				return color;

			}

			throw new Error( 'Unsupported color space conversion.' );

		},

		fromWorkingColorSpace: function ( color, targetColorSpace ) {

			return this.convert( color, this.workingColorSpace, targetColorSpace );

		},

		toWorkingColorSpace: function ( color, sourceColorSpace ) {

			return this.convert( color, sourceColorSpace, this.workingColorSpace );

		},

	};

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _rgb = { r: 0, g: 0, b: 0 };
	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	function toComponents( source, target ) {

		target.r = source.r;
		target.g = source.g;
		target.b = source.b;

		return target;

	}

	class Color {

		constructor( r, g, b ) {

			this.isColor = true;

			this.r = 1;
			this.g = 1;
			this.b = 1;

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		set( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex, colorSpace = SRGBColorSpace ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setRGB( r, g, b, colorSpace = LinearSRGBColorSpace ) {

			this.r = r;
			this.g = g;
			this.b = b;

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setHSL( h, s, l, colorSpace = LinearSRGBColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo( h, 1 );
			s = clamp( s, 0, 1 );
			l = clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			ColorManagement.toWorkingColorSpace( this, colorSpace );

			return this;

		}

		setStyle( style, colorSpace = SRGBColorSpace ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							ColorManagement.toWorkingColorSpace( this, colorSpace );

							handleAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							ColorManagement.toWorkingColorSpace( this, colorSpace );

							handleAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat( color[ 1 ] ) / 360;
							const s = parseInt( color[ 2 ], 10 ) / 100;
							const l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 4 ] );

							return this.setHSL( h, s, l, colorSpace );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					ColorManagement.toWorkingColorSpace( this, colorSpace );

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					ColorManagement.toWorkingColorSpace( this, colorSpace );

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				return this.setColorName( style, colorSpace );

			}

			return this;

		}

		setColorName( style, colorSpace = SRGBColorSpace ) {

			// color keywords
			const hex = _colorKeywords[ style.toLowerCase() ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex, colorSpace );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;

		}

		getHexString( colorSpace = SRGBColorSpace ) {

			return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

		}

		getHSL( target, colorSpace = LinearSRGBColorSpace ) {

			// h,s,l ranges are in 0.0 - 1.0

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			const r = _rgb.r, g = _rgb.g, b = _rgb.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getRGB( target, colorSpace = LinearSRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			target.r = _rgb.r;
			target.g = _rgb.g;
			target.b = _rgb.b;

			return target;

		}

		getStyle( colorSpace = SRGBColorSpace ) {

			ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

			if ( colorSpace !== SRGBColorSpace ) {

				// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
				return `color(${ colorSpace } ${ _rgb.r } ${ _rgb.g } ${ _rgb.b })`;

			}

			return `rgb(${( _rgb.r * 255 ) | 0},${( _rgb.g * 255 ) | 0},${( _rgb.b * 255 ) | 0})`;

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = lerp( _hslA.h, _hslB.h, alpha );
			const s = lerp( _hslA.s, _hslB.s, alpha );
			const l = lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			if ( attribute.normalized === true ) {

				// assuming Uint8Array

				this.r /= 255;
				this.g /= 255;
				this.b /= 255;

			}

			return this;

		}

		toJSON() {

			return this.getHex();

		}

		*[ Symbol.iterator ]() {

			yield this.r;
			yield this.g;
			yield this.b;

		}

	}

	Color.NAMES = _colorKeywords;

	let _canvas;

	class ImageUtils {

		static getDataURL( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		static sRGBToLinear( image ) {

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const canvas = createElementNS( 'canvas' );

				canvas.width = image.width;
				canvas.height = image.height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height );

				const imageData = context.getImageData( 0, 0, image.width, image.height );
				const data = imageData.data;

				for ( let i = 0; i < data.length; i ++ ) {

					data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

				}

				context.putImageData( imageData, 0, 0 );

				return canvas;

			} else if ( image.data ) {

				const data = image.data.slice( 0 );

				for ( let i = 0; i < data.length; i ++ ) {

					if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

						data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

					} else {

						// assuming float

						data[ i ] = SRGBToLinear( data[ i ] );

					}

				}

				return {
					data: data,
					width: image.width,
					height: image.height
				};

			} else {

				console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
				return image;

			}

		}

	}

	class Source {

		constructor( data = null ) {

			this.isSource = true;

			this.uuid = generateUUID();

			this.data = data;

			this.version = 0;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

				return meta.images[ this.uuid ];

			}

			const output = {
				uuid: this.uuid,
				url: ''
			};

			const data = this.data;

			if ( data !== null ) {

				let url;

				if ( Array.isArray( data ) ) {

					// cube texture

					url = [];

					for ( let i = 0, l = data.length; i < l; i ++ ) {

						if ( data[ i ].isDataTexture ) {

							url.push( serializeImage( data[ i ].image ) );

						} else {

							url.push( serializeImage( data[ i ] ) );

						}

					}

				} else {

					// texture

					url = serializeImage( data );

				}

				output.url = url;

			}

			if ( ! isRootObject ) {

				meta.images[ this.uuid ] = output;

			}

			return output;

		}

	}

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.from( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {

		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

			super();

			this.isTexture = true;

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = generateUUID();

			this.name = '';

			this.source = new Source( image );
			this.mipmaps = [];

			this.mapping = mapping;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding;

			this.userData = {};

			this.version = 0;
			this.onUpdate = null;

			this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
			this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

		}

		get image() {

			return this.source.data;

		}

		set image( value ) {

			this.source.data = value;

		}

		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.source = source.source;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.needsUpdate = true;

			return this;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				image: this.source.toJSON( meta ).uuid,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		set needsUpdate( value ) {

			if ( value === true ) {

				this.version ++;
				this.source.needsUpdate = true;

			}

		}

	}

	Texture.DEFAULT_IMAGE = null;
	Texture.DEFAULT_MAPPING = UVMapping;

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			Vector4.prototype.isVector4 = true;

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;
			yield this.w;

		}

	}

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher {

		constructor( width, height, options = {} ) {

			super();

			this.isWebGLRenderTarget = true;

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			const image = { width: width, height: height, depth: 1 };

			this.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
			this.texture.isRenderTargetTexture = true;

			this.texture.flipY = false;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;

			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

			this.samples = options.samples !== undefined ? options.samples : 0;

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();
			this.texture.isRenderTargetTexture = true;

			// ensure image object is not shared, see #20328

			const image = Object.assign( {}, source.texture.image );
			this.texture.source = new Source( image );

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;

			if ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();

			this.samples = source.samples;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this.isQuaternion = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t === 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
				return;

			}

			if ( t === 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;
				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			let r = vFrom.dot( vTo ) + 1;

			if ( r < Number.EPSILON ) {

				// vFrom and vTo point in opposite directions

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q ) {

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		slerpQuaternions( qa, qb, t ) {

			return this.copy( qa ).slerp( qb, t );

		}

		random() {

			// Derived from http://planning.cs.uiuc.edu/node198.html
			// Note, this source uses w, x, y, z ordering,
			// so we swap the order below.

			const u1 = Math.random();
			const sqrt1u1 = Math.sqrt( 1 - u1 );
			const sqrtu1 = Math.sqrt( u1 );

			const u2 = 2 * Math.PI * Math.random();

			const u3 = 2 * Math.PI * Math.random();

			return this.set(
				sqrt1u1 * Math.cos( u2 ),
				sqrtu1 * Math.sin( u3 ),
				sqrtu1 * Math.cos( u3 ),
				sqrt1u1 * Math.sin( u2 ),
			);

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._w;

		}

	}

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			Vector3.prototype.isVector3 = true;

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v ) {

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v ) {

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			return this.applyQuaternion( _quaternion$2.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion$2.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v ) {

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector$8.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector$8 );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector$8.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		setFromEuler( e ) {

			this.x = e._x;
			this.y = e._y;
			this.z = e._z;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

		randomDirection() {

			// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

			const u = ( Math.random() - 0.5 ) * 2;
			const t = Math.random() * Math.PI * 2;
			const f = Math.sqrt( 1 - u ** 2 );

			this.x = f * Math.cos( t );
			this.y = f * Math.sin( t );
			this.z = u;

			return this;

		}

		*[ Symbol.iterator ]() {

			yield this.x;
			yield this.y;
			yield this.z;

		}

	}

	const _vector$8 = /*@__PURE__*/ new Vector3();
	const _quaternion$2 = /*@__PURE__*/ new Quaternion();

	class Box3 {

		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			this.isBox3 = true;

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const x = array[ i ];
				const y = array[ i + 1 ];
				const z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromBufferAttribute( attribute ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = attribute.count; i < l; i ++ ) {

				const x = attribute.getX( i );
				const y = attribute.getY( i );
				const z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object, precise = false ) {

			this.makeEmpty();

			return this.expandByObject( object, precise );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object, precise = false ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			const geometry = object.geometry;

			if ( geometry !== undefined ) {

				if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

					const position = geometry.attributes.position;
					for ( let i = 0, l = position.count; i < l; i ++ ) {

						_vector$7.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
						this.expandByPoint( _vector$7 );

					}

				} else {

					if ( geometry.boundingBox === null ) {

						geometry.computeBoundingBox();

					}

					_box$4.copy( geometry.boundingBox );
					_box$4.applyMatrix4( object.matrixWorld );

					this.union( _box$4 );

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ], precise );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$7 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$7.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0$1.subVectors( triangle.a, _center );
			_v1$4.subVectors( triangle.b, _center );
			_v2$1.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$4, _v0$1 );
			_f1.subVectors( _v2$1, _v1$4 );
			_f2.subVectors( _v0$1, _v2$1 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0$1, _v1$4, _v2$1, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0$1, _v1$4, _v2$1, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0$1, _v1$4, _v2$1, _extents );

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );

			return clampedPoint.sub( point ).length();

		}

		getBoundingSphere( target ) {

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$7 ).length() * 0.5;

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$7 = /*@__PURE__*/ new Vector3();

	const _box$4 = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the separating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the separating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is separating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$3 = /*@__PURE__*/ new Box3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _toFarthestPoint = /*@__PURE__*/ new Vector3();
	const _toPoint = /*@__PURE__*/ new Vector3();

	class Sphere {

		constructor( center = new Vector3(), radius = - 1 ) {

			this.center = center;
			this.radius = radius;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$3.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		expandByPoint( point ) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

			_toPoint.subVectors( point, this.center );

			const lengthSq = _toPoint.lengthSq();

			if ( lengthSq > ( this.radius * this.radius ) ) {

				const length = Math.sqrt( lengthSq );
				const missingRadiusHalf = ( length - this.radius ) * 0.5;

				// Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
				this.radius += missingRadiusHalf;

			}

			return this;

		}

		union( sphere ) {

			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.

			 if ( this.center.equals( sphere.center ) === true ) {

				 _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );


			} else {

				_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

			}

			this.expandByPoint( _v1$3.copy( sphere.center ).add( _toFarthestPoint ) );
			this.expandByPoint( _v1$3.copy( sphere.center ).sub( _toFarthestPoint ) );

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			this.isPlane = true;

			// normal is assumed to be normalized

			this.normal = normal;
			this.constant = constant;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		}

		intersectLine( line, target ) {

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return null;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return null;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _sphere$3 = /*@__PURE__*/ new Sphere();
	const _vector$6 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		}

		intersectsObject( object ) {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( _sphere$3 );

		}

		intersectsSprite( sprite ) {

			_sphere$3.center.set( 0, 0, 0 );
			_sphere$3.radius = 0.7071067811865476;
			_sphere$3.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$3 );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$6 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class Matrix4 {

		constructor() {

			Matrix4.prototype.isMatrix4 = true;

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$2.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1$2.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1$2.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( xy, xz, yx, yz, zx, zy ) {

			this.set(

				1, yx, zx, 0,
				xy, 1, zy, 0,
				xz, yz, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1$2.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1$2.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1$2.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1$2.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1$2.elements[ 0 ] *= invSX;
			_m1$2.elements[ 1 ] *= invSX;
			_m1$2.elements[ 2 ] *= invSX;

			_m1$2.elements[ 4 ] *= invSY;
			_m1$2.elements[ 5 ] *= invSY;
			_m1$2.elements[ 6 ] *= invSY;

			_m1$2.elements[ 8 ] *= invSZ;
			_m1$2.elements[ 9 ] *= invSZ;
			_m1$2.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1$2 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far ) {

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );
			const c = - ( far + near ) / ( far - near );
			const d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;
			const z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _m1$2 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = 5131;

					} else {

						throw new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = 5123;

				}

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			} else if ( array instanceof Uint8ClampedArray ) {

				type = 5121;

			} else {

				throw new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	const _vector$5 = /*@__PURE__*/ new Vector3();
	const _vector2 = /*@__PURE__*/ new Vector2();

	class BufferAttribute {

		constructor( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.isBufferAttribute = true;

			this.name = '';

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		copyArray( array ) {

			this.array.set( array );

			return this;

		}

		copyColorsArray( colors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = colors.length; i < l; i ++ ) {

				let color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		}

		copyVector2sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		}

		copyVector3sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		}

		copyVector4sArray( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		}

		applyMatrix3( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2.fromBufferAttribute( this, i );
					_vector2.applyMatrix3( m );

					this.setXY( i, _vector2.x, _vector2.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$5.fromBufferAttribute( this, i );
					_vector$5.applyMatrix3( m );

					this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

				}

			}

			return this;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.applyMatrix4( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.applyNormalMatrix( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$5.fromBufferAttribute( this, i );

				_vector$5.transformDirection( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		getX( index ) {

			return this.array[ index * this.itemSize ];

		}

		setX( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		}

		getY( index ) {

			return this.array[ index * this.itemSize + 1 ];

		}

		setY( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		}

		getZ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		}

		setZ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		}

		getW( index ) {

			return this.array[ index * this.itemSize + 3 ];

		}

		setW( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		}

		setXY( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		clone() {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

		toJSON() {

			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.from( this.array ),
				normalized: this.normalized
			};

			if ( this.name !== '' ) data.name = this.name;
			if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
			if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

			return data;

		}

	}

	class Uint16BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint16Array( array ), itemSize, normalized );

		}

	}

	class Uint32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Uint32Array( array ), itemSize, normalized );

		}

	}


	class Float32BufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized ) {

			super( new Float32Array( array ), itemSize, normalized );

		}

	}

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

			this.isEuler = true;

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order = this._order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order = this._order, update = true ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update === true ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		setFromVector3( v, order = this._order ) {

			return this.set( v.x, v.y, v.z, order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

		*[ Symbol.iterator ]() {

			yield this._x;
			yield this._y;
			yield this._z;
			yield this._order;

		}

		// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

		toVector3() {

			console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

		}

	}

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = ( 1 << channel | 0 ) >>> 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

		isEnabled( channel ) {

			return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

		}

	}

	let _object3DId = 0;

	const _v1$1 = /*@__PURE__*/ new Vector3();
	const _q1 = /*@__PURE__*/ new Quaternion();
	const _m1$1 = /*@__PURE__*/ new Matrix4();
	const _target = /*@__PURE__*/ new Vector3();

	const _position$2 = /*@__PURE__*/ new Vector3();
	const _scale = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();

	const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
	const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	class Object3D extends EventDispatcher {

		constructor() {

			super();

			this.isObject3D = true;

			Object.defineProperty( this, 'id', { value: _object3DId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation._onChange( onRotationChange );
			quaternion._onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.animations = [];

			this.userData = {};

		}

		onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

		applyMatrix4( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		}

		applyQuaternion( q ) {

			this.quaternion.premultiply( q );

			return this;

		}

		setRotationFromAxisAngle( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		}

		setRotationFromEuler( euler ) {

			this.quaternion.setFromEuler( euler, true );

		}

		setRotationFromMatrix( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		}

		setRotationFromQuaternion( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		}

		rotateOnAxis( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		}

		rotateOnWorldAxis( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		}

		rotateX( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		}

		rotateY( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		}

		rotateZ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		}

		translateOnAxis( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$1.multiplyScalar( distance ) );

			return this;

		}

		translateX( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		}

		translateY( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		}

		translateZ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		}

		localToWorld( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		}

		worldToLocal( vector ) {

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		}

		lookAt( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position$2.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position$2, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position$2, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		}

		add( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		}

		remove( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		}

		removeFromParent() {

			const parent = this.parent;

			if ( parent !== null ) {

				parent.remove( this );

			}

			return this;

		}

		clear() {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		}

		attach( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		}

		getObjectById( id ) {

			return this.getObjectByProperty( 'id', id );

		}

		getObjectByName( name ) {

			return this.getObjectByProperty( 'name', name );

		}

		getObjectByProperty( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		}

		getWorldPosition( target ) {

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		}

		getWorldQuaternion( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$2, target, _scale );

			return target;

		}

		getWorldScale( target ) {

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position$2, _quaternion, target );

			return target;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		}

		raycast( /* raycaster, intersects */ ) {}

		traverse( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		}

		traverseVisible( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		}

		traverseAncestors( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		}

		updateMatrix() {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		}

		updateMatrixWorld( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		}

		toJSON( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isScene ) {

				if ( this.background ) {

					if ( this.background.isColor ) {

						object.background = this.background.toJSON();

					} else if ( this.background.isTexture ) {

						object.background = this.background.toJSON( meta ).uuid;

					}

				}

				if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

					object.environment = this.environment.toJSON( meta ).uuid;

				}

			} else if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );
				const nodes = extractFromCache( meta.nodes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;
				if ( nodes.length > 0 ) output.nodes = nodes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		}

		clone( recursive ) {

			return new this.constructor().copy( this, recursive );

		}

		copy( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	}

	Object3D.DefaultUp = /*@__PURE__*/ new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	let _id$1 = 0;

	const _m1 = /*@__PURE__*/ new Matrix4();
	const _obj = /*@__PURE__*/ new Object3D();
	const _offset = /*@__PURE__*/ new Vector3();
	const _box$2 = /*@__PURE__*/ new Box3();
	const _boxMorphTargets = /*@__PURE__*/ new Box3();
	const _vector$4 = /*@__PURE__*/ new Vector3();

	class BufferGeometry extends EventDispatcher {

		constructor() {

			super();

			this.isBufferGeometry = true;

			Object.defineProperty( this, 'id', { value: _id$1 ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};
			this.morphTargetsRelative = false;

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

			this.userData = {};

		}

		getIndex() {

			return this.index;

		}

		setIndex( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		}

		getAttribute( name ) {

			return this.attributes[ name ];

		}

		setAttribute( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		}

		deleteAttribute( name ) {

			delete this.attributes[ name ];

			return this;

		}

		hasAttribute( name ) {

			return this.attributes[ name ] !== undefined;

		}

		addGroup( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		}

		clearGroups() {

			this.groups = [];

		}

		setDrawRange( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		}

		applyMatrix4( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		applyQuaternion( q ) {

			_m1.makeRotationFromQuaternion( q );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateX( angle ) {

			// rotate geometry around world x-axis

			_m1.makeRotationX( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateY( angle ) {

			// rotate geometry around world y-axis

			_m1.makeRotationY( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		rotateZ( angle ) {

			// rotate geometry around world z-axis

			_m1.makeRotationZ( angle );

			this.applyMatrix4( _m1 );

			return this;

		}

		translate( x, y, z ) {

			// translate geometry

			_m1.makeTranslation( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		scale( x, y, z ) {

			// scale geometry

			_m1.makeScale( x, y, z );

			this.applyMatrix4( _m1 );

			return this;

		}

		lookAt( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		}

		center() {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		}

		setFromPoints( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		}

		computeBoundingBox() {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box$2.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( this.boundingBox.min, _box$2.min );
							this.boundingBox.expandByPoint( _vector$4 );

							_vector$4.addVectors( this.boundingBox.max, _box$2.max );
							this.boundingBox.expandByPoint( _vector$4 );

						} else {

							this.boundingBox.expandByPoint( _box$2.min );
							this.boundingBox.expandByPoint( _box$2.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		}

		computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
							_box$2.expandByPoint( _vector$4 );

							_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
							_box$2.expandByPoint( _vector$4 );

						} else {

							_box$2.expandByPoint( _boxMorphTargets.min );
							_box$2.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$2.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$4.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$4.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$4.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		}

		computeTangents() {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;

			const nVertices = positions.length / 3;

			if ( this.hasAttribute( 'tangent' ) === false ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			const tangents = this.getAttribute( 'tangent' ).array;

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( indices[ j + 0 ] );
					handleVertex( indices[ j + 1 ] );
					handleVertex( indices[ j + 2 ] );

				}

			}

		}

		computeVertexNormals() {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		}

		merge( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				const attribute1 = attributes[ key ];
				const attributeArray1 = attribute1.array;

				const attribute2 = geometry.attributes[ key ];
				const attributeArray2 = attribute2.array;

				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		}

		normalizeNormals() {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( normals, i );

				_vector$4.normalize();

				normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

			}

		}

		toNonIndexed() {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					if ( attribute.isInterleavedBufferAttribute ) {

						index = indices[ i ] * attribute.data.stride + attribute.offset;

					} else {

						index = indices[ i ] * itemSize;

					}

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			// for simplicity the code assumes attributes are not shared across geometries, see #15811

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				data.data.attributes[ key ] = attribute.toJSON( data.data );

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					array.push( attribute.toJSON( data.data ) );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		}

		clone() {

			 return new this.constructor().copy( this );

		}

		copy( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			// geometry generator parameters

			if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	class BoxGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

		static fromJSON( data ) {

			return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

		}

	}

	class PlaneGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		static fromJSON( data ) {

			return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {

		constructor() {

			super();

			this.isMaterial = true;

			Object.defineProperty( this, 'id', { value: materialId ++ } );

			this.uuid = generateUUID();

			this.name = '';
			this.type = 'Material';

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.shadowSide = null;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.dithering = false;

			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;

			this.visible = true;

			this.toneMapped = true;

			this.userData = {};

			this.version = 0;

			this._alphaTest = 0;

		}

		get alphaTest() {

			return this._alphaTest;

		}

		set alphaTest( value ) {

			if ( this._alphaTest > 0 !== value > 0 ) {

				this.version ++;

			}

			this._alphaTest = value;

		}

		onBuild( /* shaderobject, renderer */ ) {}

		onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

		onBeforeCompile( /* shaderobject, renderer */ ) {}

		customProgramCacheKey() {

			return this.onBeforeCompile.toString();

		}

		setValues( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;

				}

				// for backward compatibility if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( isRootObject ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen !== undefined ) data.sheen = this.sheen;
			if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
			if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
			if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
			if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
			if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

			if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

				data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

			}

			if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

				data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
			if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
			if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;

				if ( this.combine !== undefined ) data.combine = this.combine;

			}

			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
			if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
			if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.transmission !== undefined ) data.transmission = this.transmission;
			if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
			if ( this.thickness !== undefined ) data.thickness = this.thickness;
			if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
			if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
			if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.flatShading === true ) data.flatShading = this.flatShading;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( this.fog === false ) data.fog = false;

			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRootObject ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	function cloneUniformsGroups( src ) {

		const dst = [];

		for ( let u = 0; u < src.length; u ++ ) {

			dst.push( src[ u ].clone() );

		}

		return dst;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	class ShaderMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isShaderMaterial = true;

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};
			this.uniformsGroups = [];

			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;

			this.glslVersion = null;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		copy( source ) {

			super.copy( source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = cloneUniforms( source.uniforms );
			this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

			this.defines = Object.assign( {}, source.defines );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.fog = source.fog;
			this.lights = source.lights;
			this.clipping = source.clipping;

			this.extensions = Object.assign( {}, source.extensions );

			this.glslVersion = source.glslVersion;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for ( const name in this.uniforms ) {

				const uniform = this.uniforms[ name ];
				const value = uniform.value;

				if ( value && value.isTexture ) {

					data.uniforms[ name ] = {
						type: 't',
						value: value.toJSON( meta ).uuid
					};

				} else if ( value && value.isColor ) {

					data.uniforms[ name ] = {
						type: 'c',
						value: value.getHex()
					};

				} else if ( value && value.isVector2 ) {

					data.uniforms[ name ] = {
						type: 'v2',
						value: value.toArray()
					};

				} else if ( value && value.isVector3 ) {

					data.uniforms[ name ] = {
						type: 'v3',
						value: value.toArray()
					};

				} else if ( value && value.isVector4 ) {

					data.uniforms[ name ] = {
						type: 'v4',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix3 ) {

					data.uniforms[ name ] = {
						type: 'm3',
						value: value.toArray()
					};

				} else if ( value && value.isMatrix4 ) {

					data.uniforms[ name ] = {
						type: 'm4',
						value: value.toArray()
					};

				} else {

					data.uniforms[ name ] = {
						value: value
					};

					// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

				}

			}

			if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			const extensions = {};

			for ( const key in this.extensions ) {

				if ( this.extensions[ key ] === true ) extensions[ key ] = true;

			}

			if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

			return data;

		}

	}

	const _vector$3 = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

			this.origin = origin;
			this.direction = direction;

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$3 ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$3.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$3.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return _vector$3.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$3.subVectors( sphere.center, this.origin );
			const tca = _vector$3.dot( this.direction );
			const d2 = _vector$3.dot( _vector$3 ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$3 ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	class Triangle {

		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			this.a = a;
			this.b = b;
			this.c = c;

		}

		static getNormal( a, b, c, target ) {

			target.subVectors( c, b );
			_v0.subVectors( a, b );
			target.cross( _v0 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0.subVectors( c, a );
			_v1.subVectors( b, a );
			_v2.subVectors( point, a );

			const dot00 = _v0.dot( _v0 );
			const dot01 = _v0.dot( _v1 );
			const dot02 = _v0.dot( _v2 );
			const dot11 = _v1.dot( _v1 );
			const dot12 = _v1.dot( _v2 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3 );

			return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3 );

			target.set( 0, 0 );
			target.addScaledVector( uv1, _v3.x );
			target.addScaledVector( uv2, _v3.y );
			target.addScaledVector( uv3, _v3.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0.subVectors( c, b );
			_v1.subVectors( a, b );

			// strictly front facing
			return ( _v0.cross( _v1 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

			this.a.fromBufferAttribute( attribute, i0 );
			this.b.fromBufferAttribute( attribute, i1 );
			this.c.fromBufferAttribute( attribute, i2 );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0.subVectors( this.c, this.b );
			_v1.subVectors( this.a, this.b );

			return _v0.cross( _v1 ).length() * 0.5;

		}

		getMidpoint( target ) {

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	class MeshBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshBasicMaterial = true;

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _ray$1 = /*@__PURE__*/ new Ray();
	const _sphere$2 = /*@__PURE__*/ new Sphere();

	const _vA = /*@__PURE__*/ new Vector3();
	const _vB = /*@__PURE__*/ new Vector3();
	const _vC = /*@__PURE__*/ new Vector3();

	const _tempA = /*@__PURE__*/ new Vector3();
	const _tempB = /*@__PURE__*/ new Vector3();
	const _tempC = /*@__PURE__*/ new Vector3();

	const _morphA = /*@__PURE__*/ new Vector3();
	const _morphB = /*@__PURE__*/ new Vector3();
	const _morphC = /*@__PURE__*/ new Vector3();

	const _uvA = /*@__PURE__*/ new Vector2();
	const _uvB = /*@__PURE__*/ new Vector2();
	const _uvC = /*@__PURE__*/ new Vector2();

	const _intersectionPoint = /*@__PURE__*/ new Vector3();
	const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

	class Mesh extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

			super();

			this.isMesh = true;

			this.type = 'Mesh';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$2.copy( geometry.boundingSphere );
			_sphere$2.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray$1.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			let intersection;

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$1, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		}

	}

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA.fromBufferAttribute( position, a );
		_vB.fromBufferAttribute( position, b );
		_vC.fromBufferAttribute( position, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, a );
				_tempB.fromBufferAttribute( morphAttribute, b );
				_tempC.fromBufferAttribute( morphAttribute, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );
			_vB.add( _morphB );
			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA.fromBufferAttribute( uv, a );
				_uvB.fromBufferAttribute( uv, b );
				_uvC.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			if ( uv2 ) {

				_uvA.fromBufferAttribute( uv2, a );
				_uvB.fromBufferAttribute( uv2, b );
				_uvC.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

	var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

	var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common$1 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

	var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

	var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

	const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

	const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		alphatest_pars_fragment: alphatest_pars_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		iridescence_fragment: iridescence_fragment,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common$1,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphcolor_vertex: morphcolor_vertex,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normal_pars_fragment: normal_pars_fragment,
		normal_pars_vertex: normal_pars_vertex,
		normal_vertex: normal_vertex,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		iridescence_pars_fragment: iridescence_pars_fragment,
		output_fragment: output_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_vert: vertex$g,
		background_frag: fragment$g,
		cube_vert: vertex$f,
		cube_frag: fragment$f,
		depth_vert: vertex$e,
		depth_frag: fragment$e,
		distanceRGBA_vert: vertex$d,
		distanceRGBA_frag: fragment$d,
		equirect_vert: vertex$c,
		equirect_frag: fragment$c,
		linedashed_vert: vertex$b,
		linedashed_frag: fragment$b,
		meshbasic_vert: vertex$a,
		meshbasic_frag: fragment$a,
		meshlambert_vert: vertex$9,
		meshlambert_frag: fragment$9,
		meshmatcap_vert: vertex$8,
		meshmatcap_frag: fragment$8,
		meshnormal_vert: vertex$7,
		meshnormal_frag: fragment$7,
		meshphong_vert: vertex$6,
		meshphong_frag: fragment$6,
		meshphysical_vert: vertex$5,
		meshphysical_frag: fragment$5,
		meshtoon_vert: vertex$4,
		meshtoon_frag: fragment$4,
		points_vert: vertex$3,
		points_frag: fragment$3,
		shadow_vert: vertex$2,
		shadow_frag: fragment$2,
		sprite_vert: vertex$1,
		sprite_frag: fragment$1
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			uv2Transform: { value: /*@__PURE__*/ new Matrix3() },

			alphaMap: { value: null },
			alphaTest: { value: 0 }

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 }, // basic, lambert, phong
			ior: { value: 1.5 }, // physical
			refractionRatio: { value: 0.98 } // basic, lambert, phong

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() }

		},

		sprite: {

			diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
			opacity: { value: 1.0 },
			center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			alphaTest: { value: 0 },
			uvTransform: { value: /*@__PURE__*/ new Matrix3() }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag

		},

		sprite: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: /*@__PURE__*/ new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},

		cube: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: /*@__PURE__*/ new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: /*@__PURE__*/ mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
				clearcoatNormalMap: { value: null },
				iridescence: { value: 0 },
				iridescenceMap: { value: null },
				iridescenceIOR: { value: 1.3 },
				iridescenceThicknessMinimum: { value: 100 },
				iridescenceThicknessMaximum: { value: 400 },
				iridescenceThicknessMap: { value: null },
				sheen: { value: 0 },
				sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				sheenColorMap: { value: null },
				sheenRoughness: { value: 1 },
				sheenRoughnessMap: { value: null },
				transmission: { value: 0 },
				transmissionMap: { value: null },
				transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
				transmissionSamplerMap: { value: null },
				thickness: { value: 0 },
				thicknessMap: { value: null },
				attenuationDistance: { value: 0 },
				attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specularIntensity: { value: 1 },
				specularIntensityMap: { value: null },
				specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
				specularColorMap: { value: null },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	function WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = alpha === true ? 0 : 1;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene ) {

			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				background = cubemaps.get( background );

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				boxMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				planeMesh.layers.enableAll();

				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( 34921 );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;
		let forceUpdate = false;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( object, geometry, program, index );

				if ( updateBuffers ) saveCache( object, geometry, program, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			if ( updateBuffers || forceUpdate ) {

				forceUpdate = false;

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( 34963, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( object, geometry, program, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					const cachedAttribute = cachedAttributes[ name ];
					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( cachedAttribute === undefined ) return true;

					if ( cachedAttribute.attribute !== geometryAttribute ) return true;

					if ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;

					attributesNum ++;

				}

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( object, geometry, program, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			const programAttributes = program.getAttributes();

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let attribute = attributes[ name ];

					if ( attribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;

					}

					const data = {};
					data.attribute = attribute;

					if ( attribute && attribute.data ) {

						data.data = attribute.data;

					}

					cache[ name ] = data;

					attributesNum ++;

				}

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

			if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute.location >= 0 ) {

					let geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute === undefined ) {

						if ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;
						if ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;

					}

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data.isInstancedInterleavedBuffer ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( 34962, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									stride * bytesPerElement,
									( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement
								);

							}

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );

								}

								if ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

									enableAttribute( programAttribute.location + i );

								}

							}

							gl.bindBuffer( 34962, buffer );

							for ( let i = 0; i < programAttribute.locationSize; i ++ ) {

								vertexAttribPointer(
									programAttribute.location + i,
									size / programAttribute.locationSize,
									type,
									normalized,
									size * bytesPerElement,
									( size / programAttribute.locationSize ) * i * bytesPerElement
								);

							}

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute.location, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute.location, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute.location, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute.location, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();
			forceUpdate = true;

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatibility

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( 34930 );
		const maxVertexTextures = gl.getParameter( 35660 );
		const maxTextureSize = gl.getParameter( 3379 );
		const maxCubemapSize = gl.getParameter( 34076 );

		const maxAttributes = gl.getParameter( 34921 );
		const maxVertexUniforms = gl.getParameter( 36347 );
		const maxVaryings = gl.getParameter( 36348 );
		const maxFragmentUniforms = gl.getParameter( 36349 );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			drawBuffers: drawBuffers,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	class Camera extends Object3D {

		constructor() {

			super();

			this.isCamera = true;

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();

			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		}

		getWorldDirection( target ) {

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		}

		updateMatrixWorld( force ) {

			super.updateMatrixWorld( force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		updateWorldMatrix( updateParents, updateChildren ) {

			super.updateWorldMatrix( updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	class PerspectiveCamera extends Camera {

		constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

			super();

			this.isPerspectiveCamera = true;

			this.type = 'PerspectiveCamera';

			this.fov = fov;
			this.zoom = 1;

			this.near = near;
			this.far = far;
			this.focus = 10;

			this.aspect = aspect;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		}

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		}

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {

			const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		}

		getEffectiveFOV() {

			return RAD2DEG * 2 * Math.atan(
				Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

		}

		getFilmWidth() {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		}

		getFilmHeight() {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		}

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const near = this.near;
			let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	}

	const fov = 90, aspect = 1;

	class CubeCamera extends Object3D {

		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

				console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
				return;

			}

			this.renderTarget = renderTarget;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

		}

		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const renderTarget = this.renderTarget;

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentRenderTarget = renderer.getRenderTarget();

			const currentToneMapping = renderer.toneMapping;
			const currentXrEnabled = renderer.xr.enabled;

			renderer.toneMapping = NoToneMapping;
			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.toneMapping = currentToneMapping;
			renderer.xr.enabled = currentXrEnabled;

			renderTarget.texture.needsPMREMUpdate = true;

		}

	}

	class CubeTexture extends Texture {

		constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.isCubeTexture = true;

			this.flipY = false;

		}

		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor( size, options = {} ) {

			super( size, size, options );

			this.isWebGLCubeRenderTarget = true;

			const image = { width: size, height: size, depth: 1 };
			const images = [ image, image, image, image, image, image ];

			this.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture.isRenderTargetTexture = true;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		}

		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.encoding = texture.encoding;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		clear( renderer, color, depth, stencil ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class OrthographicCamera extends Camera {

		constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

			super();

			this.isOrthographicCamera = true;

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	const LOD_MIN = 4;

	// The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.
	const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

	// The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.
	const MAX_SAMPLES = 20;

	const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
	const _clearColor = /*@__PURE__*/ new Color();
	let _oldTarget = null;

	// Golden Ratio
	const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
	const INV_PHI = 1 / PHI;

	// Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.
	const _axisDirections = [
		/*@__PURE__*/ new Vector3( 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, 1 ),
		/*@__PURE__*/ new Vector3( 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),
		/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),
		/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),
		/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),
		/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),
		/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];

	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	class PMREMGenerator {

		constructor( renderer ) {

			this._renderer = renderer;
			this._pingPongRenderTarget = null;

			this._lodMax = 0;
			this._cubeSize = 0;
			this._lodPlanes = [];
			this._sizeLods = [];
			this._sigmas = [];

			this._blurMaterial = null;
			this._cubemapMaterial = null;
			this._equirectMaterial = null;

			this._compileMaterial( this._blurMaterial );

		}

		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */
		fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

			_oldTarget = this._renderer.getRenderTarget();

			this._setSize( 256 );

			const cubeUVRenderTarget = this._allocateTargets();
			cubeUVRenderTarget.depthBuffer = true;

			this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );

			if ( sigma > 0 ) {

				this._blur( cubeUVRenderTarget, 0, 0, sigma );

			}

			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * or HDR. The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromEquirectangular( equirectangular, renderTarget = null ) {

			return this._fromTexture( equirectangular, renderTarget );

		}

		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * or HDR. The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */
		fromCubemap( cubemap, renderTarget = null ) {

			return this._fromTexture( cubemap, renderTarget );

		}

		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileCubemapShader() {

			if ( this._cubemapMaterial === null ) {

				this._cubemapMaterial = _getCubemapMaterial();
				this._compileMaterial( this._cubemapMaterial );

			}

		}

		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */
		compileEquirectangularShader() {

			if ( this._equirectMaterial === null ) {

				this._equirectMaterial = _getEquirectMaterial();
				this._compileMaterial( this._equirectMaterial );

			}

		}

		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */
		dispose() {

			this._dispose();

			if ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();
			if ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();

		}

		// private interface

		_setSize( cubeSize ) {

			this._lodMax = Math.floor( Math.log2( cubeSize ) );
			this._cubeSize = Math.pow( 2, this._lodMax );

		}

		_dispose() {

			if ( this._blurMaterial !== null ) this._blurMaterial.dispose();

			if ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();

			for ( let i = 0; i < this._lodPlanes.length; i ++ ) {

				this._lodPlanes[ i ].dispose();

			}

		}

		_cleanup( outputTarget ) {

			this._renderer.setRenderTarget( _oldTarget );
			outputTarget.scissorTest = false;
			_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

		}

		_fromTexture( texture, renderTarget ) {

			if ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {

				this._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );

			} else { // Equirectangular

				this._setSize( texture.image.width / 4 );

			}

			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = renderTarget || this._allocateTargets();
			this._textureToCubeUV( texture, cubeUVRenderTarget );
			this._applyPMREM( cubeUVRenderTarget );
			this._cleanup( cubeUVRenderTarget );

			return cubeUVRenderTarget;

		}

		_allocateTargets() {

			const width = 3 * Math.max( this._cubeSize, 16 * 7 );
			const height = 4 * this._cubeSize;

			const params = {
				magFilter: LinearFilter,
				minFilter: LinearFilter,
				generateMipmaps: false,
				type: HalfFloatType,
				format: RGBAFormat,
				encoding: LinearEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget( width, height, params );

			if ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {

				if ( this._pingPongRenderTarget !== null ) {

					this._dispose();

				}

				this._pingPongRenderTarget = _createRenderTarget( width, height, params );

				const { _lodMax } = this;
				( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );

				this._blurMaterial = _getBlurShader( _lodMax, width, height );

			}

			return cubeUVRenderTarget;

		}

		_compileMaterial( material ) {

			const tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );
			this._renderer.compile( tmpMesh, _flatCamera );

		}

		_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
			const upSign = [ 1, - 1, 1, 1, 1, 1 ];
			const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
			const renderer = this._renderer;

			const originalAutoClear = renderer.autoClear;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor( _clearColor );

			renderer.toneMapping = NoToneMapping;
			renderer.autoClear = false;

			const backgroundMaterial = new MeshBasicMaterial( {
				name: 'PMREM.Background',
				side: BackSide,
				depthWrite: false,
				depthTest: false,
			} );

			const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

			let useSolidColor = false;
			const background = scene.background;

			if ( background ) {

				if ( background.isColor ) {

					backgroundMaterial.color.copy( background );
					scene.background = null;
					useSolidColor = true;

				}

			} else {

				backgroundMaterial.color.copy( _clearColor );
				useSolidColor = true;

			}

			for ( let i = 0; i < 6; i ++ ) {

				const col = i % 3;

				if ( col === 0 ) {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

				} else if ( col === 1 ) {

					cubeCamera.up.set( 0, 0, upSign[ i ] );
					cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

				} else {

					cubeCamera.up.set( 0, upSign[ i ], 0 );
					cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

				}

				const size = this._cubeSize;

				_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );

				renderer.setRenderTarget( cubeUVRenderTarget );

				if ( useSolidColor ) {

					renderer.render( backgroundBox, cubeCamera );

				}

				renderer.render( scene, cubeCamera );

			}

			backgroundBox.geometry.dispose();
			backgroundBox.material.dispose();

			renderer.toneMapping = toneMapping;
			renderer.autoClear = originalAutoClear;
			scene.background = background;

		}

		_textureToCubeUV( texture, cubeUVRenderTarget ) {

			const renderer = this._renderer;

			const isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );

			if ( isCubeTexture ) {

				if ( this._cubemapMaterial === null ) {

					this._cubemapMaterial = _getCubemapMaterial();

				}

				this._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;

			} else {

				if ( this._equirectMaterial === null ) {

					this._equirectMaterial = _getEquirectMaterial();

				}

			}

			const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
			const mesh = new Mesh( this._lodPlanes[ 0 ], material );

			const uniforms = material.uniforms;

			uniforms[ 'envMap' ].value = texture;

			const size = this._cubeSize;

			_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );

			renderer.setRenderTarget( cubeUVRenderTarget );
			renderer.render( mesh, _flatCamera );

		}

		_applyPMREM( cubeUVRenderTarget ) {

			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for ( let i = 1; i < this._lodPlanes.length; i ++ ) {

				const sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );

				const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

				this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

			}

			renderer.autoClear = autoClear;

		}

		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */
		_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(
				cubeUVRenderTarget,
				pingPongRenderTarget,
				lodIn,
				lodOut,
				sigma,
				'latitudinal',
				poleAxis );

			this._halfBlur(
				pingPongRenderTarget,
				cubeUVRenderTarget,
				lodOut,
				lodOut,
				sigma,
				'longitudinal',
				poleAxis );

		}

		_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

				console.error(
					'blur direction must be either latitudinal or longitudinal!' );

			}

			// Number of standard deviations at which to cut off the discrete approximation.
			const STANDARD_DEVIATIONS = 3;

			const blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );
			const blurUniforms = blurMaterial.uniforms;

			const pixels = this._sizeLods[ lodIn ] - 1;
			const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

			if ( samples > MAX_SAMPLES ) {

				console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

			}

			const weights = [];
			let sum = 0;

			for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

				const x = i / sigmaPixels;
				const weight = Math.exp( - x * x / 2 );
				weights.push( weight );

				if ( i === 0 ) {

					sum += weight;

				} else if ( i < samples ) {

					sum += 2 * weight;

				}

			}

			for ( let i = 0; i < weights.length; i ++ ) {

				weights[ i ] = weights[ i ] / sum;

			}

			blurUniforms[ 'envMap' ].value = targetIn.texture;
			blurUniforms[ 'samples' ].value = samples;
			blurUniforms[ 'weights' ].value = weights;
			blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

			if ( poleAxis ) {

				blurUniforms[ 'poleAxis' ].value = poleAxis;

			}

			const { _lodMax } = this;
			blurUniforms[ 'dTheta' ].value = radiansPerPixel;
			blurUniforms[ 'mipInt' ].value = _lodMax - lodIn;

			const outputSize = this._sizeLods[ lodOut ];
			const x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );
			const y = 4 * ( this._cubeSize - outputSize );

			_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
			renderer.setRenderTarget( targetOut );
			renderer.render( blurMesh, _flatCamera );

		}

	}



	function _createPlanes( lodMax ) {

		const lodPlanes = [];
		const sizeLods = [];
		const sigmas = [];

		let lod = lodMax;

		const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

		for ( let i = 0; i < totalLods; i ++ ) {

			const sizeLod = Math.pow( 2, lod );
			sizeLods.push( sizeLod );
			let sigma = 1.0 / sizeLod;

			if ( i > lodMax - LOD_MIN ) {

				sigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];

			} else if ( i === 0 ) {

				sigma = 0;

			}

			sigmas.push( sigma );

			const texelSize = 1.0 / ( sizeLod - 2 );
			const min = - texelSize;
			const max = 1 + texelSize;
			const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;

			const position = new Float32Array( positionSize * vertices * cubeFaces );
			const uv = new Float32Array( uvSize * vertices * cubeFaces );
			const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

			for ( let face = 0; face < cubeFaces; face ++ ) {

				const x = ( face % 3 ) * 2 / 3 - 1;
				const y = face > 2 ? 0 : - 1;
				const coordinates = [
					x, y, 0,
					x + 2 / 3, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y, 0,
					x + 2 / 3, y + 1, 0,
					x, y + 1, 0
				];
				position.set( coordinates, positionSize * vertices * face );
				uv.set( uv1, uvSize * vertices * face );
				const fill = [ face, face, face, face, face, face ];
				faceIndex.set( fill, faceIndexSize * vertices * face );

			}

			const planes = new BufferGeometry();
			planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
			planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
			planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
			lodPlanes.push( planes );

			if ( lod > LOD_MIN ) {

				lod --;

			}

		}

		return { lodPlanes, sizeLods, sigmas };

	}

	function _createRenderTarget( width, height, params ) {

		const cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;

	}

	function _setViewport( target, x, y, width, height ) {

		target.viewport.set( x, y, width, height );
		target.scissor.set( x, y, width, height );

	}

	function _getBlurShader( lodMax, width, height ) {

		const weights = new Float32Array( MAX_SAMPLES );
		const poleAxis = new Vector3( 0, 1, 0 );
		const shaderMaterial = new ShaderMaterial( {

			name: 'SphericalGaussianBlur',

			defines: {
				'n': MAX_SAMPLES,
				'CUBEUV_TEXEL_WIDTH': 1.0 / width,
				'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
				'CUBEUV_MAX_MIP': `${lodMax}.0`,
			},

			uniforms: {
				'envMap': { value: null },
				'samples': { value: 1 },
				'weights': { value: weights },
				'latitudinal': { value: false },
				'dTheta': { value: 0 },
				'mipInt': { value: 0 },
				'poleAxis': { value: poleAxis }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

		return shaderMaterial;

	}

	function _getEquirectMaterial() {

		return new ShaderMaterial( {

			name: 'EquirectangularToCubeUV',

			uniforms: {
				'envMap': { value: null }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCubemapMaterial() {

		return new ShaderMaterial( {

			name: 'CubemapToCubeUV',

			uniforms: {
				'envMap': { value: null },
				'flipEnvMap': { value: - 1 }
			},

			vertexShader: _getCommonVertexShader(),

			fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

			blending: NoBlending,
			depthTest: false,
			depthWrite: false

		} );

	}

	function _getCommonVertexShader() {

		return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

	}

	function WebGLCubeUVMaps( renderer ) {

		let cubeUVmaps = new WeakMap();

		let pmremGenerator = null;

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				const isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );
				const isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );

				// equirect/cube map to cubeUV conversion

				if ( isEquirectMap || isCubeMap ) {

					if ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {

						texture.needsPMREMUpdate = false;

						let renderTarget = cubeUVmaps.get( texture );

						if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

						renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );
						cubeUVmaps.set( texture, renderTarget );

						return renderTarget.texture;

					} else {

						if ( cubeUVmaps.has( texture ) ) {

							return cubeUVmaps.get( texture ).texture;

						} else {

							const image = texture.image;

							if ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {

								if ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );

								const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );
								cubeUVmaps.set( texture, renderTarget );

								texture.addEventListener( 'dispose', onTextureDispose );

								return renderTarget.texture;

							} else {

								// image not yet ready. try the conversion next frame

								return null;

							}

						}

					}

				}

			}

			return texture;

		}

		function isCubeTextureComplete( image ) {

			let count = 0;
			const length = 6;

			for ( let i = 0; i < length; i ++ ) {

				if ( image[ i ] !== undefined ) count ++;

			}

			return count === length;


		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemapUV = cubeUVmaps.get( texture );

			if ( cubemapUV !== undefined ) {

				cubeUVmaps.delete( texture );
				cubemapUV.dispose();

			}

		}

		function dispose() {

			cubeUVmaps = new WeakMap();

			if ( pmremGenerator !== null ) {

				pmremGenerator.dispose();
				pmremGenerator = null;

			}

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );
				getExtension( 'WEBGL_multisampled_render_to_texture' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			const attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	class DataArrayTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			this.isDataArrayTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function denormalize( morph, attribute ) {

		let denominator = 1;
		const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;

		if ( array instanceof Int8Array ) denominator = 127;
		else if ( array instanceof Uint8Array ) denominator = 255;
		else if ( array instanceof Uint16Array ) denominator = 65535;
		else if ( array instanceof Int16Array ) denominator = 32767;
		else if ( array instanceof Int32Array ) denominator = 2147483647;
		else console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );

		morph.divideScalar( denominator );

	}

	function WebGLMorphtargets( gl, capabilities, textures ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );
		const morphTextures = new WeakMap();
		const morph = new Vector4();

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, material, program ) {

			const objectInfluences = object.morphTargetInfluences;

			if ( capabilities.isWebGL2 === true ) {

				// instead of using attributes, the WebGL 2 code path encodes morph targets
				// into an array of data textures. Each layer represents a single morph target.

				const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
				const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

				let entry = morphTextures.get( geometry );

				if ( entry === undefined || entry.count !== morphTargetsCount ) {

					if ( entry !== undefined ) entry.texture.dispose();

					const hasMorphPosition = geometry.morphAttributes.position !== undefined;
					const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
					const hasMorphColors = geometry.morphAttributes.color !== undefined;

					const morphTargets = geometry.morphAttributes.position || [];
					const morphNormals = geometry.morphAttributes.normal || [];
					const morphColors = geometry.morphAttributes.color || [];

					let vertexDataCount = 0;

					if ( hasMorphPosition === true ) vertexDataCount = 1;
					if ( hasMorphNormals === true ) vertexDataCount = 2;
					if ( hasMorphColors === true ) vertexDataCount = 3;

					let width = geometry.attributes.position.count * vertexDataCount;
					let height = 1;

					if ( width > capabilities.maxTextureSize ) {

						height = Math.ceil( width / capabilities.maxTextureSize );
						width = capabilities.maxTextureSize;

					}

					const buffer = new Float32Array( width * height * 4 * morphTargetsCount );

					const texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );
					texture.type = FloatType;
					texture.needsUpdate = true;

					// fill buffer

					const vertexDataStride = vertexDataCount * 4;

					for ( let i = 0; i < morphTargetsCount; i ++ ) {

						const morphTarget = morphTargets[ i ];
						const morphNormal = morphNormals[ i ];
						const morphColor = morphColors[ i ];

						const offset = width * height * 4 * i;

						for ( let j = 0; j < morphTarget.count; j ++ ) {

							const stride = j * vertexDataStride;

							if ( hasMorphPosition === true ) {

								morph.fromBufferAttribute( morphTarget, j );

								if ( morphTarget.normalized === true ) denormalize( morph, morphTarget );

								buffer[ offset + stride + 0 ] = morph.x;
								buffer[ offset + stride + 1 ] = morph.y;
								buffer[ offset + stride + 2 ] = morph.z;
								buffer[ offset + stride + 3 ] = 0;

							}

							if ( hasMorphNormals === true ) {

								morph.fromBufferAttribute( morphNormal, j );

								if ( morphNormal.normalized === true ) denormalize( morph, morphNormal );

								buffer[ offset + stride + 4 ] = morph.x;
								buffer[ offset + stride + 5 ] = morph.y;
								buffer[ offset + stride + 6 ] = morph.z;
								buffer[ offset + stride + 7 ] = 0;

							}

							if ( hasMorphColors === true ) {

								morph.fromBufferAttribute( morphColor, j );

								if ( morphColor.normalized === true ) denormalize( morph, morphColor );

								buffer[ offset + stride + 8 ] = morph.x;
								buffer[ offset + stride + 9 ] = morph.y;
								buffer[ offset + stride + 10 ] = morph.z;
								buffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;

							}

						}

					}

					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2( width, height )
					};

					morphTextures.set( geometry, entry );

					function disposeTexture() {

						texture.dispose();

						morphTextures.delete( geometry );

						geometry.removeEventListener( 'dispose', disposeTexture );

					}

					geometry.addEventListener( 'dispose', disposeTexture );

				}

				//

				let morphInfluencesSum = 0;

				for ( let i = 0; i < objectInfluences.length; i ++ ) {

					morphInfluencesSum += objectInfluences[ i ];

				}

				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );

				program.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );
				program.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );


			} else {

				// When object doesn't have morph target influences defined, we treat it as a 0-length array
				// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

				const length = objectInfluences === undefined ? 0 : objectInfluences.length;

				let influences = influencesList[ geometry.id ];

				if ( influences === undefined || influences.length !== length ) {

					// initialise list

					influences = [];

					for ( let i = 0; i < length; i ++ ) {

						influences[ i ] = [ i, 0 ];

					}

					influencesList[ geometry.id ] = influences;

				}

				// Collect influences

				for ( let i = 0; i < length; i ++ ) {

					const influence = influences[ i ];

					influence[ 0 ] = i;
					influence[ 1 ] = objectInfluences[ i ];

				}

				influences.sort( absNumericalSort );

				for ( let i = 0; i < 8; i ++ ) {

					if ( i < length && influences[ i ][ 1 ] ) {

						workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
						workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

					} else {

						workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
						workInfluences[ i ][ 1 ] = 0;

					}

				}

				workInfluences.sort( numericalSort );

				const morphTargets = geometry.morphAttributes.position;
				const morphNormals = geometry.morphAttributes.normal;

				let morphInfluencesSum = 0;

				for ( let i = 0; i < 8; i ++ ) {

					const influence = workInfluences[ i ];
					const index = influence[ 0 ];
					const value = influence[ 1 ];

					if ( index !== Number.MAX_SAFE_INTEGER && value ) {

						if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

							geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

						}

						if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

							geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

						}

						morphInfluences[ i ] = value;
						morphInfluencesSum += value;

					} else {

						if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

							geometry.deleteAttribute( 'morphTarget' + i );

						}

						if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

							geometry.deleteAttribute( 'morphNormal' + i );

						}

						morphInfluences[ i ] = 0;

					}

				}

				// GLSL shader uses formula baseinfluence * base + sum(target * influence)
				// This allows us to switch between absolute morphs and relative morphs without changing shader code
				// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
				const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

				program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
				program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

			}

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				attributes.update( object.instanceMatrix, 34962 );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, 34962 );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	class Data3DTexture extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			this.isData3DTexture = true;

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = /*@__PURE__*/ new Texture();
	const emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();
	const empty3dTexture = /*@__PURE__*/ new Data3DTexture();
	const emptyCubeTexture = /*@__PURE__*/ new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or THREE.MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single integer / boolean

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single integer / boolean vector (from flat array)

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Single unsigned integer

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single unsigned integer vector (from flat array)

	function setValueV2ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3uiv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4ui( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4uiv( this.addr, v );

		copyArray( cache, v );

	}


	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || empty3dTexture, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTextureCube( v || emptyCubeTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyArrayTexture, unit );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT
			case 0x8dc6: return setValueV2ui; // _VEC2
			case 0x8dc7: return setValueV3ui; // _VEC3
			case 0x8dc8: return setValueV4ui; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}


	// Array of scalars

	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Array of vectors (from flat array or array of THREE.VectorN)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (from flat array or array of THREE.MatrixN)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of integer / boolean

	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	// Array of integer / boolean vectors (from flat array)

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}

	// Array of unsigned integer

	function setValueV1uiArray( gl, v ) {

		gl.uniform1uiv( this.addr, v );

	}

	// Array of unsigned integer vectors (from flat array)

	function setValueV2uiArray( gl, v ) {

		gl.uniform2uiv( this.addr, v );

	}

	function setValueV3uiArray( gl, v ) {

		gl.uniform3uiv( this.addr, v );

	}

	function setValueV4uiArray( gl, v ) {

		gl.uniform4uiv( this.addr, v );

	}


	// Array of textures (2D / 3D / Cube / 2DArray)

	function setValueT1Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT3DArray( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	function setValueT2DArrayArray( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );

		}

	}


	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x1405: return setValueV1uiArray; // UINT
			case 0x8dc6: return setValueV2uiArray; // _VEC2
			case 0x8dc7: return setValueV3uiArray; // _VEC3
			case 0x8dc8: return setValueV4uiArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3DArray;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArrayArray;

		}

	}

	// --- Uniform Classes ---

	class SingleUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class PureArrayUniform {

		constructor( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.cache = [];
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

	}

	class StructuredUniform {

		constructor( id ) {

			this.id = id;

			this.seq = [];
			this.map = {};

		}

		setValue( gl, value, textures ) {

			const seq = this.seq;

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				u.setValue( gl, value[ u.id ], textures );

			}

		}

	}

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	class WebGLUniforms {

		constructor( gl, program ) {

			this.seq = [];
			this.map = {};

			const n = gl.getProgramParameter( program, 35718 );

			for ( let i = 0; i < n; ++ i ) {

				const info = gl.getActiveUniform( program, i ),
					addr = gl.getUniformLocation( program, info.name );

				parseUniform( info, addr, this );

			}

		}

		setValue( gl, name, value, textures ) {

			const u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, textures );

		}

		setOptional( gl, object, name ) {

			const v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		}

		static upload( gl, seq, values, textures ) {

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {

					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, textures );

				}

			}

		}

		static seqWithValue( seq, values ) {

			const r = [];

			for ( let i = 0, n = seq.length; i !== n; ++ i ) {

				const u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		}

	}

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function handleSource( string, errorLine ) {

		const lines = string.split( '\n' );
		const lines2 = [];

		const from = Math.max( errorLine - 6, 0 );
		const to = Math.min( errorLine + 6, lines.length );

		for ( let i = from; i < to; i ++ ) {

			const line = i + 1;
			lines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );

		}

		return lines2.join( '\n' );

	}

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, 35713 );
		const errors = gl.getShaderInfoLog( shader ).trim();

		if ( status && errors === '' ) return '';

		const errorMatches = /ERROR: 0:(\d+)/.exec( errors );
		if ( errorMatches ) {

			// --enable-privileged-webgl-extension
			// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			const errorLine = parseInt( errorMatches[ 1 ] );
			return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource( gl.getShaderSource( shader ), errorLine );

		} else {

			return errors;

		}

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, 35721 );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			let locationSize = 1;
			if ( info.type === 35674 ) locationSize = 2;
			if ( info.type === 35675 ) locationSize = 3;
			if ( info.type === 35676 ) locationSize = 4;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = {
				type: info.type,
				location: gl.getAttribLocation( program, name ),
				locationSize: locationSize
			};

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		const string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string
			.replace( unrollLoopPattern, loopReplacer )
			.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

	}

	function deprecatedLoopReplacer( match, start, end, snippet ) {

		console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
		return loopReplacer( match, start, end, snippet );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function generateCubeUVSize( parameters ) {

		const imageHeight = parameters.envMapCubeUVHeight;

		if ( imageHeight === null ) return null;

		const maxMip = Math.log2( imageHeight ) - 2;

		const texelHeight = 1.0 / imageHeight;

		const texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );

		return { texelWidth, texelHeight, maxMip };

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		// TODO Send this event to Three.js DevTools
		// console.log( 'WebGLProgram', cacheKey );

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
		const envMapCubeUVSize = generateCubeUVSize( parameters );

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
				( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#if defined( USE_COLOR_ALPHA )',

				'	attribute vec4 color;',

				'#elif defined( USE_COLOR )',

				'	attribute vec3 color;',

				'#endif',

				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
				envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
				envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

				parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
				parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',

				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
				parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.alphaTest ? '#define USE_ALPHATEST' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
				parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

				parameters.transmission ? '#define USE_TRANSMISSION' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

				parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',
				parameters.opaque ? '#define OPAQUE' : '',

				ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

				parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'precision mediump sampler2DArray;',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, 35714 ) === false ) {

				runnable = false;

				const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error(
					'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
					'VALIDATE_STATUS ' + gl.getProgramParameter( program, 35715 ) + '\n\n' +
					'Program Info Log: ' + programLog + '\n' +
					vertexErrors + '\n' +
					fragmentErrors
				);

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	let _id = 0;

	class WebGLShaderCache {

		constructor() {

			this.shaderCache = new Map();
			this.materialCache = new Map();

		}

		update( material ) {

			const vertexShader = material.vertexShader;
			const fragmentShader = material.fragmentShader;

			const vertexShaderStage = this._getShaderStage( vertexShader );
			const fragmentShaderStage = this._getShaderStage( fragmentShader );

			const materialShaders = this._getShaderCacheForMaterial( material );

			if ( materialShaders.has( vertexShaderStage ) === false ) {

				materialShaders.add( vertexShaderStage );
				vertexShaderStage.usedTimes ++;

			}

			if ( materialShaders.has( fragmentShaderStage ) === false ) {

				materialShaders.add( fragmentShaderStage );
				fragmentShaderStage.usedTimes ++;

			}

			return this;

		}

		remove( material ) {

			const materialShaders = this.materialCache.get( material );

			for ( const shaderStage of materialShaders ) {

				shaderStage.usedTimes --;

				if ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );

			}

			this.materialCache.delete( material );

			return this;

		}

		getVertexShaderID( material ) {

			return this._getShaderStage( material.vertexShader ).id;

		}

		getFragmentShaderID( material ) {

			return this._getShaderStage( material.fragmentShader ).id;

		}

		dispose() {

			this.shaderCache.clear();
			this.materialCache.clear();

		}

		_getShaderCacheForMaterial( material ) {

			const cache = this.materialCache;

			if ( cache.has( material ) === false ) {

				cache.set( material, new Set() );

			}

			return cache.get( material );

		}

		_getShaderStage( code ) {

			const cache = this.shaderCache;

			if ( cache.has( code ) === false ) {

				const stage = new WebGLShaderStage( code );
				cache.set( code, stage );

			}

			return cache.get( code );

		}

	}

	class WebGLShaderStage {

		constructor( code ) {

			this.id = _id ++;

			this.code = code;
			this.usedTimes = 0;

		}

	}

	function WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {

		const _programLayers = new Layers();
		const _customShaders = new WebGLShaderCache();
		const programs = [];

		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const geometry = object.geometry;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			//

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			let morphTextureStride = 0;

			if ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;
			if ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;
			if ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;

			//

			let vertexShader, fragmentShader;
			let customVertexShaderID, customFragmentShaderID;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

				_customShaders.update( material );

				customVertexShaderID = _customShaders.getVertexShaderID( material );
				customFragmentShaderID = _customShaders.getFragmentShaderID( material );

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const useAlphaTest = material.alphaTest > 0;
			const useClearcoat = material.clearcoat > 0;
			const useIridescence = material.iridescence > 0;

			const parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget === null ) ? renderer.outputEncoding : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding ),
				map: !! material.map,
				matcap: !! material.matcap,
				envMap: !! envMap,
				envMapMode: envMap && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,

				decodeVideoTexture: !! material.map && ( material.map.isVideoTexture === true ) && ( material.map.encoding === sRGBEncoding ),

				clearcoat: useClearcoat,
				clearcoatMap: useClearcoat && !! material.clearcoatMap,
				clearcoatRoughnessMap: useClearcoat && !! material.clearcoatRoughnessMap,
				clearcoatNormalMap: useClearcoat && !! material.clearcoatNormalMap,

				iridescence: useIridescence,
				iridescenceMap: useIridescence && !! material.iridescenceMap,
				iridescenceThicknessMap: useIridescence && !! material.iridescenceThicknessMap,

				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				specularIntensityMap: !! material.specularIntensityMap,
				specularColorMap: !! material.specularColorMap,

				opaque: material.transparent === false && material.blending === NormalBlending,

				alphaMap: !! material.alphaMap,
				alphaTest: useAlphaTest,

				gradientMap: !! material.gradientMap,

				sheen: material.sheen > 0,
				sheenColorMap: !! material.sheenColorMap,
				sheenRoughnessMap: !! material.sheenRoughnessMap,

				transmission: material.transmission > 0,
				transmissionMap: !! material.transmissionMap,
				thicknessMap: !! material.thicknessMap,

				combine: material.combine,

				vertexTangents: ( !! material.normalMap && !! geometry.attributes.tangent ),
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || !! material.displacementMap || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || !! material.sheenColorMap || !! material.sheenRoughnessMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.iridescenceMap || !! material.iridescenceThicknessMap || material.transmission > 0 || !! material.transmissionMap || !! material.thicknessMap || !! material.specularIntensityMap || !! material.specularColorMap || material.sheen > 0 || !! material.sheenColorMap || !! material.sheenRoughnessMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog === true,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: !! material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: object.isSkinnedMesh === true,

				morphTargets: geometry.morphAttributes.position !== undefined,
				morphNormals: geometry.morphAttributes.normal !== undefined,
				morphColors: geometry.morphAttributes.color !== undefined,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				useDepthPacking: !! material.depthPacking,
				depthPacking: material.depthPacking || 0,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.customVertexShaderID );
				array.push( parameters.customFragmentShaderID );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				getProgramCacheKeyParameters( array, parameters );
				getProgramCacheKeyBooleans( array, parameters );
				array.push( renderer.outputEncoding );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getProgramCacheKeyParameters( array, parameters ) {

			array.push( parameters.precision );
			array.push( parameters.outputEncoding );
			array.push( parameters.envMapMode );
			array.push( parameters.envMapCubeUVHeight );
			array.push( parameters.combine );
			array.push( parameters.vertexUvs );
			array.push( parameters.fogExp2 );
			array.push( parameters.sizeAttenuation );
			array.push( parameters.morphTargetsCount );
			array.push( parameters.morphAttributeCount );
			array.push( parameters.numDirLights );
			array.push( parameters.numPointLights );
			array.push( parameters.numSpotLights );
			array.push( parameters.numHemiLights );
			array.push( parameters.numRectAreaLights );
			array.push( parameters.numDirLightShadows );
			array.push( parameters.numPointLightShadows );
			array.push( parameters.numSpotLightShadows );
			array.push( parameters.shadowMapType );
			array.push( parameters.toneMapping );
			array.push( parameters.numClippingPlanes );
			array.push( parameters.numClipIntersection );
			array.push( parameters.depthPacking );

		}

		function getProgramCacheKeyBooleans( array, parameters ) {

			_programLayers.disableAll();

			if ( parameters.isWebGL2 )
				_programLayers.enable( 0 );
			if ( parameters.supportsVertexTextures )
				_programLayers.enable( 1 );
			if ( parameters.instancing )
				_programLayers.enable( 2 );
			if ( parameters.instancingColor )
				_programLayers.enable( 3 );
			if ( parameters.map )
				_programLayers.enable( 4 );
			if ( parameters.matcap )
				_programLayers.enable( 5 );
			if ( parameters.envMap )
				_programLayers.enable( 6 );
			if ( parameters.lightMap )
				_programLayers.enable( 7 );
			if ( parameters.aoMap )
				_programLayers.enable( 8 );
			if ( parameters.emissiveMap )
				_programLayers.enable( 9 );
			if ( parameters.bumpMap )
				_programLayers.enable( 10 );
			if ( parameters.normalMap )
				_programLayers.enable( 11 );
			if ( parameters.objectSpaceNormalMap )
				_programLayers.enable( 12 );
			if ( parameters.tangentSpaceNormalMap )
				_programLayers.enable( 13 );
			if ( parameters.clearcoat )
				_programLayers.enable( 14 );
			if ( parameters.clearcoatMap )
				_programLayers.enable( 15 );
			if ( parameters.clearcoatRoughnessMap )
				_programLayers.enable( 16 );
			if ( parameters.clearcoatNormalMap )
				_programLayers.enable( 17 );
			if ( parameters.iridescence )
				_programLayers.enable( 18 );
			if ( parameters.iridescenceMap )
				_programLayers.enable( 19 );
			if ( parameters.iridescenceThicknessMap )
				_programLayers.enable( 20 );
			if ( parameters.displacementMap )
				_programLayers.enable( 21 );
			if ( parameters.specularMap )
				_programLayers.enable( 22 );
			if ( parameters.roughnessMap )
				_programLayers.enable( 23 );
			if ( parameters.metalnessMap )
				_programLayers.enable( 24 );
			if ( parameters.gradientMap )
				_programLayers.enable( 25 );
			if ( parameters.alphaMap )
				_programLayers.enable( 26 );
			if ( parameters.alphaTest )
				_programLayers.enable( 27 );
			if ( parameters.vertexColors )
				_programLayers.enable( 28 );
			if ( parameters.vertexAlphas )
				_programLayers.enable( 29 );
			if ( parameters.vertexUvs )
				_programLayers.enable( 30 );
			if ( parameters.vertexTangents )
				_programLayers.enable( 31 );
			if ( parameters.uvsVertexOnly )
				_programLayers.enable( 32 );
			if ( parameters.fog )
				_programLayers.enable( 33 );

			array.push( _programLayers.mask );
			_programLayers.disableAll();

			if ( parameters.useFog )
				_programLayers.enable( 0 );
			if ( parameters.flatShading )
				_programLayers.enable( 1 );
			if ( parameters.logarithmicDepthBuffer )
				_programLayers.enable( 2 );
			if ( parameters.skinning )
				_programLayers.enable( 3 );
			if ( parameters.morphTargets )
				_programLayers.enable( 4 );
			if ( parameters.morphNormals )
				_programLayers.enable( 5 );
			if ( parameters.morphColors )
				_programLayers.enable( 6 );
			if ( parameters.premultipliedAlpha )
				_programLayers.enable( 7 );
			if ( parameters.shadowMapEnabled )
				_programLayers.enable( 8 );
			if ( parameters.physicallyCorrectLights )
				_programLayers.enable( 9 );
			if ( parameters.doubleSided )
				_programLayers.enable( 10 );
			if ( parameters.flipSided )
				_programLayers.enable( 11 );
			if ( parameters.useDepthPacking )
				_programLayers.enable( 12 );
			if ( parameters.dithering )
				_programLayers.enable( 13 );
			if ( parameters.specularIntensityMap )
				_programLayers.enable( 14 );
			if ( parameters.specularColorMap )
				_programLayers.enable( 15 );
			if ( parameters.transmission )
				_programLayers.enable( 16 );
			if ( parameters.transmissionMap )
				_programLayers.enable( 17 );
			if ( parameters.thicknessMap )
				_programLayers.enable( 18 );
			if ( parameters.sheen )
				_programLayers.enable( 19 );
			if ( parameters.sheenColorMap )
				_programLayers.enable( 20 );
			if ( parameters.sheenRoughnessMap )
				_programLayers.enable( 21 );
			if ( parameters.decodeVideoTexture )
				_programLayers.enable( 22 );
			if ( parameters.opaque )
				_programLayers.enable( 23 );

			array.push( _programLayers.mask );

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		function releaseShaderCache( material ) {

			_customShaders.remove( material );

		}

		function dispose() {

			_customShaders.dispose();

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			releaseShaderCache: releaseShaderCache,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs,
			dispose: dispose
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transmissive = [];
		const transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.push( renderItem );

			} else if ( material.transparent === true ) {

				transparent.push( renderItem );

			} else {

				opaque.push( renderItem );

			}

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			if ( material.transmission > 0.0 ) {

				transmissive.unshift( renderItem );

			} else if ( material.transparent === true ) {

				transparent.unshift( renderItem );

			} else {

				opaque.unshift( renderItem );

			}

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			let list;

			if ( lists.has( scene ) === false ) {

				list = new WebGLRenderList();
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= lists.get( scene ).length ) {

					list = new WebGLRenderList();
					lists.get( scene ).push( list );

				} else {

					list = lists.get( scene )[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights, physicallyCorrectLights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;

			lights.sort( shadowCastingLightsFirst );

			// artist-friendly light intensity scaling factor
			const scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity * scaleFactor;
					g += color.g * intensity * scaleFactor;
					b += color.b * intensity * scaleFactor;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;
						state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

						numSpotShadows ++;

					}

					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( physicallyCorrectLights ) {

			lights.setup( lightsArray, physicallyCorrectLights );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			let renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStates.get( scene ).length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStates.get( scene ).push( renderState );

				} else {

					renderState = renderStates.get( scene )[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	class MeshDepthMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDepthMaterial = true;

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	class MeshDistanceMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshDistanceMaterial = true;

			this.type = 'MeshDistanceMaterial';

			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.referencePosition.copy( source.referencePosition );
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	function WebGLShadowMap( _renderer, _objects, _capabilities ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),
			_distanceMaterial = new MeshDistanceMaterial(),

			_materialCache = {},

			_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vertex,
			fragmentShader: fragment

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {

					if ( _shadowMapSize.x > _maxTextureSize ) {

						_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > _maxTextureSize ) {

						_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null ) {

					const pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			if ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {

				shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
				shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

				shadowMaterialVertical.needsUpdate = true;
				shadowMaterialHorizontal.needsUpdate = true;

			}

			if ( shadow.mapPass === null ) {

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );

			}

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {

			let result = null;

			const customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;

			if ( customMaterial !== undefined ) {

				result = customMaterial;

			} else {

				result = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;

			}

			if ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||
				( material.displacementMap && material.displacementScale !== 0 ) ||
				( material.alphaMap && material.alphaTest > 0 ) ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.alphaMap = material.alphaMap;
			result.alphaTest = material.alphaTest;

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.displacementMap = material.displacementMap;
			result.displacementScale = material.displacementScale;
			result.displacementBias = material.displacementBias;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				result.referencePosition.setFromMatrixPosition( light.matrixWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( 2960 );

						} else {

							disable( 2960 );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		const uboBindings = new WeakMap();
		const uboProgamMap = new WeakMap();

		let enabledCapabilities = {};

		let currentBoundFramebuffers = {};
		let currentDrawbuffers = new WeakMap();
		let defaultDrawbuffers = [];

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( 35661 );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const scissorParam = gl.getParameter( 3088 );
		const viewportParam = gl.getParameter( 2978 );

		const currentScissor = new Vector4().fromArray( scissorParam );
		const currentViewport = new Vector4().fromArray( viewportParam );

		function createTexture( type, target, count ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( let i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function bindFramebuffer( target, framebuffer ) {

			if ( currentBoundFramebuffers[ target ] !== framebuffer ) {

				gl.bindFramebuffer( target, framebuffer );

				currentBoundFramebuffers[ target ] = framebuffer;

				if ( isWebGL2 ) {

					// 36009 is equivalent to 36160

					if ( target === 36009 ) {

						currentBoundFramebuffers[ 36160 ] = framebuffer;

					}

					if ( target === 36160 ) {

						currentBoundFramebuffers[ 36009 ] = framebuffer;

					}

				}

				return true;

			}

			return false;

		}

		function drawBuffers( renderTarget, framebuffer ) {

			let drawBuffers = defaultDrawbuffers;

			let needsUpdate = false;

			if ( renderTarget ) {

				drawBuffers = currentDrawbuffers.get( framebuffer );

				if ( drawBuffers === undefined ) {

					drawBuffers = [];
					currentDrawbuffers.set( framebuffer, drawBuffers );

				}

				if ( renderTarget.isWebGLMultipleRenderTargets ) {

					const textures = renderTarget.texture;

					if ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== 36064 ) {

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							drawBuffers[ i ] = 36064 + i;

						}

						drawBuffers.length = textures.length;

						needsUpdate = true;

					}

				} else {

					if ( drawBuffers[ 0 ] !== 36064 ) {

						drawBuffers[ 0 ] = 36064;

						needsUpdate = true;

					}

				}

			} else {

				if ( drawBuffers[ 0 ] !== 1029 ) {

					drawBuffers[ 0 ] = 1029;

					needsUpdate = true;

				}

			}

			if ( needsUpdate ) {

				if ( capabilities.isWebGL2 ) {

					gl.drawBuffers( drawBuffers );

				} else {

					extensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );

				}

			}


		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: 32774,
			[ SubtractEquation ]: 32778,
			[ ReverseSubtractEquation ]: 32779
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = 32775;
			equationToGL[ MaxEquation ] = 32776;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: 0,
			[ OneFactor ]: 1,
			[ SrcColorFactor ]: 768,
			[ SrcAlphaFactor ]: 770,
			[ SrcAlphaSaturateFactor ]: 776,
			[ DstColorFactor ]: 774,
			[ DstAlphaFactor ]: 772,
			[ OneMinusSrcColorFactor ]: 769,
			[ OneMinusSrcAlphaFactor ]: 771,
			[ OneMinusDstColorFactor ]: 775,
			[ OneMinusDstAlphaFactor ]: 773
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 769, 0, 1 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 769, 0, 1 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			material.alphaToCoverage === true
				? enable( 32926 )
				: disable( 32926 );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			let boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage2D() {

			try {

				gl.texSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texSubImage3D() {

			try {

				gl.texSubImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function compressedTexSubImage2D() {

			try {

				gl.compressedTexSubImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage2D() {

			try {

				gl.texStorage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texStorage3D() {

			try {

				gl.texStorage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		function updateUBOMapping( uniformsGroup, program ) {

			let mapping = uboProgamMap.get( program );

			if ( mapping === undefined ) {

				mapping = new WeakMap();

				uboProgamMap.set( program, mapping );

			}

			let blockIndex = mapping.get( uniformsGroup );

			if ( blockIndex === undefined ) {

				blockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );

				mapping.set( uniformsGroup, blockIndex );

			}

		}

		function uniformBlockBinding( uniformsGroup, program ) {

			const mapping = uboProgamMap.get( program );
			const blockIndex = mapping.get( uniformsGroup );

			if ( uboBindings.get( uniformsGroup ) !== blockIndex ) {

				// bind shader specific block index to global block point

				gl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );

				uboBindings.set( uniformsGroup, blockIndex );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( 3042 );
			gl.disable( 2884 );
			gl.disable( 2929 );
			gl.disable( 32823 );
			gl.disable( 3089 );
			gl.disable( 2960 );
			gl.disable( 32926 );

			gl.blendEquation( 32774 );
			gl.blendFunc( 1, 0 );
			gl.blendFuncSeparate( 1, 0, 1, 0 );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( 513 );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( 519, 0, 0xffffffff );
			gl.stencilOp( 7680, 7680, 7680 );
			gl.clearStencil( 0 );

			gl.cullFace( 1029 );
			gl.frontFace( 2305 );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( 33984 );

			gl.bindFramebuffer( 36160, null );

			if ( isWebGL2 === true ) {

				gl.bindFramebuffer( 36009, null );
				gl.bindFramebuffer( 36008, null );

			}

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentBoundFramebuffers = {};
			currentDrawbuffers = new WeakMap();
			defaultDrawbuffers = [];

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			currentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );
			currentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			bindFramebuffer: bindFramebuffer,
			drawBuffers: drawBuffers,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			updateUBOMapping: updateUBOMapping,
			uniformBlockBinding: uniformBlockBinding,

			texStorage2D: texStorage2D,
			texStorage3D: texStorage3D,
			texSubImage2D: texSubImage2D,
			texSubImage3D: texSubImage3D,
			compressedTexSubImage2D: compressedTexSubImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;
		const multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;
		const supportsInvalidateFramebuffer = /OculusBrowser/g.test( navigator.userAgent );

		const _videoTextures = new WeakMap();
		let _canvas;

		const _sources = new WeakMap(); // maps WebglTexture objects to instances of Source

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				// eslint-disable-next-line compat/compat
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				// eslint-disable-next-line compat/compat
				new OffscreenCanvas( width, height ) : createElementNS( 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo$1( image ) {

			return isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target ) {

			_gl.generateMipmap( target );

		}

		function getInternalFormat( internalFormatName, glFormat, glType, encoding, isVideoTexture = false ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;

			}

			if ( glFormat === 33319 ) {

				if ( glType === 5126 ) internalFormat = 33328;
				if ( glType === 5131 ) internalFormat = 33327;
				if ( glType === 5121 ) internalFormat = 33323;

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = ( encoding === sRGBEncoding && isVideoTexture === false ) ? 35907 : 32856;
				if ( glType === 32819 ) internalFormat = 32854;
				if ( glType === 32820 ) internalFormat = 32855;

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 33327 || internalFormat === 33328 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		function getMipLevels( texture, image, supportsMips ) {

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {

				return Math.log2( Math.max( image.width, image.height ) ) + 1;

			} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {

				// user-defined mipmaps

				return texture.mipmaps.length;

			} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {

				return image.mipmaps.length;

			} else {

				// texture without mipmaps (only base level)

				return 1;

			}

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			// check if it's necessary to remove the WebGLTexture object

			const source = texture.source;
			const webglTextures = _sources.get( source );

			if ( webglTextures ) {

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];
				webglTexture.usedTimes --;

				// the WebGLTexture object is not used anymore, remove it

				if ( webglTexture.usedTimes === 0 ) {

					deleteTexture( texture );

				}

				// remove the weak map entry if no WebGLTexture uses the source anymore

				if ( Object.keys( webglTextures ).length === 0 ) {

					_sources.delete( source );

				}

			}

			properties.remove( texture );

		}

		function deleteTexture( texture ) {

			const textureProperties = properties.get( texture );
			_gl.deleteTexture( textureProperties.__webglTexture );

			const source = texture.source;
			const webglTextures = _sources.get( source );
			delete webglTextures[ textureProperties.__cacheKey ];

			info.memory.textures --;

		}

		function deallocateRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

				info.memory.textures --;

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );

				if ( renderTargetProperties.__webglColorRenderbuffer ) {

					for ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {

						if ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

				}

				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			if ( renderTarget.isWebGLMultipleRenderTargets ) {

				for ( let i = 0, il = texture.length; i < il; i ++ ) {

					const attachmentProperties = properties.get( texture[ i ] );

					if ( attachmentProperties.__webglTexture ) {

						_gl.deleteTexture( attachmentProperties.__webglTexture );

						info.memory.textures --;

					}

					properties.remove( texture[ i ] );

				}

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		function getTextureCacheKey( texture ) {

			const array = [];

			array.push( texture.wrapS );
			array.push( texture.wrapT );
			array.push( texture.magFilter );
			array.push( texture.minFilter );
			array.push( texture.anisotropy );
			array.push( texture.internalFormat );
			array.push( texture.format );
			array.push( texture.type );
			array.push( texture.generateMipmaps );
			array.push( texture.premultiplyAlpha );
			array.push( texture.flipY );
			array.push( texture.unpackAlignment );
			array.push( texture.encoding );

			return array.join();

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === null ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: 10497,
			[ ClampToEdgeWrapping ]: 33071,
			[ MirroredRepeatWrapping ]: 33648
		};

		const filterToGL = {
			[ NearestFilter ]: 9728,
			[ NearestMipmapNearestFilter ]: 9984,
			[ NearestMipmapLinearFilter ]: 9986,

			[ LinearFilter ]: 9729,
			[ LinearMipmapNearestFilter ]: 9985,
			[ LinearMipmapLinearFilter ]: 9987
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			let forceUpload = false;

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

			}

			// create Source <-> WebGLTextures mapping if necessary

			const source = texture.source;
			let webglTextures = _sources.get( source );

			if ( webglTextures === undefined ) {

				webglTextures = {};
				_sources.set( source, webglTextures );

			}

			// check if there is already a WebGLTexture object for the given texture parameters

			const textureCacheKey = getTextureCacheKey( texture );

			if ( textureCacheKey !== textureProperties.__cacheKey ) {

				// if not, create a new instance of WebGLTexture

				if ( webglTextures[ textureCacheKey ] === undefined ) {

					// create new entry

					webglTextures[ textureCacheKey ] = {
						texture: _gl.createTexture(),
						usedTimes: 0
					};

					info.memory.textures ++;

					// when a new instance of WebGLTexture was created, a texture upload is required
					// even if the image contents are identical

					forceUpload = true;

				}

				webglTextures[ textureCacheKey ].usedTimes ++;

				// every time the texture cache key changes, it's necessary to check if an instance of
				// WebGLTexture can be deleted in order to avoid a memory leak.

				const webglTexture = webglTextures[ textureProperties.__cacheKey ];

				if ( webglTexture !== undefined ) {

					webglTextures[ textureProperties.__cacheKey ].usedTimes --;

					if ( webglTexture.usedTimes === 0 ) {

						deleteTexture( texture );

					}

				}

				// store references to cache key and WebGLTexture object

				textureProperties.__cacheKey = textureCacheKey;
				textureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;

			}

			return forceUpload;

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = 3553;

			if ( texture.isDataArrayTexture ) textureType = 35866;
			if ( texture.isData3DTexture ) textureType = 32879;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			if ( source.version !== source.__currentVersion || forceUpload === true ) {

				_gl.pixelStorei( 37440, texture.flipY );
				_gl.pixelStorei( 37441, texture.premultiplyAlpha );
				_gl.pixelStorei( 3317, texture.unpackAlignment );
				_gl.pixelStorei( 37443, 0 );

				const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;
				let image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
				image = verifyColorSpace( texture, image );

				const supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.encoding );

				let glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture );

				setTextureParameters( textureType, texture, supportsMips );

				let mipmap;
				const mipmaps = texture.mipmaps;

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( source.__currentVersion === undefined ) || ( forceUpload === true );
				const levels = getMipLevels( texture, image, supportsMips );

				if ( texture.isDepthTexture ) {

					// populate depth texture with dummy data

					glInternalFormat = 6402;

					if ( isWebGL2 ) {

						if ( texture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( texture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						} else if ( texture.type === UnsignedInt248Type ) {

							glInternalFormat = 35056;

						} else {

							glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

						}

					} else {

						if ( texture.type === FloatType ) {

							console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

						}

					}

					// validation checks for WebGL 1

					if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

							texture.type = UnsignedIntType;
							glType = utils.convert( texture.type );

						}

					}

					if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

						// Depth stencil textures need the DEPTH_STENCIL internal format
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						glInternalFormat = 34041;

						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {

							console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

							texture.type = UnsignedInt248Type;
							glType = utils.convert( texture.type );

						}

					}

					//

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( 3553, 1, glInternalFormat, image.width, image.height );

						} else {

							state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

						}

					}

				} else if ( texture.isDataTexture ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( 3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );

						} else {

							state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );

						}

					}

				} else if ( texture.isCompressedTexture ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

					}

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat ) {

							if ( glFormat !== null ) {

								if ( useTexStorage ) {

									state.compressedTexSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

								} else {

									state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								}

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				} else if ( texture.isDataArrayTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( 35866, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( 35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isData3DTexture ) {

					if ( useTexStorage ) {

						if ( allocateMemory ) {

							state.texStorage3D( 32879, levels, glInternalFormat, image.width, image.height, image.depth );

						}

						state.texSubImage3D( 32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );

					} else {

						state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );

					}

				} else if ( texture.isFramebufferTexture ) {

					if ( allocateMemory ) {

						if ( useTexStorage ) {

							state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

						} else {

							let width = image.width, height = image.height;

							for ( let i = 0; i < levels; i ++ ) {

								state.texImage2D( 3553, i, glInternalFormat, width, height, 0, glFormat, glType, null );

								width >>= 1;
								height >>= 1;

							}

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && supportsMips ) {

						if ( useTexStorage && allocateMemory ) {

							state.texStorage2D( 3553, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );

						}

						for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];

							if ( useTexStorage ) {

								state.texSubImage2D( 3553, i, 0, 0, glFormat, glType, mipmap );

							} else {

								state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

							}

						}

						texture.generateMipmaps = false;

					} else {

						if ( useTexStorage ) {

							if ( allocateMemory ) {

								state.texStorage2D( 3553, levels, glInternalFormat, image.width, image.height );

							}

							state.texSubImage2D( 3553, 0, 0, 0, glFormat, glType, image );

						} else {

							state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( textureType );

				}

				source.__currentVersion = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			const forceUpload = initTexture( textureProperties, texture );
			const source = texture.source;

			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, textureProperties.__webglTexture );

			if ( source.version !== source.__currentVersion || forceUpload === true ) {

				_gl.pixelStorei( 37440, texture.flipY );
				_gl.pixelStorei( 37441, texture.premultiplyAlpha );
				_gl.pixelStorei( 3317, texture.unpackAlignment );
				_gl.pixelStorei( 37443, 0 );

				const isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );
				const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				const cubeImage = [];

				for ( let i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

					cubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );

				}

				const image = cubeImage[ 0 ],
					supportsMips = isPowerOfTwo$1( image ) || isWebGL2,
					glFormat = utils.convert( texture.format, texture.encoding ),
					glType = utils.convert( texture.type ),
					glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );

				const useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );
				const allocateMemory = ( source.__currentVersion === undefined ) || ( forceUpload === true );
				let levels = getMipLevels( texture, image, supportsMips );

				setTextureParameters( 34067, texture, supportsMips );

				let mipmaps;

				if ( isCompressed ) {

					if ( useTexStorage && allocateMemory ) {

						state.texStorage2D( 34067, levels, glInternalFormat, image.width, image.height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						mipmaps = cubeImage[ i ].mipmaps;

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat ) {

								if ( glFormat !== null ) {

									if ( useTexStorage ) {

										state.compressedTexSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );

									} else {

										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									}

								} else {

									console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

								}

							} else {

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );

								} else {

									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

				} else {

					mipmaps = texture.mipmaps;

					if ( useTexStorage && allocateMemory ) {

						// TODO: Uniformly handle mipmap definitions
						// Normal textures and compressed cube textures define base level + mips with their mipmap array
						// Uncompressed cube textures use their mipmap array only for mips (no base level)

						if ( mipmaps.length > 0 ) levels ++;

						state.texStorage2D( 34067, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );

					}

					for ( let i = 0; i < 6; i ++ ) {

						if ( isDataTexture ) {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];
								const mipmapImage = mipmap.image[ i ].image;

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );

								} else {

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

								}

							}

						} else {

							if ( useTexStorage ) {

								state.texSubImage2D( 34069 + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );

							} else {

								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

							}

							for ( let j = 0; j < mipmaps.length; j ++ ) {

								const mipmap = mipmaps[ j ];

								if ( useTexStorage ) {

									state.texSubImage2D( 34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );

								} else {

									state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

								}

							}

						}

					}

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					// We assume images for cube map have the same size.
					generateMipmap( 34067 );

				}

				source.__currentVersion = source.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			textureProperties.__version = texture.version;

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {

			const glFormat = utils.convert( texture.format, texture.encoding );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
			const renderTargetProperties = properties.get( renderTarget );

			if ( ! renderTargetProperties.__hasExternalTextures ) {

				if ( textureTarget === 32879 || textureTarget === 35866 ) {

					state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

				} else {

					state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				}

			}

			state.bindFramebuffer( 36160, framebuffer );

			if ( useMultisampledRTT( renderTarget ) ) {

				multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );

			} else {

				_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );

			}

			state.bindFramebuffer( 36160, null );

		}


		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = 33189;

				if ( isMultisample || useMultisampledRTT( renderTarget ) ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = 36012;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = 33190;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				const samples = getRenderTargetSamples( renderTarget );

				if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

					_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

				} else if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, 35056, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

				for ( let i = 0; i < textures.length; i ++ ) {

					const texture = textures[ i ];

					const glFormat = utils.convert( texture.format, texture.encoding );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
					const samples = getRenderTargetSamples( renderTarget );

					if ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {

						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else if ( useMultisampledRTT( renderTarget ) ) {

						multisampledRTTExt.renderbufferStorageMultisampleEXT( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					} else {

						_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

					}

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			state.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
			const samples = getRenderTargetSamples( renderTarget );

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 36096, 3553, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

				}

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				if ( useMultisampledRTT( renderTarget ) ) {

					multisampledRTTExt.framebufferTexture2DMultisampleEXT( 36160, 33306, 3553, webglDepthTexture, 0, samples );

				} else {

					_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

				}

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );
			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			state.bindFramebuffer( 36160, null );

		}

		// rebind framebuffer with external textures
		function rebindTextures( renderTarget, colorTexture, depthTexture ) {

			const renderTargetProperties = properties.get( renderTarget );

			if ( colorTexture !== undefined ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553 );

			}

			if ( depthTexture !== undefined ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			if ( renderTarget.isWebGLMultipleRenderTargets !== true ) {

				if ( textureProperties.__webglTexture === undefined ) {

					textureProperties.__webglTexture = _gl.createTexture();

				}

				textureProperties.__version = texture.version;
				info.memory.textures ++;

			}

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );
			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultipleRenderTargets ) {

					if ( capabilities.drawBuffers ) {

						const textures = renderTarget.texture;

						for ( let i = 0, il = textures.length; i < il; i ++ ) {

							const attachmentProperties = properties.get( textures[ i ] );

							if ( attachmentProperties.__webglTexture === undefined ) {

								attachmentProperties.__webglTexture = _gl.createTexture();

								info.memory.textures ++;

							}

						}

					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );

					}

				}

				if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

					const textures = isMultipleRenderTargets ? texture : [ texture ];

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = [];

					state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );

					for ( let i = 0; i < textures.length; i ++ ) {

						const texture = textures[ i ];
						renderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const glFormat = utils.convert( texture.format, texture.encoding );
						const glType = utils.convert( texture.type );
						const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.encoding );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					state.bindFramebuffer( 36160, null );

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, 36064, 34069 + i );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( 34067 );

				}

				state.unbindTexture();

			} else if ( isMultipleRenderTargets ) {

				const textures = renderTarget.texture;

				for ( let i = 0, il = textures.length; i < il; i ++ ) {

					const attachment = textures[ i ];
					const attachmentProperties = properties.get( attachment );

					state.bindTexture( 3553, attachmentProperties.__webglTexture );
					setTextureParameters( 3553, attachment, supportsMips );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553 );

					if ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {

						generateMipmap( 3553 );

					}

				}

				state.unbindTexture();

			} else {

				let glTextureType = 3553;

				if ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {

					if ( isWebGL2 ) {

						glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;

					} else {

						console.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType );

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( glTextureType );

				}

				state.unbindTexture();

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;

			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];

			for ( let i = 0, il = textures.length; i < il; i ++ ) {

				const texture = textures[ i ];

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
					const webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					generateMipmap( target );
					state.unbindTexture();

				}

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {

				const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];
				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;
				const invalidationArray = [];
				const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
				const renderTargetProperties = properties.get( renderTarget );
				const isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );

				// If MRT we need to remove FBO attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, null );

						state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( 36009, 36064 + i, 3553, null, 0 );

					}

				}

				state.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				state.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				for ( let i = 0; i < textures.length; i ++ ) {

					invalidationArray.push( 36064 + i );

					if ( renderTarget.depthBuffer ) {

						invalidationArray.push( depthStyle );

					}

					const ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;

					if ( ignoreDepthValues === false ) {

						if ( renderTarget.depthBuffer ) mask |= 256;
						if ( renderTarget.stencilBuffer ) mask |= 1024;

					}

					if ( isMultipleRenderTargets ) {

						_gl.framebufferRenderbuffer( 36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

					}

					if ( ignoreDepthValues === true ) {

						_gl.invalidateFramebuffer( 36008, [ depthStyle ] );
						_gl.invalidateFramebuffer( 36009, [ depthStyle ] );

					}

					if ( isMultipleRenderTargets ) {

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;
						_gl.framebufferTexture2D( 36009, 36064, 3553, webglTexture, 0 );

					}

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

					if ( supportsInvalidateFramebuffer ) {

						_gl.invalidateFramebuffer( 36008, invalidationArray );

					}


				}

				state.bindFramebuffer( 36008, null );
				state.bindFramebuffer( 36009, null );

				// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments
				if ( isMultipleRenderTargets ) {

					for ( let i = 0; i < textures.length; i ++ ) {

						state.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064 + i, 36161, renderTargetProperties.__webglColorRenderbuffer[ i ] );

						const webglTexture = properties.get( textures[ i ] ).__webglTexture;

						state.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
						_gl.framebufferTexture2D( 36009, 36064 + i, 3553, webglTexture, 0 );

					}

				}

				state.bindFramebuffer( 36009, renderTargetProperties.__webglMultisampledFramebuffer );

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return Math.min( maxSamples, renderTarget.samples );

		}

		function useMultisampledRTT( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			return isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		function verifyColorSpace( texture, image ) {

			const encoding = texture.encoding;
			const format = texture.format;
			const type = texture.type;

			if ( texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat ) return image;

			if ( encoding !== LinearEncoding ) {

				// sRGB

				if ( encoding === sRGBEncoding ) {

					if ( isWebGL2 === false ) {

						// in WebGL 1, try to use EXT_sRGB extension and unsized formats

						if ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {

							texture.format = _SRGBAFormat;

							// it's not possible to generate mips in WebGL 1 with this extension

							texture.minFilter = LinearFilter;
							texture.generateMipmaps = false;

						} else {

							// slow fallback (CPU decode)

							image = ImageUtils.sRGBToLinear( image );

						}

					} else {

						// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format

						if ( format !== RGBAFormat || type !== UnsignedByteType ) {

							console.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );

						}

					}

				} else {

					console.error( 'THREE.WebGLTextures: Unsupported texture encoding:', encoding );

				}

			}

			return image;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.rebindTextures = rebindTextures;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.setupDepthRenderbuffer = setupDepthRenderbuffer;
		this.setupFrameBufferTexture = setupFrameBufferTexture;
		this.useMultisampledRTT = useMultisampledRTT;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p, encoding = null ) {

			let extension;

			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;

			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return 5131;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;

			if ( p === RGBFormat ) {

				console.warn( 'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228' );
				return 6408;

			}

			// WebGL 1 sRGB fallback

			if ( p === _SRGBAFormat ) {

				extension = extensions.get( 'EXT_sRGB' );

				if ( extension !== null ) {

					return extension.SRGB_ALPHA_EXT;

				} else {

					return null;

				}

			}

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) return 36244;
			if ( p === RGFormat ) return 33319;
			if ( p === RGIntegerFormat ) return 33320;
			if ( p === RGBAIntegerFormat ) return 36249;

			// S3TC

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				if ( encoding === sRGBEncoding ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				} else {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					} else {

						return null;

					}

				}

			}

			// PVRTC

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			// ETC1

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			// ETC2

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;

				} else {

					return null;

				}

			}

			// ASTC

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					if ( p === RGBA_ASTC_4x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if ( p === RGBA_ASTC_5x4_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if ( p === RGBA_ASTC_5x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if ( p === RGBA_ASTC_6x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if ( p === RGBA_ASTC_6x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if ( p === RGBA_ASTC_8x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if ( p === RGBA_ASTC_8x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if ( p === RGBA_ASTC_8x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if ( p === RGBA_ASTC_10x5_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if ( p === RGBA_ASTC_10x6_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if ( p === RGBA_ASTC_10x8_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if ( p === RGBA_ASTC_10x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if ( p === RGBA_ASTC_12x10_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if ( p === RGBA_ASTC_12x12_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;

				} else {

					return null;

				}

			}

			// BPTC

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					if ( p === RGBA_BPTC_Format ) return ( encoding === sRGBEncoding ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;

				} else {

					return null;

				}

			}

			//

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return 34042;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

			// if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

			return ( gl[ p ] !== undefined ) ? gl[ p ] : null;

		}

		return { convert: convert };

	}

	class ArrayCamera extends PerspectiveCamera {

		constructor( array = [] ) {

			super();

			this.isArrayCamera = true;

			this.cameras = array;

		}

	}

	class Group extends Object3D {

		constructor() {

			super();

			this.isGroup = true;

			this.type = 'Group';

		}

	}

	const _moveEvent = { type: 'move' };

	class WebXRController {

		constructor() {

			this._targetRay = null;
			this._grip = null;
			this._hand = null;

		}

		getHandSpace() {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		}

		getTargetRaySpace() {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();

			}

			return this._targetRay;

		}

		getGripSpace() {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();

			}

			return this._grip;

		}

		dispatchEvent( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		}

		disconnect( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		}

		update( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						if ( hand.joints[ inputjoint.jointName ] === undefined ) {

							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[ inputjoint.jointName ] = joint;
							// ??
							hand.add( joint );

						}

						const joint = hand.joints[ inputjoint.jointName ];

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

							if ( gripPose.linearVelocity ) {

								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy( gripPose.linearVelocity );

							} else {

								grip.hasLinearVelocity = false;

							}

							if ( gripPose.angularVelocity ) {

								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy( gripPose.angularVelocity );

							} else {

								grip.hasAngularVelocity = false;

							}

						}

					}

				}

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
					if ( inputPose === null && gripPose !== null ) {

						inputPose = gripPose;

					}

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

						if ( inputPose.linearVelocity ) {

							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy( inputPose.linearVelocity );

						} else {

							targetRay.hasLinearVelocity = false;

						}

						if ( inputPose.angularVelocity ) {

							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy( inputPose.angularVelocity );

						} else {

							targetRay.hasAngularVelocity = false;

						}

						this.dispatchEvent( _moveEvent );

					}

				}


			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

	}

	class DepthTexture extends Texture {

		constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

			}

			if ( type === undefined && format === DepthFormat ) type = UnsignedIntType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isDepthTexture = true;

			this.image = { width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps = false;

		}


	}

	class WebXRManager extends EventDispatcher {

		constructor( renderer, gl ) {

			super();

			const scope = this;

			let session = null;
			let framebufferScaleFactor = 1.0;

			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			let customReferenceSpace = null;

			let pose = null;
			let glBinding = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			let xrFrame = null;
			const attributes = gl.getContextAttributes();
			let initialRenderTarget = null;
			let newRenderTarget = null;

			const controllers = [];
			const controllerInputSources = [];

			//

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable( 1 );
			cameraL.viewport = new Vector4();

			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable( 2 );
			cameraR.viewport = new Vector4();

			const cameras = [ cameraL, cameraR ];

			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable( 1 );
			cameraVR.layers.enable( 2 );

			let _currentDepthNear = null;
			let _currentDepthFar = null;

			//

			this.cameraAutoUpdate = true;
			this.enabled = false;

			this.isPresenting = false;

			this.getController = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getTargetRaySpace();

			};

			this.getControllerGrip = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getGripSpace();

			};

			this.getHand = function ( index ) {

				let controller = controllers[ index ];

				if ( controller === undefined ) {

					controller = new WebXRController();
					controllers[ index ] = controller;

				}

				return controller.getHandSpace();

			};

			//

			function onSessionEvent( event ) {

				const controllerIndex = controllerInputSources.indexOf( event.inputSource );

				if ( controllerIndex === - 1 ) {

					return;

				}

				const controller = controllers[ controllerIndex ];

				if ( controller !== undefined ) {

					controller.dispatchEvent( { type: event.type, data: event.inputSource } );

				}

			}

			function onSessionEnd() {

				session.removeEventListener( 'select', onSessionEvent );
				session.removeEventListener( 'selectstart', onSessionEvent );
				session.removeEventListener( 'selectend', onSessionEvent );
				session.removeEventListener( 'squeeze', onSessionEvent );
				session.removeEventListener( 'squeezestart', onSessionEvent );
				session.removeEventListener( 'squeezeend', onSessionEvent );
				session.removeEventListener( 'end', onSessionEnd );
				session.removeEventListener( 'inputsourceschange', onInputSourcesChange );

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];

					if ( inputSource === null ) continue;

					controllerInputSources[ i ] = null;

					controllers[ i ].disconnect( inputSource );

				}

				_currentDepthNear = null;
				_currentDepthFar = null;

				// restore framebuffer/rendering state

				renderer.setRenderTarget( initialRenderTarget );

				glBaseLayer = null;
				glProjLayer = null;
				glBinding = null;
				session = null;
				newRenderTarget = null;

				//

				animation.stop();

				scope.isPresenting = false;

				scope.dispatchEvent( { type: 'sessionend' } );

			}

			this.setFramebufferScaleFactor = function ( value ) {

				framebufferScaleFactor = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

				}

			};

			this.setReferenceSpaceType = function ( value ) {

				referenceSpaceType = value;

				if ( scope.isPresenting === true ) {

					console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

				}

			};

			this.getReferenceSpace = function () {

				return customReferenceSpace || referenceSpace;

			};

			this.setReferenceSpace = function ( space ) {

				customReferenceSpace = space;

			};

			this.getBaseLayer = function () {

				return glProjLayer !== null ? glProjLayer : glBaseLayer;

			};

			this.getBinding = function () {

				return glBinding;

			};

			this.getFrame = function () {

				return xrFrame;

			};

			this.getSession = function () {

				return session;

			};

			this.setSession = async function ( value ) {

				session = value;

				if ( session !== null ) {

					initialRenderTarget = renderer.getRenderTarget();

					session.addEventListener( 'select', onSessionEvent );
					session.addEventListener( 'selectstart', onSessionEvent );
					session.addEventListener( 'selectend', onSessionEvent );
					session.addEventListener( 'squeeze', onSessionEvent );
					session.addEventListener( 'squeezestart', onSessionEvent );
					session.addEventListener( 'squeezeend', onSessionEvent );
					session.addEventListener( 'end', onSessionEnd );
					session.addEventListener( 'inputsourceschange', onInputSourcesChange );

					if ( attributes.xrCompatible !== true ) {

						await gl.makeXRCompatible();

					}

					if ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {

						const layerInit = {
							antialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};

						glBaseLayer = new XRWebGLLayer( session, gl, layerInit );

						session.updateRenderState( { baseLayer: glBaseLayer } );

						newRenderTarget = new WebGLRenderTarget(
							glBaseLayer.framebufferWidth,
							glBaseLayer.framebufferHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								encoding: renderer.outputEncoding
							}
						);

					} else {

						let depthFormat = null;
						let depthType = null;
						let glDepthFormat = null;

						if ( attributes.depth ) {

							glDepthFormat = attributes.stencil ? 35056 : 33190;
							depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
							depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;

						}

						const projectionlayerInit = {
							colorFormat: 32856,
							depthFormat: glDepthFormat,
							scaleFactor: framebufferScaleFactor
						};

						glBinding = new XRWebGLBinding( session, gl );

						glProjLayer = glBinding.createProjectionLayer( projectionlayerInit );

						session.updateRenderState( { layers: [ glProjLayer ] } );

						newRenderTarget = new WebGLRenderTarget(
							glProjLayer.textureWidth,
							glProjLayer.textureHeight,
							{
								format: RGBAFormat,
								type: UnsignedByteType,
								depthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),
								stencilBuffer: attributes.stencil,
								encoding: renderer.outputEncoding,
								samples: attributes.antialias ? 4 : 0
							} );

						const renderTargetProperties = renderer.properties.get( newRenderTarget );
						renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;

					}

					newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278

					// Set foveation to maximum.
					this.setFoveation( 1.0 );

					customReferenceSpace = null;
					referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

					animation.setContext( session );
					animation.start();

					scope.isPresenting = true;

					scope.dispatchEvent( { type: 'sessionstart' } );

				}

			};

			function onInputSourcesChange( event ) {

				// Notify disconnected

				for ( let i = 0; i < event.removed.length; i ++ ) {

					const inputSource = event.removed[ i ];
					const index = controllerInputSources.indexOf( inputSource );

					if ( index >= 0 ) {

						controllerInputSources[ index ] = null;
						controllers[ index ].dispatchEvent( { type: 'disconnected', data: inputSource } );

					}

				}

				// Notify connected

				for ( let i = 0; i < event.added.length; i ++ ) {

					const inputSource = event.added[ i ];

					let controllerIndex = controllerInputSources.indexOf( inputSource );

					if ( controllerIndex === - 1 ) {

						// Assign input source a controller that currently has no input source

						for ( let i = 0; i < controllers.length; i ++ ) {

							if ( i >= controllerInputSources.length ) {

								controllerInputSources.push( inputSource );
								controllerIndex = i;
								break;

							} else if ( controllerInputSources[ i ] === null ) {

								controllerInputSources[ i ] = inputSource;
								controllerIndex = i;
								break;

							}

						}

						// If all controllers do currently receive input we ignore new ones

						if ( controllerIndex === - 1 ) break;

					}

					const controller = controllers[ controllerIndex ];

					if ( controller ) {

						controller.dispatchEvent( { type: 'connected', data: inputSource } );

					}

				}

			}

			//

			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();

			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */
			function setProjectionFromUnion( camera, cameraL, cameraR ) {

				cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
				cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

				const ipd = cameraLPos.distanceTo( cameraRPos );

				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements;

				// VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.
				const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
				const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
				const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
				const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

				const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
				const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
				const left = near * leftFov;
				const right = near * rightFov;

				// Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.
				const zOffset = ipd / ( - leftFov + rightFov );
				const xOffset = zOffset * - leftFov;

				// TODO: Better way to apply this offset?
				cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
				camera.translateX( xOffset );
				camera.translateZ( zOffset );
				camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

				// Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.
				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + ( ipd - xOffset );
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;

				camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

			}

			function updateCamera( camera, parent ) {

				if ( parent === null ) {

					camera.matrixWorld.copy( camera.matrix );

				} else {

					camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

				}

				camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			}

			this.updateCamera = function ( camera ) {

				if ( session === null ) return;

				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

					// Note that the new renderState won't apply until the next frame. See #18320

					session.updateRenderState( {
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					} );

					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;

				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;

				updateCamera( cameraVR, parent );

				for ( let i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				cameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );

				// update user camera and its children

				camera.position.copy( cameraVR.position );
				camera.quaternion.copy( cameraVR.quaternion );
				camera.scale.copy( cameraVR.scale );
				camera.matrix.copy( cameraVR.matrix );
				camera.matrixWorld.copy( cameraVR.matrixWorld );

				const children = camera.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				// update projection matrix for proper view frustum culling

				if ( cameras.length === 2 ) {

					setProjectionFromUnion( cameraVR, cameraL, cameraR );

				} else {

					// assume single camera setup (AR)

					cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

				}

			};

			this.getCamera = function () {

				return cameraVR;

			};

			this.getFoveation = function () {

				if ( glProjLayer !== null ) {

					return glProjLayer.fixedFoveation;

				}

				if ( glBaseLayer !== null ) {

					return glBaseLayer.fixedFoveation;

				}

				return undefined;

			};

			this.setFoveation = function ( foveation ) {

				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution

				if ( glProjLayer !== null ) {

					glProjLayer.fixedFoveation = foveation;

				}

				if ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {

					glBaseLayer.fixedFoveation = foveation;

				}

			};

			// Animation Loop

			let onAnimationFrameCallback = null;

			function onAnimationFrame( time, frame ) {

				pose = frame.getViewerPose( customReferenceSpace || referenceSpace );
				xrFrame = frame;

				if ( pose !== null ) {

					const views = pose.views;

					if ( glBaseLayer !== null ) {

						renderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );
						renderer.setRenderTarget( newRenderTarget );

					}

					let cameraVRNeedsUpdate = false;

					// check if it's necessary to rebuild cameraVR's camera list

					if ( views.length !== cameraVR.cameras.length ) {

						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;

					}

					for ( let i = 0; i < views.length; i ++ ) {

						const view = views[ i ];

						let viewport = null;

						if ( glBaseLayer !== null ) {

							viewport = glBaseLayer.getViewport( view );

						} else {

							const glSubImage = glBinding.getViewSubImage( glProjLayer, view );
							viewport = glSubImage.viewport;

							// For side-by-side projection, we only produce a single texture for both eyes.
							if ( i === 0 ) {

								renderer.setRenderTargetTextures(
									newRenderTarget,
									glSubImage.colorTexture,
									glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );

								renderer.setRenderTarget( newRenderTarget );

							}

						}

						let camera = cameras[ i ];

						if ( camera === undefined ) {

							camera = new PerspectiveCamera();
							camera.layers.enable( i );
							camera.viewport = new Vector4();
							cameras[ i ] = camera;

						}

						camera.matrix.fromArray( view.transform.matrix );
						camera.projectionMatrix.fromArray( view.projectionMatrix );
						camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

						if ( i === 0 ) {

							cameraVR.matrix.copy( camera.matrix );

						}

						if ( cameraVRNeedsUpdate === true ) {

							cameraVR.cameras.push( camera );

						}

					}

				}

				//

				for ( let i = 0; i < controllers.length; i ++ ) {

					const inputSource = controllerInputSources[ i ];
					const controller = controllers[ i ];

					if ( inputSource !== null && controller !== undefined ) {

						controller.update( inputSource, frame, customReferenceSpace || referenceSpace );

					}

				}

				if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

				xrFrame = null;

			}

			const animation = new WebGLAnimation();

			animation.setAnimationLoop( onAnimationFrame );

			this.setAnimationLoop = function ( callback ) {

				onAnimationFrameCallback = callback;

			};

			this.dispose = function () {};

		}

	}

	function WebGLMaterials( renderer, properties ) {

		function refreshFogUniforms( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsStandard( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material, transmissionRenderTarget );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.ior.value = material.ior;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;

				// artist-friendly light intensity scaling factor
				const scaleFactor = ( renderer.physicallyCorrectLights !== true ) ? Math.PI : 1;

				uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. iridescence map
			// 14. iridescence thickness map
			// 15. specular intensity map
			// 16. specular tint map
			// 17. transmission map
			// 18. thickness map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			} else if ( material.clearcoatMap ) {

				uvScaleMap = material.clearcoatMap;

			} else if ( material.clearcoatNormalMap ) {

				uvScaleMap = material.clearcoatNormalMap;

			} else if ( material.clearcoatRoughnessMap ) {

				uvScaleMap = material.clearcoatRoughnessMap;

			} else if ( material.iridescenceMap ) {

				uvScaleMap = material.iridescenceMap;

			} else if ( material.iridescenceThicknessMap ) {

				uvScaleMap = material.iridescenceThicknessMap;

			} else if ( material.specularIntensityMap ) {

				uvScaleMap = material.specularIntensityMap;

			} else if ( material.specularColorMap ) {

				uvScaleMap = material.specularColorMap;

			} else if ( material.transmissionMap ) {

				uvScaleMap = material.transmissionMap;

			} else if ( material.thicknessMap ) {

				uvScaleMap = material.thicknessMap;

			} else if ( material.sheenColorMap ) {

				uvScaleMap = material.sheenColorMap;

			} else if ( material.sheenRoughnessMap ) {

				uvScaleMap = material.sheenRoughnessMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.alphaTest > 0 ) {

				uniforms.alphaTest.value = material.alphaTest;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {

			uniforms.ior.value = material.ior; // also part of uniforms common

			if ( material.sheen > 0 ) {

				uniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );

				uniforms.sheenRoughness.value = material.sheenRoughness;

				if ( material.sheenColorMap ) {

					uniforms.sheenColorMap.value = material.sheenColorMap;

				}

				if ( material.sheenRoughnessMap ) {

					uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;

				}

			}

			if ( material.clearcoat > 0 ) {

				uniforms.clearcoat.value = material.clearcoat;
				uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

				if ( material.clearcoatMap ) {

					uniforms.clearcoatMap.value = material.clearcoatMap;

				}

				if ( material.clearcoatRoughnessMap ) {

					uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

				}

				if ( material.clearcoatNormalMap ) {

					uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
					uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

					if ( material.side === BackSide ) {

						uniforms.clearcoatNormalScale.value.negate();

					}

				}

			}

			if ( material.iridescence > 0 ) {

				uniforms.iridescence.value = material.iridescence;
				uniforms.iridescenceIOR.value = material.iridescenceIOR;
				uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];
				uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];

				if ( material.iridescenceMap ) {

					uniforms.iridescenceMap.value = material.iridescenceMap;

				}

				if ( material.iridescenceThicknessMap ) {

					uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;

				}

			}

			if ( material.transmission > 0 ) {

				uniforms.transmission.value = material.transmission;
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );

				if ( material.transmissionMap ) {

					uniforms.transmissionMap.value = material.transmissionMap;

				}

				uniforms.thickness.value = material.thickness;

				if ( material.thicknessMap ) {

					uniforms.thicknessMap.value = material.thicknessMap;

				}

				uniforms.attenuationDistance.value = material.attenuationDistance;
				uniforms.attenuationColor.value.copy( material.attenuationColor );

			}

			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularColor.value.copy( material.specularColor );

			if ( material.specularIntensityMap ) {

				uniforms.specularIntensityMap.value = material.specularIntensityMap;

			}

			if ( material.specularColorMap ) {

				uniforms.specularColorMap.value = material.specularColorMap;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function WebGLUniformsGroups( gl, info, capabilities, state ) {

		let buffers = {};
		let updateList = {};
		let allocatedBindingPoints = [];

		const maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( 35375 ) : 0; // binding points are global whereas block indices are per shader program

		function bind( uniformsGroup, program ) {

			const webglProgram = program.program;
			state.uniformBlockBinding( uniformsGroup, webglProgram );

		}

		function update( uniformsGroup, program ) {

			let buffer = buffers[ uniformsGroup.id ];

			if ( buffer === undefined ) {

				prepareUniformsGroup( uniformsGroup );

				buffer = createBuffer( uniformsGroup );
				buffers[ uniformsGroup.id ] = buffer;

				uniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );

			}

			// ensure to update the binding points/block indices mapping for this program

			const webglProgram = program.program;
			state.updateUBOMapping( uniformsGroup, webglProgram );

			// update UBO once per frame

			const frame = info.render.frame;

			if ( updateList[ uniformsGroup.id ] !== frame ) {

				updateBufferData( uniformsGroup );

				updateList[ uniformsGroup.id ] = frame;

			}

		}

		function createBuffer( uniformsGroup ) {

			// the setup of an UBO is independent of a particular shader program but global

			const bindingPointIndex = allocateBindingPointIndex();
			uniformsGroup.__bindingPointIndex = bindingPointIndex;

			const buffer = gl.createBuffer();
			const size = uniformsGroup.__size;
			const usage = uniformsGroup.usage;

			gl.bindBuffer( 35345, buffer );
			gl.bufferData( 35345, size, usage );
			gl.bindBuffer( 35345, null );
			gl.bindBufferBase( 35345, bindingPointIndex, buffer );

			return buffer;

		}

		function allocateBindingPointIndex() {

			for ( let i = 0; i < maxBindingPoints; i ++ ) {

				if ( allocatedBindingPoints.indexOf( i ) === - 1 ) {

					allocatedBindingPoints.push( i );
					return i;

				}

			}

			console.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );

			return 0;

		}

		function updateBufferData( uniformsGroup ) {

			const buffer = buffers[ uniformsGroup.id ];
			const uniforms = uniformsGroup.uniforms;
			const cache = uniformsGroup.__cache;

			gl.bindBuffer( 35345, buffer );

			for ( let i = 0, il = uniforms.length; i < il; i ++ ) {

				const uniform = uniforms[ i ];

				// partly update the buffer if necessary

				if ( hasUniformChanged( uniform, i, cache ) === true ) {

					const value = uniform.value;
					const offset = uniform.__offset;

					if ( typeof value === 'number' ) {

						uniform.__data[ 0 ] = value;
						gl.bufferSubData( 35345, offset, uniform.__data );

					} else {

						if ( uniform.value.isMatrix3 ) {

							// manually converting 3x3 to 3x4

							uniform.__data[ 0 ] = uniform.value.elements[ 0 ];
							uniform.__data[ 1 ] = uniform.value.elements[ 1 ];
							uniform.__data[ 2 ] = uniform.value.elements[ 2 ];
							uniform.__data[ 3 ] = uniform.value.elements[ 0 ];
							uniform.__data[ 4 ] = uniform.value.elements[ 3 ];
							uniform.__data[ 5 ] = uniform.value.elements[ 4 ];
							uniform.__data[ 6 ] = uniform.value.elements[ 5 ];
							uniform.__data[ 7 ] = uniform.value.elements[ 0 ];
							uniform.__data[ 8 ] = uniform.value.elements[ 6 ];
							uniform.__data[ 9 ] = uniform.value.elements[ 7 ];
							uniform.__data[ 10 ] = uniform.value.elements[ 8 ];
							uniform.__data[ 11 ] = uniform.value.elements[ 0 ];

						} else {

							value.toArray( uniform.__data );

						}

						gl.bufferSubData( 35345, offset, uniform.__data );

					}

				}

			}

			gl.bindBuffer( 35345, null );

		}

		function hasUniformChanged( uniform, index, cache ) {

			const value = uniform.value;

			if ( cache[ index ] === undefined ) {

				// cache entry does not exist so far

				if ( typeof value === 'number' ) {

					cache[ index ] = value;

				} else {

					cache[ index ] = value.clone();

				}

				return true;

			} else {

				// compare current value with cached entry

				if ( typeof value === 'number' ) {

					if ( cache[ index ] !== value ) {

						cache[ index ] = value;
						return true;

					}

				} else {

					const cachedObject = cache[ index ];

					if ( cachedObject.equals( value ) === false ) {

						cachedObject.copy( value );
						return true;

					}

				}

			}

			return false;

		}

		function prepareUniformsGroup( uniformsGroup ) {

			// determine total buffer size according to the STD140 layout
			// Hint: STD140 is the only supported layout in WebGL 2

			const uniforms = uniformsGroup.uniforms;

			let offset = 0; // global buffer offset in bytes
			const chunkSize = 16; // size of a chunk in bytes
			let chunkOffset = 0; // offset within a single chunk in bytes

			for ( let i = 0, l = uniforms.length; i < l; i ++ ) {

				const uniform = uniforms[ i ];
				const info = getUniformSize( uniform );

				// the following two properties will be used for partial buffer updates

				uniform.__data = new Float32Array( info.storage / Float32Array.BYTES_PER_ELEMENT );
				uniform.__offset = offset;

				//

				if ( i > 0 ) {

					chunkOffset = offset % chunkSize;

					const remainingSizeInChunk = chunkSize - chunkOffset;

					// check for chunk overflow

					if ( chunkOffset !== 0 && ( remainingSizeInChunk - info.boundary ) < 0 ) {

						// add padding and adjust offset

						offset += ( chunkSize - chunkOffset );
						uniform.__offset = offset;

					}

				}

				offset += info.storage;

			}

			// ensure correct final padding

			chunkOffset = offset % chunkSize;

			if ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );

			//

			uniformsGroup.__size = offset;
			uniformsGroup.__cache = {};

			return this;

		}

		function getUniformSize( uniform ) {

			const value = uniform.value;

			const info = {
				boundary: 0, // bytes
				storage: 0 // bytes
			};

			// determine sizes according to STD140

			if ( typeof value === 'number' ) {

				// float/int

				info.boundary = 4;
				info.storage = 4;

			} else if ( value.isVector2 ) {

				// vec2

				info.boundary = 8;
				info.storage = 8;

			} else if ( value.isVector3 || value.isColor ) {

				// vec3

				info.boundary = 16;
				info.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes

			} else if ( value.isVector4 ) {

				// vec4

				info.boundary = 16;
				info.storage = 16;

			} else if ( value.isMatrix3 ) {

				// mat3 (in STD140 a 3x3 matrix is represented as 3x4)

				info.boundary = 48;
				info.storage = 48;

			} else if ( value.isMatrix4 ) {

				// mat4

				info.boundary = 64;
				info.storage = 64;

			} else if ( value.isTexture ) {

				console.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );

			} else {

				console.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );

			}

			return info;

		}

		function onUniformsGroupsDispose( event ) {

			const uniformsGroup = event.target;

			uniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );

			const index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );
			allocatedBindingPoints.splice( index, 1 );

			gl.deleteBuffer( buffers[ uniformsGroup.id ] );

			delete buffers[ uniformsGroup.id ];
			delete updateList[ uniformsGroup.id ];

		}

		function dispose() {

			for ( const id in buffers ) {

				gl.deleteBuffer( buffers[ id ] );

			}

			allocatedBindingPoints = [];
			buffers = {};
			updateList = {};

		}

		return {

			bind: bind,
			update: update,

			dispose: dispose

		};

	}

	function createCanvasElement() {

		const canvas = createElementNS( 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	function WebGLRenderer( parameters = {} ) {

		this.isWebGLRenderer = true;

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let _alpha;

		if ( _context !== null ) {

			_alpha = _context.getContextAttributes().alpha;

		} else {

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false;

		}

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		//

		Object.defineProperties( this, {

			// @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d

			gammaFactor: {
				get: function () {

					console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );
					return 2;

				},
				set: function () {

					console.warn( 'THREE.WebGLRenderer: .gammaFactor has been removed.' );

				}
			}

		} );

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		//

		let _width = _canvas.width;
		let _height = _canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// transmission

		let _transmissionRenderTarget = null;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector2 = new Vector2();
		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = _context;

		function getContext( contextNames, contextAttributes ) {

			for ( let i = 0; i < contextNames.length; i ++ ) {

				const contextName = contextNames[ i ];
				const context = _canvas.getContext( contextName, contextAttributes );
				if ( context !== null ) return context;

			}

			return null;

		}

		try {

			const contextAttributes = {
				alpha: true,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};

			// OffscreenCanvas does not have setAttribute, see #22811
			if ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );

			// event listeners must be registered before WebGL context is created, see #12753
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
			_canvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			if ( _gl === null ) {

				const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

				if ( _this.isWebGL1Renderer === true ) {

					contextNames.shift();

				}

				_gl = getContext( contextNames, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextNames ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates, uniformsGroups;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			extensions.init( capabilities );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );

			info = new WebGLInfo();
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			cubeuvmaps = new WebGLCubeUVMaps( _this );
			attributes = new WebGLAttributes( _gl, capabilities );
			bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl, capabilities, textures );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( _this, properties );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates( extensions, capabilities );
			background = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );
			shadowMap = new WebGLShadowMap( _this, objects, capabilities );
			uniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color = true, depth = true, stencil = true ) {

			let bits = 0;

			if ( color ) bits |= 16384;
			if ( depth ) bits |= 256;
			if ( stencil ) bits |= 1024;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
			_canvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			uniformsGroups.dispose();
			programCache.dispose();

			xr.dispose();

			xr.removeEventListener( 'sessionstart', onXRSessionStart );
			xr.removeEventListener( 'sessionend', onXRSessionEnd );

			if ( _transmissionRenderTarget ) {

				_transmissionRenderTarget.dispose();
				_transmissionRenderTarget = null;

			}

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;

			initGLContext();

			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;

		}

		function onContextCreationError( event ) {

			console.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReferences( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReferences( material ) {

			const programs = properties.get( material ).programs;

			if ( programs !== undefined ) {

				programs.forEach( function ( program ) {

					programCache.releaseProgram( program );

				} );

				if ( material.isShaderMaterial ) {

					programCache.releaseShaderCache( material );

				}

			}

		}

		// Buffer rendering

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, geometry, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			const position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) return;

			} else if ( index.count === 0 ) {

				return;

			}

			//

			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			const dataCount = ( index !== null ) ? index.count : position.count;

			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;

			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;

			const drawStart = Math.max( rangeStart, groupStart );
			const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					renderer.setMode( 4 );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( 1 );

				} else if ( object.isLineLoop ) {

					renderer.setMode( 2 );

				} else {

					renderer.setMode( 3 );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( 0 );

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			scene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( _this.physicallyCorrectLights );

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							getProgram( material2, scene, object );

						}

					} else {

						getProgram( material, scene, object );

					}

				}

			} );

			renderStateStack.pop();
			currentRenderState = null;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		function onXRSessionStart() {

			animation.stop();

		}

		function onXRSessionEnd() {

			animation.start();

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof self !== 'undefined' ) animation.setContext( self );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		xr.addEventListener( 'sessionstart', onXRSessionStart );
		xr.addEventListener( 'sessionend', onXRSessionEnd );

		// Rendering

		this.render = function ( scene, camera ) {

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				if ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );

				camera = xr.getCamera(); // use XR camera for rendering

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			//

			background.render( currentRenderList, scene );

			// render scene

			currentRenderState.setupLights( _this.physicallyCorrectLights );

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let i = 0, l = cameras.length; i < l; i ++ ) {

					const camera2 = cameras[ i ];

					renderScene( currentRenderList, scene, camera2, camera2.viewport );

				}

			} else {

				renderScene( currentRenderList, scene, camera );

			}

			//

			if ( _currentRenderTarget !== null ) {

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

			}

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			// _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						// update skeleton only once in a frame

						if ( object.skeleton.frame !== info.render.frame ) {

							object.skeleton.update();
							object.skeleton.frame = info.render.frame;

						}

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderScene( currentRenderList, scene, camera, viewport ) {

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;

			currentRenderState.setupLightsView( camera );

			if ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );

			if ( viewport ) state.viewport( _currentViewport.copy( viewport ) );

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

		}

		function renderTransmissionPass( opaqueObjects, scene, camera ) {

			const isWebGL2 = capabilities.isWebGL2;

			if ( _transmissionRenderTarget === null ) {

				_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {
					generateMipmaps: true,
					type: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					samples: ( isWebGL2 && _antialias === true ) ? 4 : 0
				} );

			}

			_this.getDrawingBufferSize( _vector2 );

			if ( isWebGL2 ) {

				_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );

			} else {

				_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );

			}

			//

			const currentRenderTarget = _this.getRenderTarget();
			_this.setRenderTarget( _transmissionRenderTarget );
			_this.clear();

			// Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;

			renderObjects( opaqueObjects, scene, camera );

			_this.toneMapping = currentToneMapping;

			textures.updateMultisampleRenderTarget( _transmissionRenderTarget );
			textures.updateRenderTargetMipmap( _transmissionRenderTarget );

			_this.setRenderTarget( currentRenderTarget );

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( object.layers.test( camera.layers ) ) {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			material.onBeforeRender( _this, scene, camera, geometry, object, group );

			if ( material.transparent === true && material.side === DoubleSide ) {

				material.side = BackSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = FrontSide;
				material.needsUpdate = true;
				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

				material.side = DoubleSide;

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function getProgram( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let programs = materialProperties.programs;

			// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );

			if ( programs === undefined ) {

				// new material

				material.addEventListener( 'dispose', onMaterialDispose );

				programs = new Map();
				materialProperties.programs = programs;

			}

			let program = programs.get( programCacheKey );

			if ( program !== undefined ) {

				// early out if program and light state is identical

				if ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {

					updateCommonMaterialProperties( material, parameters );

					return program;

				}

			} else {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBuild( object, parameters, _this );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );
				programs.set( programCacheKey, program );

				materialProperties.uniforms = parameters.uniforms;

			}

			const uniforms = materialProperties.uniforms;

			if ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {

				uniforms.clippingPlanes = clipping.uniform;

			}

			updateCommonMaterialProperties( material, parameters );

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;

			return program;

		}

		function updateCommonMaterialProperties( material, parameters ) {

			const materialProperties = properties.get( material );

			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.morphColors = parameters.morphColors;
			materialProperties.morphTargetsCount = parameters.morphTargetsCount;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
			materialProperties.toneMapping = parameters.toneMapping;

		}

		function setProgram( camera, scene, geometry, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );
			const envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );
			const vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;
			const vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;
			const morphTargets = !! geometry.morphAttributes.position;
			const morphNormals = !! geometry.morphAttributes.normal;
			const morphColors = !! geometry.morphAttributes.color;
			const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;

			const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
			const morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			//

			let needsProgramChange = false;

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.outputEncoding !== encoding ) {

					needsProgramChange = true;

				} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {

					needsProgramChange = true;

				} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {

					needsProgramChange = true;

				} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {

					needsProgramChange = true;

				} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {

					needsProgramChange = true;

				} else if ( materialProperties.envMap !== envMap ) {

					needsProgramChange = true;

				} else if ( material.fog === true && materialProperties.fog !== fog ) {

					needsProgramChange = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {

					needsProgramChange = true;

				} else if ( materialProperties.vertexTangents !== vertexTangents ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphTargets !== morphTargets ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphNormals !== morphNormals ) {

					needsProgramChange = true;

				} else if ( materialProperties.morphColors !== morphColors ) {

					needsProgramChange = true;

				} else if ( materialProperties.toneMapping !== toneMapping ) {

					needsProgramChange = true;

				} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {

					needsProgramChange = true;

				}

			} else {

				needsProgramChange = true;
				materialProperties.__version = material.version;

			}

			//

			let program = materialProperties.currentProgram;

			if ( needsProgramChange === true ) {

				program = getProgram( material, scene, object );

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					object.isSkinnedMesh ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning and morph target uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone and morph texture must go before other textures
			// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

			if ( object.isSkinnedMesh ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						console.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );

					}

				}

			}

			const morphAttributes = geometry.morphAttributes;

			if ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {

				morphtargets.update( object, geometry, material, program );

			}


			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog === true ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			// UBOs

			if ( material.isShaderMaterial || material.isRawShaderMaterial ) {

				const groups = material.uniformsGroups;

				for ( let i = 0, l = groups.length; i < l; i ++ ) {

					if ( capabilities.isWebGL2 ) {

						const group = groups[ i ];

						uniformsGroups.update( group, program );
						uniformsGroups.bind( group, program );

					} else {

						console.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );

					}

				}

			}

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {

			properties.get( renderTarget.texture ).__webglTexture = colorTexture;
			properties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__hasExternalTextures = true;

			if ( renderTargetProperties.__hasExternalTextures ) {

				renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;

				if ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {

					// The multisample_render_to_texture extension doesn't work properly if there
					// are midframe flushes and an external depth buffer. Disable use of the extension.
					if ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {

						console.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );
						renderTargetProperties.__useRenderToTexture = false;

					}

				}

			}

		};

		this.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {

			const renderTargetProperties = properties.get( renderTarget );
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
			renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			let useDefaultFramebuffer = true;

			if ( renderTarget ) {

				const renderTargetProperties = properties.get( renderTarget );

				if ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {

					// We need to make sure to rebind the framebuffer.
					state.bindFramebuffer( 36160, null );
					useDefaultFramebuffer = false;

				} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				} else if ( renderTargetProperties.__hasExternalTextures ) {

					// Color and depth texture must be rebound in order for the swapchain to update.
					textures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );

				}

			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const texture = renderTarget.texture;

				if ( texture.isData3DTexture || texture.isDataArrayTexture ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					framebuffer = __webglFramebuffer[ activeCubeFace ];
					isCube = true;

				} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			const framebufferBound = state.bindFramebuffer( 36160, framebuffer );

			if ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {

				state.drawBuffers( renderTarget, framebuffer );

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const textureProperties = properties.get( renderTarget.texture );
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

			}

			_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				state.bindFramebuffer( 36160, framebuffer );

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! halfFloatSupportedByExt ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} finally {

					// restore framebuffer of current render target if necessary

					const framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;
					state.bindFramebuffer( 36160, framebuffer );

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexSubImage2D( 3553, level, 0, 0, position.x, position.y, width, height );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

			if ( _this.isWebGL1Renderer ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
				return;

			}

			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isData3DTexture ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = 32879;

			} else if ( dstTexture.isDataArrayTexture ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = 35866;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

			const unpackRowLen = _gl.getParameter( 3314 );
			const unpackImageHeight = _gl.getParameter( 32878 );
			const unpackSkipPixels = _gl.getParameter( 3316 );
			const unpackSkipRows = _gl.getParameter( 3315 );
			const unpackSkipImages = _gl.getParameter( 32877 );

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;

			_gl.pixelStorei( 3314, image.width );
			_gl.pixelStorei( 32878, image.height );
			_gl.pixelStorei( 3316, sourceBox.min.x );
			_gl.pixelStorei( 3315, sourceBox.min.y );
			_gl.pixelStorei( 32877, sourceBox.min.z );

			if ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {

				_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );
					_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );

				} else {

					_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );

				}

			}

			_gl.pixelStorei( 3314, unpackRowLen );
			_gl.pixelStorei( 32878, unpackImageHeight );
			_gl.pixelStorei( 3316, unpackSkipPixels );
			_gl.pixelStorei( 3315, unpackSkipRows );
			_gl.pixelStorei( 32877, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			if ( texture.isCubeTexture ) {

				textures.setTextureCube( texture, 0 );

			} else if ( texture.isData3DTexture ) {

				textures.setTexture3D( texture, 0 );

			} else if ( texture.isDataArrayTexture ) {

				textures.setTexture2DArray( texture, 0 );

			} else {

				textures.setTexture2D( texture, 0 );

			}

			state.unbindTexture();

		};

		this.resetState = function () {

			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

		}

	}

	class FogExp2 {

		constructor( color, density = 0.00025 ) {

			this.isFogExp2 = true;

			this.name = '';

			this.color = new Color( color );
			this.density = density;

		}

		clone() {

			return new FogExp2( this.color, this.density );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	}

	class Scene extends Object3D {

		constructor() {

			super();

			this.isScene = true;

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	}

	class LineBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isLineBasicMaterial = true;

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			this.fog = source.fog;

			return this;

		}

	}

	class PointsMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isPointsMaterial = true;

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.fog = source.fog;

			return this;

		}

	}

	const _inverseMatrix = /*@__PURE__*/ new Matrix4();
	const _ray = /*@__PURE__*/ new Ray();
	const _sphere$1 = /*@__PURE__*/ new Sphere();
	const _position$1 = /*@__PURE__*/ new Vector3();

	class Points extends Object3D {

		constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

			super();

			this.isPoints = true;

			this.type = 'Points';

			this.geometry = geometry;
			this.material = material;

			this.updateMorphTargets();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		}

		raycast( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );
			_sphere$1.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i ++ ) {

					const a = index.getX( i );

					_position$1.fromBufferAttribute( positionAttribute, a );

					testPoint$1( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, l = end; i < l; i ++ ) {

					_position$1.fromBufferAttribute( positionAttribute, i );

					testPoint$1( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		}

		updateMorphTargets() {

			const geometry = this.geometry;

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		}

	}

	function testPoint$1( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		const rayPointDistanceSq = _ray.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			const intersectPoint = new Vector3();

			_ray.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	class DataTexture extends Texture {

		constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.isDataTexture = true;

			this.image = { data: data, width: width, height: height };

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

	}

	class CanvasTexture extends Texture {

		constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.isCanvasTexture = true;

			this.needsUpdate = true;

		}

	}

	class SphereGeometry extends BufferGeometry {

		constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy == 0 && thetaStart == 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		static fromJSON( data ) {

			return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

		}

	}

	class RingGeometry extends BufferGeometry {

		constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			thetaSegments = Math.max( 3, thetaSegments );
			phiSegments = Math.max( 1, phiSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// some helper variables

			let radius = innerRadius;
			const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			const vertex = new Vector3();
			const uv = new Vector2();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= phiSegments; j ++ ) {

				for ( let i = 0; i <= thetaSegments; i ++ ) {

					// values are generate from the inside of the ring to the outside

					const segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex

					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, 0, 1 );

					// uv

					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;

					uvs.push( uv.x, uv.y );

				}

				// increase the radius for next row of vertices

				radius += radiusStep;

			}

			// indices

			for ( let j = 0; j < phiSegments; j ++ ) {

				const thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( let i = 0; i < thetaSegments; i ++ ) {

					const segment = i + thetaSegmentLevel;

					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		static fromJSON( data ) {

			return new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );

		}

	}

	class CylinderGeometry extends BufferGeometry {

		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

		static fromJSON( data ) {

			return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

		}

	}

	class MeshLambertMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshLambertMaterial = true;

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.fog = source.fog;

			return this;

		}

	}

	class MeshPhongMaterial extends Material {

		constructor( parameters ) {

			super();

			this.isMeshPhongMaterial = true;

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.flatShading = false;

			this.fog = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.flatShading = source.flatShading;

			this.fog = source.fog;

			return this;

		}

	}

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	class LoadingManager {

		constructor( onLoad, onProgress, onError ) {

			const scope = this;

			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = [];

			// Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

			this.resolveURL = function ( url ) {

				if ( urlModifier ) {

					return urlModifier( url );

				}

				return url;

			};

			this.setURLModifier = function ( transform ) {

				urlModifier = transform;

				return this;

			};

			this.addHandler = function ( regex, loader ) {

				handlers.push( regex, loader );

				return this;

			};

			this.removeHandler = function ( regex ) {

				const index = handlers.indexOf( regex );

				if ( index !== - 1 ) {

					handlers.splice( index, 2 );

				}

				return this;

			};

			this.getHandler = function ( file ) {

				for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

					const regex = handlers[ i ];
					const loader = handlers[ i + 1 ];

					if ( regex.global ) regex.lastIndex = 0; // see #17920

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			};

		}

	}

	const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

	class Loader {

		constructor( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};

		}

		load( /* url, onLoad, onProgress, onError */ ) {}

		loadAsync( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		}

		parse( /* data */ ) {}

		setCrossOrigin( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		}

		setWithCredentials( value ) {

			this.withCredentials = value;
			return this;

		}

		setPath( path ) {

			this.path = path;
			return this;

		}

		setResourcePath( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		}

		setRequestHeader( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	}

	class ImageLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = createElementNS( 'img' );

			function onImageLoad() {

				removeEventListeners();

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				removeEventListeners();

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			function removeEventListeners() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.slice( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	}

	class TextureLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	}

	const loading = {};

	class HttpError extends Error {

		constructor( message, response ) {

			super( message );
			this.response = response;

		}

	}

	class FileLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				this.manager.itemStart( url );

				setTimeout( () => {

					if ( onLoad ) onLoad( cached );

					this.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Initialise array for duplicate requests
			loading[ url ] = [];

			loading[ url ].push( {
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError,
			} );

			// create request
			const req = new Request( url, {
				headers: new Headers( this.requestHeader ),
				credentials: this.withCredentials ? 'include' : 'same-origin',
				// An abort controller could be added within a future PR
			} );

			// record states ( avoid data race )
			const mimeType = this.mimeType;
			const responseType = this.responseType;

			// start the fetch
			fetch( req )
				.then( response => {

					if ( response.status === 200 || response.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( response.status === 0 ) {

							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						}

						// Workaround: Checking if response.body === undefined for Alipay browser #23548

						if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

							return response;

						}

						const callbacks = loading[ url ];
						const reader = response.body.getReader();
						const contentLength = response.headers.get( 'Content-Length' );
						const total = contentLength ? parseInt( contentLength ) : 0;
						const lengthComputable = total !== 0;
						let loaded = 0;

						// periodically read data into the new stream tracking while download progress
						const stream = new ReadableStream( {
							start( controller ) {

								readData();

								function readData() {

									reader.read().then( ( { done, value } ) => {

										if ( done ) {

											controller.close();

										} else {

											loaded += value.byteLength;

											const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
											for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

												const callback = callbacks[ i ];
												if ( callback.onProgress ) callback.onProgress( event );

											}

											controller.enqueue( value );
											readData();

										}

									} );

								}

							}

						} );

						return new Response( stream );

					} else {

						throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

					}

				} )
				.then( response => {

					switch ( responseType ) {

						case 'arraybuffer':

							return response.arrayBuffer();

						case 'blob':

							return response.blob();

						case 'document':

							return response.text()
								.then( text => {

									const parser = new DOMParser();
									return parser.parseFromString( text, mimeType );

								} );

						case 'json':

							return response.json();

						default:

							if ( mimeType === undefined ) {

								return response.text();

							} else {

								// sniff encoding
								const re = /charset="?([^;"\s]*)"?/i;
								const exec = re.exec( mimeType );
								const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
								const decoder = new TextDecoder( label );
								return response.arrayBuffer().then( ab => decoder.decode( ab ) );

							}

					}

				} )
				.then( data => {

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, data );

					const callbacks = loading[ url ];
					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( data );

					}

				} )
				.catch( err => {

					// Abort errors and other errors are handled the same

					const callbacks = loading[ url ];

					if ( callbacks === undefined ) {

						// When onLoad was called and url was deleted in `loading`
						this.manager.itemError( url );
						throw err;

					}

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( err );

					}

					this.manager.itemError( url );

				} )
				.finally( () => {

					this.manager.itemEnd( url );

				} );

			this.manager.itemStart( url );

		}

		setResponseType( value ) {

			this.responseType = value;
			return this;

		}

		setMimeType( value ) {

			this.mimeType = value;
			return this;

		}

	}

	class Light extends Object3D {

		constructor( color, intensity = 1 ) {

			super();

			this.isLight = true;

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		dispose() {

			// Empty here in base class; some subclasses override.

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	}

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	class LightShadow {

		constructor( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.blurSamples = 8;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this.autoUpdate = true;
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		getViewportCount() {

			return this._viewportCount;

		}

		getFrustum() {

			return this._frustum;

		}

		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

		}

		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		getFrameExtents() {

			return this._frameExtents;

		}

		dispose() {

			if ( this.map ) {

				this.map.dispose();

			}

			if ( this.mapPass ) {

				this.mapPass.dispose();

			}

		}

		copy( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

			this.isDirectionalLightShadow = true;

		}

	}

	class DirectionalLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isDirectionalLight = true;

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		dispose() {

			this.shadow.dispose();

		}

		copy( source ) {

			super.copy( source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		}

	}

	class AmbientLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.isAmbientLight = true;

			this.type = 'AmbientLight';

		}

	}

	const _eyeRight = /*@__PURE__*/ new Matrix4();
	const _eyeLeft = /*@__PURE__*/ new Matrix4();
	const _projectionMatrix = /*@__PURE__*/ new Matrix4();

	class StereoCamera {

		constructor() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};

		}

		update( camera ) {

			const cache = this._cache;

			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if ( needsUpdate ) {

				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				_projectionMatrix.copy( camera.projectionMatrix );
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
				let xmin, xmax;

				// translate xOffset

				_eyeLeft.elements[ 12 ] = - eyeSepHalf;
				_eyeRight.elements[ 12 ] = eyeSepHalf;

				// for left eye

				xmin = - ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;

				_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( _projectionMatrix );

				// for right eye

				xmin = - ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;

				_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( _projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

		}

	}

	class InstancedBufferGeometry extends BufferGeometry {

		constructor() {

			super();

			this.isInstancedBufferGeometry = true;

			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;

		}

		copy( source ) {

			super.copy( source );

			this.instanceCount = source.instanceCount;

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const data = super.toJSON( this );

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	}

	class InstancedBufferAttribute extends BufferAttribute {

		constructor( array, itemSize, normalized, meshPerAttribute = 1 ) {

			if ( typeof normalized === 'number' ) {

				meshPerAttribute = normalized;

				normalized = false;

				console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

			}

			super( array, itemSize, normalized );

			this.isInstancedBufferAttribute = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	}

	class InterleavedBuffer {

		constructor( array, stride ) {

			this.isInterleavedBuffer = true;

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.usage = StaticDrawUsage;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

			this.uuid = generateUUID();

		}

		onUploadCallback() {}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

		setUsage( value ) {

			this.usage = value;

			return this;

		}

		copy( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		}

		copyAt( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		}

		set( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		}

		clone( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new this.constructor( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		}

		onUpload( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

		toJSON( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {

		constructor( array, stride, meshPerAttribute = 1 ) {

			super( array, stride );

			this.isInstancedInterleavedBuffer = true;

			this.meshPerAttribute = meshPerAttribute;

		}

		copy( source ) {

			super.copy( source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

		clone( data ) {

			const ib = super.clone( data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		}

		toJSON( data ) {

			const json = super.toJSON( data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	}

	const _vector$2 = /*@__PURE__*/ new Vector3();

	class InterleavedBufferAttribute {

		constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

			this.isInterleavedBufferAttribute = true;

			this.name = '';

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}

		get count() {

			return this.data.count;

		}

		get array() {

			return this.data.array;

		}

		set needsUpdate( value ) {

			this.data.needsUpdate = value;

		}

		applyMatrix4( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.applyMatrix4( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		applyNormalMatrix( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.applyNormalMatrix( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		transformDirection( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$2.fromBufferAttribute( this, i );

				_vector$2.transformDirection( m );

				this.setXYZ( i, _vector$2.x, _vector$2.y, _vector$2.z );

			}

			return this;

		}

		setX( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		}

		setY( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		}

		setZ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		}

		setW( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		}

		getX( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		}

		getY( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		}

		getZ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		}

		getW( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		}

		setXY( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		}

		setXYZ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		}

		setXYZW( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

		clone( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		}

		toJSON( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interleaved attribtue

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	}

	class Raycaster {

		constructor( origin, direction, near = 0, far = Infinity ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();

			this.params = {
				Mesh: {},
				Line: { threshold: 1 },
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

		}

		set( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		}

		setFromCamera( coords, camera ) {

			if ( camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		}

		intersectObject( object, recursive = true, intersects = [] ) {

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		}

		intersectObjects( objects, recursive = true, intersects = [] ) {

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {

		constructor( radius = 1, phi = 0, theta = 0 ) {

			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle

			return this;

		}

		set( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		}

		// restrict phi to be between EPS and PI-EPS
		makeSafe() {

			const EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$1 = /*@__PURE__*/ new Vector2();

	class Box2 {

		constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

			this.isBox2 = true;

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		}

		getCenter( target ) {

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		}

		intersectsBox( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		}

		clampPoint( point, target ) {

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	const _startP = /*@__PURE__*/ new Vector3();
	const _startEnd = /*@__PURE__*/ new Vector3();

	class Line3 {

		constructor( start = new Vector3(), end = new Vector3() ) {

			this.start = start;
			this.end = end;

		}

		set( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		}

		copy( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		}

		getCenter( target ) {

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		}

		delta( target ) {

			return target.subVectors( this.end, this.start );

		}

		distanceSq() {

			return this.start.distanceToSquared( this.end );

		}

		distance() {

			return this.start.distanceTo( this.end );

		}

		at( t, target ) {

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		closestPointToPointParameter( point, clampToLine ) {

			_startP.subVectors( point, this.start );
			_startEnd.subVectors( this.end, this.start );

			const startEnd2 = _startEnd.dot( _startEnd );
			const startEnd_startP = _startEnd.dot( _startP );

			let t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = clamp( t, 0, 1 );

			}

			return t;

		}

		closestPointToPoint( point, clampToLine, target ) {

			const t = this.closestPointToPointParameter( point, clampToLine );

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		applyMatrix4( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		}

		equals( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	Object3D.onUploadDropBuffer = function () {

		// call back from BufferAttribute to drop JS buffers after data has been transfered to GPU
		this.array = null;

	};

	Object3D.DefaultUp.set( 0, 0, 1 );

	Object3D.prototype.addStatic = function ( obj ) {

		obj.matrixAutoUpdate = false;
		obj.updateMatrix();

		this.add( obj );

	};

	Object3D.prototype.dropBuffers = function ( colors = true ) {

		const geometry = this.geometry;
		const attributes = geometry.attributes;

		for ( const name in attributes )
			if ( colors || name !== 'color' ) attributes[ name ].onUpload( Object3D.onUploadDropBuffer );

		if ( geometry.index ) geometry.index.onUpload( Object3D.onUploadDropBuffer );

	};

	var anaglyphVertexShader = "varying vec2 vUv;\nvoid main() {\n\tvUv = vec2( uv.x, uv.y );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var anaglyphFragmentShader = "uniform sampler2D mapLeft;\nuniform sampler2D mapRight;\nvarying vec2 vUv;\nuniform mat3 colorMatrixLeft;\nuniform mat3 colorMatrixRight;\nfloat lin( float c ) {\n\treturn c <= 0.04045 ? c * 0.0773993808 : pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n}\nvec4 lin( vec4 c ) {\n\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );\n}\nfloat dev( float c ) {\n\treturn c <= 0.0031308 ? c * 12.92 : pow( c, 0.41666 ) * 1.055 - 0.055;\n}\nvoid main() {\n\tvec2 uv = vUv;\n\tvec4 colorL = lin( texture2D( mapLeft, uv ) );\n\tvec4 colorR = lin( texture2D( mapRight, uv ) );\n\tvec3 color = clamp(\n\t\t\tcolorMatrixLeft * colorL.rgb +\n\t\t\tcolorMatrixRight * colorR.rgb, 0., 1.\n\t);\n\tgl_FragColor = vec4(\n\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),\n\t\t\tmax( colorL.a, colorR.a )\n\t);\n}";

	var cursorVertexShader = "#include <fog_pars_vertex>\n#include <wall_vertex_pars>\nvoid main() {\n\t#include <wall_vertex>\n\t#include <fog_vertex>\n}";

	var cursorFragmentShader = "#include <fog_pars_fragment>\n#include <wall_fragment_pars>\n#include <cursor_fragment_pars>\n#include <location_fade_fragment_pars>\nvoid main() {\n\t#include <cursor_fragment>\n\t#include <location_fade_fragment>\n\t#include <fog_fragment>\n}";

	var depthMapVertexShader = "uniform float minZ;\nuniform float scaleZ;\nvarying float vHeight;\nvoid main() {\n\tvHeight = ( position.z - minZ ) * scaleZ;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var depthMapFragmentShader = "#include <packRGBA>\nvarying float vHeight;\nvoid main() {\n\tgl_FragColor = packFloatToRGBA( vHeight );\n}";

	var depthVertexShader = "#include <fog_pars_vertex>\n#include <wall_vertex_pars>\n#include <depth_vertex_pars>\nvoid main() {\n\t#include <wall_vertex>\n\t#include <depth_vertex>\n\t#include <fog_vertex>\n}";

	var depthFragmentShader = "#include <fog_pars_fragment>\n#include <wall_fragment_pars>\n#include <depth_fragment_pars>\n#include <location_fade_fragment_pars>\nvoid main() {\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, vTerrainCoords ) );\n\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\tfloat depth = ( terrainHeight - vPosition.z ) * depthScale;\n\tgl_FragColor = texture2D( cmap, vec2( depth, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#include <location_fade_fragment>\n\t#include <fog_fragment>\n}";

	var depthCursorVertexShader = "#include <fog_pars_vertex>\n#include <wall_vertex_pars>\n#include <depth_vertex_pars>\nvarying float vCursor;\nvoid main() {\n\t#include <wall_vertex>\n\t#include <depth_vertex>\n\t#include <fog_vertex>\n}";

	var depthCursorFragmentShader = "#include <fog_pars_fragment>\n#include <wall_fragment_pars>\n#include <cursor_fragment_pars>\n#include <depth_fragment_pars>\n#include <location_fade_fragment_pars>\nvoid main() {\n\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, vTerrainCoords ) );\n\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\tfloat vCursor = terrainHeight - vPosition.z;\n\t#include <cursor_fragment>\n\t#include <location_fade_fragment>\n\t#include <fog_fragment>\n}";

	var glyphVertexShader = "#include <fog_pars_vertex>\nuniform float cellScale;\nuniform vec2 scale;\nuniform mat2 rotate;\nuniform vec2 viewPort;\nattribute float offsets;\nattribute vec2 instanceUvs;\nattribute float instanceOffsets;\nattribute float instanceWidths;\nvarying vec2 vUv;\nvoid main() {\n\tvUv = instanceUvs + vec2( position.x * cellScale * instanceWidths, position.y * cellScale );\n\tvec2 newPosition = vec2( position.x * instanceWidths, position.y );\n\tnewPosition.x += instanceOffsets;\n\tnewPosition.y += offsets;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition.xy *= offset.w;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n\tvec2 snap = viewPort / gl_Position.w;\n\tgl_Position.xy =  ( trunc( gl_Position.xy * snap ) + 0.5 ) / snap;\n\t#include <fog_vertex>\n}";

	var glyphFragmentShader = "#include <fog_pars_fragment>\nuniform sampler2D atlas;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( atlas, vUv );\n\t#include <fog_fragment>\n}";

	var heightVertexShader = "#include <fog_pars_vertex>\n#include <wall_vertex_pars>\nuniform float minZ;\nuniform float scaleZ;\nvarying float zMap;\nvoid main() {\n\t#include <wall_vertex>\n\tzMap = ( position.z - minZ ) * scaleZ;\n\t#include <fog_vertex>\n}";

	var heightFragmentShader = "#include <fog_pars_fragment>\n#include <wall_fragment_pars>\n#include <location_fade_fragment_pars>\nuniform sampler2D cmap;\nvarying float zMap;\nvoid main() {\n\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#include <location_fade_fragment>\n\t#include <fog_fragment>\n}";

	var popupVertexShader = "\nuniform mat2 rotate;\nuniform vec2 scale;\nuniform vec2 viewPort;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tvec2 newPosition = vec2( position.x, position.y );\n\tvColor = color;\n\tvUv = newPosition;\n\tnewPosition = rotate * newPosition;\n\tvec4 offset = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tnewPosition *= scale;\n\tnewPosition *= offset.w;\n\tgl_Position = vec4( newPosition, 0.0, 0.0 ) + offset;\n\tvec2 snap = viewPort / gl_Position.w;\n\tgl_Position.xy =  ( trunc( gl_Position.xy * snap ) + 0.5 ) / snap;\n}";

	var popupFragmentShader = "uniform sampler2D popupImage;\nvarying vec2 vUv;\nvarying vec3 vColor;\nvoid main() {\n\tgl_FragColor = texture2D( popupImage, vUv ) * vec4( vColor, 1.0 );\n}";

	var waterVertexShader = "attribute vec3 sinks;\nattribute float selection;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tvPosition = position;\n\tvSelection = selection;\n\tvSink = sinks;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var waterFragmentShader = "uniform float offset;\nvarying vec3 vPosition;\nvarying float vSelection;\nvarying vec3 vSink;\nvoid main() {\n\tgl_FragColor = vec4( 0.1, 0.1, sin( offset + distance( vPosition, vSink ) ) * 0.4 + 0.6, 0.0 );\n\tgl_FragColor = mix( gl_FragColor, vec4( 1.0, 0.0, 0.0, 1.0 ), vSelection );\n}";

	var lineVertexShader = "#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\nuniform float linewidth;\nuniform vec2 resolution;\nattribute vec3 instanceStart;\nattribute vec3 instanceEnd;\nattribute vec3 instanceColorStart;\nattribute vec3 instanceColorEnd;\nattribute float instanceHideVertex;\nvarying vec2 vUv;\nvarying float vHide;\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tuniform float minZ;\n\tuniform float scaleZ;\n\tvarying float zMap;\n#endif\n#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\t#include <depth_vertex_pars>\n\tvarying float height;\n#endif\n#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\tvarying float vCursor;\n#endif\n#if defined( CV_Z ) || defined ( CV_SCALEWIDTH )\n\tvarying float vFadeDepth;\n#endif\n#ifdef USE_DASH\n\tuniform float dashScale;\n\tattribute float instanceDistanceStart;\n\tattribute float instanceDistanceEnd;\n\tvarying float vLineDistance;\n#endif\nvarying vec3 vPosition;\nvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\tfloat a = projectionMatrix[ 2 ][ 2 ];\tfloat b = projectionMatrix[ 3 ][ 2 ];\tfloat nearEstimate = - 0.5 * b / a;\n\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\tend.xyz = mix( start.xyz, end.xyz, alpha );\n}\nvoid main() {\n\t#ifdef USE_COLOR\n\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\t#endif\n\t#ifdef USE_DASH\n\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t#endif\n\tfloat aspect = resolution.x / resolution.y;\n\tvUv = uv;\n\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\tif ( perspective ) {\n\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\t\t\ttrimSegment( start, end );\n\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\t\t\ttrimSegment( end, start );\n\t\t}\n\t}\n\tvec4 clipStart = projectionMatrix * start;\n\tvec4 clipEnd = projectionMatrix * end;\n\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\tvec2 dir = ndcEnd - ndcStart;\n\tdir.x *= aspect;\n\tdir = normalize( dir );\n\tvec2 offset = vec2( dir.y, - dir.x );\n\tdir.x /= aspect;\n\toffset.x /= aspect;\n\tif ( position.x < 0.0 ) offset *= - 1.0;\n\tif ( position.y < 0.0 ) {\n\t\toffset += - dir;\n\t} else if ( position.y > 1.0 ) {\n\t\toffset += dir;\n\t}\n\toffset *= linewidth;\n\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\t#if defined( CV_Z ) || defined ( CV_SCALEWIDTH )\n\t\tvec4 o = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\tvFadeDepth = ( 2.0 - clamp( clip.z, 0.0, 2.0 * o.z ) / o.z ) / 2.0;\n\t\tif ( ! perspective ) {\n\t\t\tvFadeDepth = 1.0 - vFadeDepth;\n\t\t}\n\t\t#ifdef CV_SCALEWIDTH\n\t\t\toffset *= max( vFadeDepth, 1.0 / linewidth );\n\t\t#endif\n\t#endif\n\toffset /= resolution.y;\n\toffset *= clip.w;\n\tclip.xy += offset;\n\tvPosition = ( position.y < 0.5 ) ? instanceStart : instanceEnd;\n\t#ifdef CV_CURSOR\n\t\tvCursor = vPosition.z;\n\t#endif\n\t#ifdef CV_HEIGHT\n\t\tzMap = ( vPosition.z - minZ ) * scaleZ;\n\t#endif\n\t#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\t\tvTerrainCoords = vec2( ( vPosition.x - modelMin.x ) * scaleX, ( vPosition.y - modelMin.y ) * scaleY );\n\t#endif\n\tvHide = instanceHideVertex;\n\tgl_Position = clip;\n\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end;\n\t#include <fog_vertex>\n}";

	var lineFragmentShader = "#include <packRGBA>\nuniform vec3 diffuse;\nuniform float opacity;\n#include <location_fade_fragment_pars>\n#ifdef CV_HEIGHT\n\tuniform sampler2D cmap;\n\tvarying float zMap;\n#endif\n#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\tuniform sampler2D depthMap;\n\tuniform sampler2D cmap;\n\tuniform vec3 modelMin;\n\tuniform float depthScale;\n\tuniform float rangeZ;\n\tuniform float datumShift;\n\tvarying vec2 vTerrainCoords;\n#endif\n#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\t#include <cursor_fragment_pars>\n\tvarying float height;\n#endif\n#ifdef USE_DASH\n\tuniform float dashSize;\n\tuniform float dashOffset;\n\tuniform float gapSize;\n#endif\n#ifdef CV_Z\n\tvarying float vFadeDepth;\n#endif\nvarying float vLineDistance;\nvarying vec3 vPosition;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\nvarying vec2 vUv;\nvarying float vHide;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( vHide > 0.0 ) discard;\n\t#ifdef USE_DASH\n\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard;\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; \n\t#endif\n\tif ( abs( vUv.y ) > 1.0 ) {\n\t\tfloat a = vUv.x;\n\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\tfloat len2 = a * a + b * b;\n\t\tif ( len2 > 1.0 ) discard;\n\t}\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\t#ifdef CV_HEIGHT\n\t\tgl_FragColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#if defined( CV_DEPTH ) || defined( CV_DEPTH_CURSOR )\n\t\tfloat terrainHeight = unpackRGBAToFloat( texture2D( depthMap, vTerrainCoords ) );\n\t\tterrainHeight = terrainHeight * rangeZ + modelMin.z + datumShift;\n\t\tfloat depth = terrainHeight - vPosition.z;\n\t\tfloat vCursor = depth;\n\t#endif\n\t#ifdef CV_DEPTH\n\t\tgl_FragColor = texture2D( cmap, vec2( depth * depthScale, 1.0 ) ) * vec4( vColor, 1.0 );\n\t#endif\n\t#if defined( CV_CURSOR ) || defined( CV_DEPTH_CURSOR )\n\t\t#include <cursor_fragment>\n\t#endif\n\t#ifdef CV_BASIC\n\t\tgl_FragColor = diffuseColor;\n\t#endif\n\t#ifdef CV_Z\n\t\tgl_FragColor = vec4( vFadeDepth, 0.0, 1.0 - vFadeDepth, diffuseColor.a );\n\t#endif\n\t#include <location_fade_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var wallVertexShader = "#include <fog_pars_vertex>\n#include <wall_vertex_pars>\nvoid main() {\n\t#include <wall_vertex>\n\t#include <fog_vertex>\n}";

	var wallFragmentShader = "#include <fog_pars_fragment>\n#include <wall_fragment_pars>\n#include <location_fade_fragment_pars>\nvoid main() {\n\tgl_FragColor = vec4( vColor, 1.0 );\n\t#include <location_fade_fragment>\n\t#include <fog_fragment>\n}";

	var wall_vertex = "\n\tvec3 sNormal = normalMatrix * normal;\n\tfloat dotNL = dot( normalize( sNormal ), uLight );\n\tvColor = saturate( dotNL ) * color + vec3( 0.3, 0.3, 0.3 );\n\tvPosition = position;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;";

	var wall_vertex_pars = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying vec3 vPosition;";

	var wall_fragment_pars = "\nuniform vec3 uLight;\nvarying vec3 vColor;\nvarying vec3 vPosition;";

	var depth_fragment_pars = "#include <packRGBA>\nuniform sampler2D depthMap;\nuniform sampler2D cmap;\nuniform vec3 modelMin;\nuniform float depthScale;\nuniform float rangeZ;\nuniform float datumShift;\nvarying vec2 vTerrainCoords;";

	var depth_vertex_pars = "uniform vec3 modelMin;\nuniform float scaleX;\nuniform float scaleY;\nvarying vec2 vTerrainCoords;";

	var depth_vertex = "\n\tvTerrainCoords = vec2( ( position.x - modelMin.x ) * scaleX, ( position.y - modelMin.y ) * scaleY );";

	var cursor_fragment = "float delta = abs( vPosition.z - cursor );\n\tfloat ss = smoothstep( 0.0, cursorWidth, cursorWidth - delta );\n\tif ( delta < cursorWidth * 0.05 ) {\n\t\tgl_FragColor = vec4( vColor, 1.0 );\n\t} else {\n\t\tgl_FragColor = vec4( mix( baseColor, cursorColor, ss ), 1.0 ) * vec4( vColor, 1.0 );\n\t}";

	var cursor_fragment_pars = "uniform float cursor;\nuniform float cursorWidth;\nuniform vec3 baseColor;\nuniform vec3 cursorColor;";

	var contour_vertex = "vPositionZ = position.z + zOffset + datumShift;\nvPosition = vec2( position.x, position.y );";

	var contour_vertex_pars = "uniform float zOffset;\nuniform float datumShift;\nvarying float vPositionZ;\nvarying vec2 vPosition;";

	var contour_fragment_pars = "uniform vec3 contourColor;\nuniform vec3 contourColor10;\nuniform float contourInterval;\nuniform vec3 baseColor;\nvarying float vPositionZ;";

	var contour_fragment = "float zLine = vPositionZ / contourInterval;\nfloat f = fract( zLine );\nfloat f10 = fract( zLine / 10.0 );\nfloat df = fwidth( zLine );\nif ( f > 0.5 ) {\n    f = 1.0 - f;\n    f10 = 1.0 - f10;\n}\nfloat contourColorSelection = step( 0.91, f10 );\nfloat c = smoothstep( df * 0.5, df * 1.0, f );\nvec4 finalColor = vec4( mix( contourColor, contourColor10, contourColorSelection ), 1.0 );\nvec4 baseColorAlpha = vec4( baseColor, opacity );\ndiffuseColor = mix( finalColor, baseColorAlpha, c );";

	var hypsometric_vertex = "vPosition = vec2( position.x, position.y );\nzMap = saturate( ( position.z - minZ ) * scaleZ );";

	var hypsometric_vertex_pars = "uniform float minZ;\nuniform float scaleZ;\nvarying float zMap;\nvarying vec2 vPosition;";

	var hypsometric_fragment_pars = "uniform sampler2D cmap;\nvarying float zMap;";

	var hypsometric_fragment = "diffuseColor = texture2D( cmap, vec2( 1.0 - zMap, 1.0 ) );\ndiffuseColor.a = opacity;";

	var location_fragment_pars = "uniform float accuracy;\nuniform vec2 target;\nuniform vec3 ringColor;\nvarying vec2 vPosition;";

	var location_fragment = "if ( accuracy >= 0.0 ) {\n\tfloat targetDistance = distance( target, vPosition );\n\tfloat f = abs( targetDistance - accuracy );\n\tfloat df = abs( fwidth( targetDistance ) );\n\tdiffuseColor = mix( vec4( ringColor, 1.0 ), diffuseColor, smoothstep( 0.0, 4.0 * df, f ) );\n}";

	var location_fade_fragment_pars = "#ifdef CV_LOCATION\n\tuniform float distanceFadeMin;\n\tuniform float distanceFadeMax;\n\tuniform vec3 cameraLocation;\n#endif";

	var location_fade_fragment = "#ifdef CV_LOCATION\n\t\tgl_FragColor.a = 1.0 - smoothstep( distanceFadeMin, distanceFadeMax, distance( cameraLocation, vPosition ) );\n\t#endif";

	var packRGBA = "const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packFloatToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToFloat( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}";

	Object.assign( ShaderChunk, {
		// common wall shader code
		wall_vertex: wall_vertex,
		wall_vertex_pars: wall_vertex_pars,
		wall_fragment_pars: wall_fragment_pars,

		// common depth below surface shader code
		depth_fragment_pars: depth_fragment_pars,
		depth_vertex_pars: depth_vertex_pars,
		depth_vertex: depth_vertex,

		// common cursor shader code
		cursor_fragment: cursor_fragment,
		cursor_fragment_pars: cursor_fragment_pars,

		contour_vertex: contour_vertex,
		contour_vertex_pars: contour_vertex_pars,
		contour_fragment_pars: contour_fragment_pars,
		contour_fragment: contour_fragment,

		hypsometric_vertex: hypsometric_vertex,
		hypsometric_vertex_pars: hypsometric_vertex_pars,
		hypsometric_fragment_pars: hypsometric_fragment_pars,
		hypsometric_fragment: hypsometric_fragment,

		// common terrain location indicator

		location_fragment_pars: location_fragment_pars,
		location_fragment: location_fragment,

		location_fade_fragment_pars: location_fade_fragment_pars,
		location_fade_fragment: location_fade_fragment,

		packRGBA: packRGBA
	} );

	const Shaders = {
		anaglyphVertexShader:	anaglyphVertexShader,
		anaglyphFragmentShader:	anaglyphFragmentShader,
		cursorVertexShader:		cursorVertexShader,
		cursorFragmentShader:	cursorFragmentShader,
		depthMapVertexShader:	depthMapVertexShader,
		depthMapFragmentShader:	depthMapFragmentShader,
		depthVertexShader:		depthVertexShader,
		depthFragmentShader:	depthFragmentShader,
		depthCursorVertexShader:		depthCursorVertexShader,
		depthCursorFragmentShader:		depthCursorFragmentShader,
		glyphVertexShader:		glyphVertexShader,
		glyphFragmentShader:	glyphFragmentShader,
		heightVertexShader:		heightVertexShader,
		heightFragmentShader:	heightFragmentShader,
		popupVertexShader:		popupVertexShader,
		popupFragmentShader:	popupFragmentShader,
		waterVertexShader:		waterVertexShader,
		waterFragmentShader:	waterFragmentShader,
		lineVertexShader:		lineVertexShader,
		lineFragmentShader:		lineFragmentShader,
		wallVertexShader:		wallVertexShader,
		wallFragmentShader:		wallFragmentShader
	};

	// EOF

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author marklundin / http://mark-lundin.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author tschw
	 */

	function AnaglyphEffect ( renderer, width, height ) {

		// Matrices generated with angler.js https://github.com/tschw/angler.js/
		// (in column-major element order, as accepted by WebGL)

		this.colorMatrixLeft = new Matrix3().fromArray( [

			1.0671679973602295, 	-0.0016435992438346148,		 0.0001777536963345483, // r out
			-0.028107794001698494,	-0.00019593400065787137,	-0.0002875397040043026, // g out
			-0.04279090091586113,	 0.000015809757314855233,	-0.00024287120322696865 // b out

		] );

		//	red						green 						blue  						in

		this.colorMatrixRight = new Matrix3().fromArray( [

			-0.0355340838432312,	-0.06440307199954987,		 0.018319187685847282,	// r out
			-0.10269022732973099,	 0.8079727292060852,		-0.04835830628871918,	// g out
			0.0001224992738571018,	-0.009558862075209618,		 0.567823588848114		// b out

		] );

		const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

		const _scene = new Scene();

		const _stereo = new StereoCamera();

		_stereo.cameraL.layers.mask = 0xFFFFFFFF;
		_stereo.cameraR.layers.mask = 0xFFFFFFFF;

		const _params = { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat };

		if ( width === undefined ) width = 512;
		if ( height === undefined ) height = 512;

		const pixelRatio = renderer.getPixelRatio();

		const _renderTargetL = new WebGLRenderTarget( width * pixelRatio, height * pixelRatio, _params );
		const _renderTargetR = new WebGLRenderTarget( width * pixelRatio, height * pixelRatio, _params );

		const _material = new ShaderMaterial( {

			uniforms: {

				'mapLeft': { value: _renderTargetL.texture },
				'mapRight': { value: _renderTargetR.texture },

				'colorMatrixLeft': { value: this.colorMatrixLeft },
				'colorMatrixRight': { value: this.colorMatrixRight }

			},

			vertexShader: Shaders.anaglyphVertexShader,
			fragmentShader: Shaders.anaglyphFragmentShader

		} );

		const _mesh = new Mesh( new PlaneGeometry( 2, 2 ), _material );
		_scene.add( _mesh );

		this.setLayers = function ( mask ) {

			_stereo.cameraL.layers.mask = mask;
			_stereo.cameraR.layers.mask = mask;

		};

		this.setSize = function ( width, height ) {

			renderer.setSize( width, height );

			const pixelRatio = renderer.getPixelRatio();

			_renderTargetL.setSize( width * pixelRatio, height * pixelRatio );
			_renderTargetR.setSize( width * pixelRatio, height * pixelRatio );

		};

		this.setEyeSeparation = function ( x ) {

			_stereo.eyeSep = x;

		};

		this.render = function ( scene, camera ) {

			scene.updateMatrixWorld();

			if ( camera.parent === null ) camera.updateMatrixWorld();

			_stereo.update( camera );

			renderer.setRenderTarget( _renderTargetL );
			renderer.clear();
			renderer.render( scene, _stereo.cameraL );

			renderer.setRenderTarget( _renderTargetR );
			renderer.clear();
			renderer.render( scene, _stereo.cameraR );

			renderer.setRenderTarget( null );
			renderer.render( _scene, _camera );

		};

		this.dispose = function() {

			_renderTargetL.dispose();
			_renderTargetR.dispose();

			_material.dispose();
			_mesh.geometry.dispose();

		};

	}

	const __rotation = new Euler();
	const __q = new Quaternion();

	function CameraManager ( ctx, renderer, scene ) {

		const container = ctx.container;

		const width = container.clientWidth;
		const height = container.clientHeight;

		const orthographicCamera = new OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, 0.05, 4000 );
		const perspectiveCamera = new PerspectiveCamera( ctx.cfg.themeValue( 'fieldOfView' ), width / height, 1, 16000 );

		const self = this;

		let savedMask;

		scene.add( perspectiveCamera );
		scene.add( orthographicCamera );

		initCamera( perspectiveCamera );
		initCamera( orthographicCamera );

		this.activeCamera = perspectiveCamera;
		this.mode = CAMERA_PERSPECTIVE;

		const backMaterial = new MeshBasicMaterial( { side: BackSide, colorWrite: false } );
		const backMask = 1 << FEATURE_SURVEY | 1 << FEATURE_TERRAIN;

		let eyeSeparation = 0.5;
		let lastFrame = 0;
		let activeEffect = null;

		ctx.viewer.addEventListener( 'resized', onResize );

		function onResize ( e ) {

			const width = e.width;
			const height = e.height;

			// adjust cameras to new aspect ratio etc.

			orthographicCamera.zoom *= width / ( orthographicCamera.right - orthographicCamera.left );

			orthographicCamera.left   = -width / 2;
			orthographicCamera.right  =  width / 2;
			orthographicCamera.top    =  height / 2;
			orthographicCamera.bottom = -height / 2;

			orthographicCamera.updateProjectionMatrix();

			perspectiveCamera.aspect = width / height;

			perspectiveCamera.updateProjectionMatrix();

			activeEffect?.setSize( width, height );

		}

		const standardRenderer = function () {

			// render depth buffer from underside of terrain
			const camera = self.activeCamera;

			if ( self.testCameraLayer( FEATURE_TERRAIN ) ) {

				camera.layers.mask = backMask;
				scene.overrideMaterial = backMaterial;

				renderer.render( scene, camera );

				scene.overrideMaterial = null;
				camera.layers.mask = savedMask;

			}

			renderer.render( scene, camera );
			renderer.getContext().flush();

			lastFrame = renderer.info.render.frame;

		};

		this.activeRenderer = standardRenderer;

		function initCamera ( camera ) {

			camera.zoom = 1;

			camera.layers.set( 0 );

			camera.layers.enable( LEG_CAVE );
			camera.layers.enable( FEATURE_SELECTED_BOX );
			savedMask = camera.layers.mask;

		}

		this.resetCameras = function () {

			initCamera( perspectiveCamera );
			initCamera( orthographicCamera );

		};

		this.setCameraLayer = function ( layerTag, enable ) {

			// ignore if no change

			if ( enable == this.testCameraLayer( layerTag ) ) return false;

			if ( enable ) {

				perspectiveCamera.layers.enable( layerTag );
				orthographicCamera.layers.enable( layerTag );

			} else {

				perspectiveCamera.layers.disable( layerTag );
				orthographicCamera.layers.disable( layerTag );

			}

			savedMask = this.activeCamera.layers.mask;

			activeEffect?.setLayers( savedMask );

			return true;

		};

		this.testCameraLayer = function ( layerTag ) {

			return ( ( savedMask & 1 << layerTag ) > 0 );

		};

		this.setCamera = function ( mode, target ) {

			if ( this.mode === mode ) return;

			let offsetLength;
			let activeCamera = this.activeCamera;

			const offset = activeCamera.position.clone().sub( target );

			if ( activeEffect !== null ) {

				activeEffect.dispose();
				activeEffect = null;

			}

			switch ( mode ) {

			case CAMERA_ANAGLYPH:

				activeEffect = new AnaglyphEffect( renderer, width, height );

				if ( activeCamera.isPerspective ) break;

			case CAMERA_PERSPECTIVE: // eslint-disable-line no-fallthrough

				offsetLength = 4 * height * Math.tan( DEG2RAD * perspectiveCamera.fov / 2 ) / orthographicCamera.zoom / 2;

				offset.setLength( offsetLength );

				activeCamera = perspectiveCamera;

				break;

			case CAMERA_ORTHOGRAPHIC:

				offsetLength = offset.length();

				if ( offsetLength === 0 ) {

					offset.z = 1;
					offsetLength = 1;

				}

				orthographicCamera.zoom = 2 * height * Math.tan( DEG2RAD * perspectiveCamera.fov / 2 ) / offsetLength;

				activeCamera = orthographicCamera;

				break;

			default:

				console.warn( 'unknown camera mode', mode );
				return;

			}

			if ( activeEffect !== null ) {

				activeEffect.setLayers( activeCamera.layers.mask );

				this.activeRenderer = function () {

					activeEffect.render( scene, activeCamera );

				};

			} else {

				this.activeRenderer = standardRenderer;

			}

			// update new camera with position to give same apparent zoom and view

			activeCamera.position.copy( offset.add( target ) );

			activeCamera.updateProjectionMatrix();
			activeCamera.lookAt( target );

			this.activeCamera = activeCamera;
			this.mode = mode;

		};

		this.getLastFrame = function () {

			return lastFrame;

		};

		this.getRotation = function () {

			return __rotation.setFromQuaternion( this.activeCamera.getWorldQuaternion( __q ) );

		};

		Object.defineProperties( this, {

			'eyeSeparation': {
				get() { return eyeSeparation; },
				set( x ) {

					// x varies from 0 to 1
					// base separation = 0.064
					eyeSeparation = x;

					if ( activeEffect !== null ) {

						activeEffect.setEyeSeparation( 0.064 + ( x - 0.5 ) * 0.06 );

					}

				}

			},

			'focalLength': {
				get() { return perspectiveCamera.getFocalLength(); },
				set( x ) { perspectiveCamera.setFocalLength( x ); }
			}

		} );

	}

	const __v1$2 = new Vector3();
	const __v2$2 = new Vector3();
	const __v3 = new Vector3();
	const __m4 = new Matrix4();
	const __e$1 = new Euler();

	class CameraMove {

		constructor ( controls, renderFunction ) {

			const endCameraPosition = new Vector3();
			const endPOI = new Vector3();
			const endQuaternion = new Quaternion();
			const cameraManager = controls.cameraManager;

			let endZoom = 1;
			let frameCount = 0;
			let skipNext = false;
			let rotation = 0;
			let delta = 0;
			let running = false;
			let animationFunction = null;
			let rafID = 0;

			function getCardinalAxis ( targetAxis ) {

				cameraManager.activeCamera.getWorldDirection( __v1$2 );

				const x = Math.abs( __v1$2.x );
				const y = Math.abs( __v1$2.y );
				const z = Math.abs( __v1$2.z );

				if ( x > y && x > z ) {

					targetAxis.set( Math.sign( __v1$2.x ), 0, 0 );

				} else if ( y > z ) {

					targetAxis.set( 0, Math.sign( __v1$2.y ), 0 );

				} else {

					targetAxis.set( 0, 0, Math.sign( __v1$2.z ) );

				}

			}

			function prepareRotation ( endCamera, orientation ) {

				const camera = cameraManager.activeCamera;

				__v1$2.copy( endCamera ).sub( endPOI ).normalize();

				const zDot = __v1$2.dot( Object3D.DefaultUp );

				if ( Math.abs( zDot ) > 0.99999 && orientation !== undefined ) {

					// apply correction if looking verticaly to set to required cardinal direction for 'up'
					endCamera.add( orientation.multiplyScalar( 0.02 * __v1$2.z ) );

				}

				// calculate end state rotation of camera

				__m4.lookAt( endCamera, endPOI, Object3D.DefaultUp );

				endQuaternion.setFromRotationMatrix( __m4 ).normalize();

				// rotation to nearest degree
				rotation = Math.round( 2 * Math.acos( Math.abs( clamp( endQuaternion.dot( camera.quaternion ), - 1, 1 ) ) ) * RAD2DEG );

			}

			this.prepare = function ( endBox, requiredTargetAxis ) {

				if ( running ) return this;

				const targetAxis = __v2$2;
				const orientation = __v3;

				const camera = cameraManager.activeCamera;
				const cameraStart = camera.position;

				skipNext = false;

				// move camera to cardinal axis closest to current camera direction
				// or axis provided by caller

				if ( requiredTargetAxis === undefined ) {

					getCardinalAxis( targetAxis );

					if ( targetAxis.z !== 0 ) {

						// set orientation from current orientation, snapping to cardinals
						__e$1.setFromQuaternion( camera.quaternion );

						const direction = Math.round( 2 * ( __e$1.z + Math.PI ) / Math.PI );

						switch ( direction ) {

						case 0:
						case 4:

							orientation.set( 0, 1, 0 ); // S
							break;

						case 1:

							orientation.set( -1, 0, 0 ); // E
							break;

						case 2:

							orientation.set( 0, -1, 0 ); // N
							break;

						case 3:

							orientation.set( 1, 0, 0 ); // W
							break;

						default:

							orientation.set( 0, -1, 0 ); // up = N when looking vertically

						}

					}

				} else {

					targetAxis.copy( requiredTargetAxis );
					orientation.set( 0, -1, 0 ); // up = N when looking vertically

				}

				const fit = fitBox( camera, endBox, targetAxis );

				endBox.getCenter( endPOI );
				endZoom = fit.zoom;

				endCameraPosition.copy( endPOI ).add( targetAxis.negate().multiplyScalar( fit.elevation ) );

				// skip move if extremely small

				const cameraOffset = cameraStart.distanceTo( endCameraPosition );

				// calculate end state rotation of camera

				prepareRotation( endCameraPosition, orientation );

				if ( cameraOffset < 0.1 * endCameraPosition.z ) {

					// simple rotation of camera, minimal camera position change

					skipNext = ( rotation === 0 );

				} else {

					rotation = 0;

				}

				animationFunction = animateMove;

				return this;

			};

			this.preparePoint = function ( endPOIIn ) {

				if ( running ) return this;

				const camera = cameraManager.activeCamera;

				// calculate end state rotation of camera
				endPOI.copy( endPOIIn );
				endCameraPosition.copy( camera.position );

				prepareRotation( camera.position );

				// minimal camera rotation or no change of POI
				skipNext = ( rotation === 0 );

				animationFunction = animateMove;

				return this;

			};

			this.start = function ( timed ) {

				if ( running || skipNext ) return;

				if ( timed ) {

					frameCount = ( rotation > 0 ) ? Math.max( 1, Math.round( rotation / 2 ) ) : 30;

				} else {

					frameCount = 1;

				}

				controls.enabled = false;

				running = true;

				animate();

			};

			this.cancel = function () {

				if ( rafID !== 0 ) window.cancelAnimationFrame( rafID );

				if ( ! running ) return;

				frameCount = 1;
				running = false;
				rafID = 0;

				animate();

				controls.enabled = true;
				controls.autoRotate = false;

			};

			function animate () {

				if ( controls.autoRotate ) {

					controls.update();

				} else if ( animationFunction ) {

					animationFunction();

					if ( --frameCount === 0 ) {

						animationFunction = null;
						endAnimation();

					}

				}

				if ( running ) rafID = window.requestAnimationFrame( animate );

			}

			function endAnimation () {

				controls.target.copy( endPOI );
				cameraManager.activeCamera.position.copy( endCameraPosition );

				running = false;
				rotation = 0;
				rafID = 0;

				controls.enabled = true;
				controls.end();

			}

			function animateMove () {

				// update camera position

				const camera = cameraManager.activeCamera;
				const target = controls.target;
				const dt = 1 - ( frameCount - 1 ) / frameCount;

				if ( ! rotation ) {

					camera.position.lerp( endCameraPosition, dt);
					camera.zoom = camera.zoom + ( endZoom - camera.zoom ) * dt;

					if ( camera.isOrthographicCamera ) camera.updateProjectionMatrix();

					camera.lookAt( target.lerp( endPOI, dt ) );

				}

				camera.quaternion.slerp( endQuaternion, dt );

				renderFunction();

			}

			function setAngleCommon ( deltaIn ) {

				frameCount = Math.max( 1, Math.round( Math.abs( deltaIn ) * 90 / Math.PI ) );
				delta = deltaIn / frameCount;
				running = true;

				animate();

			}

			function animateAzimuthMove () {

				controls.rotateLeft( delta );

			}

			this.setAzimuthAngle = function ( targetAngle ) {

				if ( running || controls.autoRotate ) return this;

				let delta = ( controls.getAzimuthalAngle() - targetAngle );
				const deltaSize = Math.abs( delta );

				if ( deltaSize > Math.PI ) delta = 2 * Math.PI - deltaSize;

				animationFunction = animateAzimuthMove;
				setAngleCommon( delta );

			};

			function animatePolarMove () {

				controls.rotateUp( delta );

			}

			this.setPolarAngle = function ( targetAngle ) {

				if ( running ) return this;

				animationFunction = animatePolarMove;

				setAngleCommon( controls.getPolarAngle() - targetAngle );

			};

			this.setAutoRotate = function ( state ) {

				if ( state ) {

					if ( running ) return;

					controls.autoRotate = true;

					running = true;
					animationFunction = false;

					animate();

				} else {

					if ( controls.autoRotate ) running = false;

					controls.autoRotate = false;
					controls.enabled = true;
					rafID = 0;

				}

			};

			function fitBox ( camera, box, viewAxis ) {

				const size = box.getSize( __v1$2 );

				let elevation = CAMERA_OFFSET;
				let zoom = 1;

				let dX, dY, dZ;

				if ( viewAxis === undefined || viewAxis.z !== 0 ) {

					dX = size.x;
					dY = size.y;
					dZ = size.z;

				} else if ( viewAxis.x !== 0 ) {

					dX = size.y;
					dY = size.z;
					dZ = size.x;

				} else {

					dX = size.x;
					dY = size.z;
					dZ = size.y;

				}

				if ( camera.isPerspectiveCamera ) {

					const tan2 = 2 * Math.tan( DEG2RAD * 0.5 * camera.getEffectiveFOV() );

					const e1 = dY / tan2;
					const e2 = ( 1 / camera.aspect ) * dX / tan2;

					elevation = Math.max( e1, e2 ) * 1.1 + dZ / 2;

					if ( elevation === 0 ) elevation = 100;

				} else {

					const hRatio = ( camera.right - camera.left ) / dX;
					const vRatio = ( camera.top - camera.bottom ) / dY;

					zoom = Math.min( hRatio, vRatio ) * 1 / 1.1;

				}

				return { zoom: zoom, elevation: elevation };

			}

		}

	}

	function replaceExtension( fileName, newExtention ) {

		if ( fileName === undefined ) return 'file set';

		return fileName.split( '.' ).shift() + '.' + newExtention;

	}

	function dataURL( json ) {

		return 'data:text/json;charset=utf8,' + encodeURIComponent( JSON.stringify( json, null, '\t' ) );

	}

	function Tree( name, id, root, parent ) { // root parameter only used internally

		if ( root === undefined ) {

			this.id = 0;
			this.maxId = 0;
			this.root = this;
			this.parent = null;
			this.pathCache = [];
			this.idCache = [];

		} else {

			this.root = root;
			this.parent = parent;
			this.id = ( id === null ) ? ++root.maxId : id;

			parent.children.push( this );

		}

		this.boundingBox = new Box3(); // FIXME - make optional - overhead for stations
		this.stationCount = 0;
		this.name = name || '';
		this.children = [];
		this.type = 0;

	}

	Tree.prototype.sorted = false;

	Tree.prototype.traverse = function ( func ) {

		func ( this );

		if ( this.children === undefined ) return;

		const children = this.children;

		for ( let i = 0; i < children.length; i++ ) {

			children[ i ].traverse( func );

		}

	};

	Tree.prototype.traverseDepthFirst = function ( func ) {

		const children = this.children;

		for ( let i = 0; i < children.length; i++ ) {

			children[ i ].traverseDepthFirst( func );

		}

		func( this );

	};

	Tree.prototype.forEachChild = function ( func ) {

		this.children.forEach( child => func( child ) );

	};

	Tree.prototype.addById = function ( name, id ) {

		const root = this.root;
		const node = new Tree( name, id, root, this );

		root.maxId = Math.max( root.maxId, id );
		this.root.idCache[ id ] = node;

		return node;

	};

	Tree.prototype.addPath = function ( path ) {

		// find part of path that exists already
		const pathArray = path.split( '.' );

		let node = this.getByPathArray( pathArray );

		// return node or add remainder of path to node

		while ( pathArray.length > 0 ) {

			const newNode = new Tree( pathArray.shift(), null, this.root, node );

			this.root.pathCache[ newNode.getPath() ] = newNode;
			node = newNode;

		}

		return node;

	};

	Tree.prototype.addLeaf = function ( path, leafNode, comments ) {

		const root = this.root;

		// common for all paths

		leafNode.root = root;
		leafNode.id = ++root.maxId;

		if ( comments ) leafNode.comments = comments;

		// short cut for flat surveys with little tree structure
		if ( path.length === 1 ) {

			leafNode.name = path[ 0 ];
			leafNode.parent = this;

			this.children.push( leafNode );

			return leafNode;

		}

		// find part of path that exists already using cache

		const leaf = [];
		let node;

		while ( node === undefined && path.length > 1 ) {

			leaf.unshift( path.pop() );
			node = this.root.pathCache[ path.join( '.' ) ];

		}

		// we have a valid path - attach the leaf here

		if ( node !== undefined) {

			leafNode.name = leaf.join( '.' );
			leafNode.parent = node;
			node.children.push( leafNode );

			return leafNode;

		}

		// fallback in case path not created

		path = path.concat( leaf );

		node = this.getByPathArray( path );

		if ( path.length === 0 ) return node;

		// add remainder of path to node

		while ( path.length > 1 ) {

			node = new Tree( path.shift(), null, this.root, node );

		}

		leafNode.name = path.shift();
		leafNode.parent = node;
		node.children.push( leafNode );

		return leafNode;

	};

	Tree.prototype.addLeafById = function ( name, id, leafNode, comment ) {

		const root = this.root;

		leafNode.name = name;
		leafNode.id = id;
		leafNode.parent = this;

		this.children.push( leafNode );

		if ( comment ) leafNode.comment = comment;

		root.maxId = Math.max( root.maxId, id );
		this.root.idCache[ id ] = leafNode;

		return leafNode;

	};

	Tree.prototype.findById = function ( id ) {

		if ( this.id === id ) return this;

		const node = this.root.idCache[ id ];
		if ( node !== undefined ) return node;

		for ( let i = 0, l = this.children.length; i < l; i++ ) {

			const found = this.children[ i ].findById( id );

			if ( found ) return found;

		}

		return undefined;

	};

	/*
	Tree.prototype.getByPath = function ( path ) {

		const pathArray = path.split( '.' );
		const node = this.getByPathArray( pathArray );

		return ( pathArray.length === 0 ) ? node: undefined;

	};
	*/

	Tree.prototype.getByPath = function ( path ) {

		if ( ! path )
			return undefined;

		const pathArray = path.split( '.' );

		let node = this.getByPathArray( pathArray );
		let pathArrayPos = undefined;

		if ( pathArray.length !== 0 )
		{
			const pathArrayEx = path.split( '.' );

			if ( pathArrayEx.length - 2 < 0 )
				return undefined;

			const pathArrayMainPath = pathArrayEx.slice( 0, pathArrayEx.length - 2 );
			const pathPosStation = pathArrayEx.slice( pathArrayEx.length - 2, pathArrayEx.length ).join( '.' );

			node = this.getByPathArray( pathArrayPos = pathArrayMainPath.concat( pathPosStation ) );
		}

		return ( ( pathArray.length === 0 ) || ( pathArrayPos.length === 0 ) ) ? node: undefined;

	};

	Tree.prototype.getByPathArray = function ( path ) {

		let node = this.root;
		let search = true;

		while ( search && path.length > 0 ) {

			search = false;

			for ( let i = 0, l = node.children.length; i < l; i++ ) {

				const child = node.children[ i ];

				if ( child.name === path[ 0 ] ) {

					node = child;
					path.shift();
					search = true;

					break;

				}

			}

		}

		return node;

	};

	Tree.prototype.getPath = function ( endNode ) {

		const path = [];

		let node = this;

		if ( endNode === undefined ) endNode = this.root;

		do {

			path.push( node.name );
			node = node.parent;

		} while ( node !== endNode && node !== null );

		return path.reverse().join( '.' );

	};

	Tree.prototype.getSubtreeIds = function ( idSet ) {

		this.traverse( _getId );

		function _getId( node ) {

			if ( node.type === 0 ) idSet.add( node.id );

		}

		return idSet;

	};

	Tree.prototype.getIdByPath = function ( path ) {

		const array = path.split( '.' );
		const node = this.getByPathArray( array );

		if ( array.length === 0 ) {

			return node.id;

		} else {

			return undefined;

		}

	};

	Tree.prototype.trim = function ( path ) {

		const prefix = path.shift();
		const children = this.children;

		let child;

		if ( prefix === undefined ) return;

		for ( let i = 0; i < children.length; i++ ) {

			child = children[ i ];

			if ( child.name === prefix ) break;

		}

		this.children = [ child ];

		child.trim( path );

	};

	Tree.prototype.updateWorld = function ( matrixWorld ) {

		this.worldBoundingBox = this.boundingBox.clone().applyMatrix4( matrixWorld );

	};

	// node: recursive generator function - handle with care

	Tree.prototype.findIntersects = function* ( matrixWorld, ray ) {

		if ( this.type !== 0 ) return;

		if ( this === this.root ) {

			if ( ! this.worldBoundingBox ) this.updateWorld( matrixWorld );
			if ( ! ray.intersectsBox( this.worldBoundingBox ) ) return;

		}

		const children = this.children;
		const l = children.length;

		// finding smallest child box that intersects

		for ( let i = 0; i < l; i++ ) {

			const node = children[ i ];

			// ignore survey stations
			if ( node.type !== 0 ) continue;

			if ( ! node.worldBoundingBox ) node.updateWorld( matrixWorld );

			if ( ray.intersectsBox( node.worldBoundingBox ) ) {

				yield* node.findIntersects( matrixWorld, ray );

			}

		}

		// only return nodes with stations as children
		if ( this.stationCount > 0 ) yield this;

	};

	Tree.prototype.isStation = function () {

		return ( this.type !== 0  );

	};

	// extend Vector3 to add methods to calculate lengths corrected for distortions introduced

	class StationPosition extends Vector3 {

		constructor ( x, y, z ) {

			super ( x, y, z );

			this.id = 0;
			this.parent = null;
			this.name = null;
			this.legs = [];
			this.linkedSegments = [];
			this.stationVertexIndex = -1;

		}

		effectiveConnections () {

			let connections = this.connections;
			let next = this.next;

			while ( next !== null && next !== this ) {

				connections += next.connections;
				next = next.next;

			}

			return connections;

		}

		// add station to linked list of duplicate stations
		linkStation ( station ) {

			if ( this.next ) {

				const oldNext = this.next;

				this.next = station;
				station.next = oldNext;

			} else {

				// note: special case adding to single station.
				// preserves benefit of default null values attached to prototype

				this.next = station;
				station.next = this;

				this.ownType = this.type;

			}

			station.ownType = station.type;

			this.type |= station.type;
			station.type = this.type;

		}

	}

	StationPosition.prototype.connections = 0;
	StationPosition.prototype.splays = 0;
	StationPosition.prototype.shortestPath = Infinity;
	StationPosition.prototype.children = []; // leaf nodes
	StationPosition.prototype.next = null;
	StationPosition.prototype.ownType = null;

	Object.assign( StationPosition.prototype, Tree.prototype );

	class Svx3dHandler {

		type = 'arraybuffer';

		constructor ( fileName ) {

			this.fileName = fileName;
			this.groups = [];
			this.section = null;
		}

		parse ( cave, dataStream, metadata, section, progress ) {

			cave.metadata = metadata;

			this.section = section;
			this.progress = progress;
			this.groups = [];
			this.cave = cave;
			this.stationMap = new Map();
			this.dataStream = dataStream;

			let pos = 0; // file position
			const decoder = new TextDecoder();

			// read file header

			readLF(); // Survex 3D Image File
			this.version = readLF(); // 3d version
			const auxInfo = readNSLF();
			readLF(); // Date

			const sourceCRS = ( auxInfo[ 1 ] === undefined ) ? null : auxInfo[ 1 ]; // coordinate reference system ( proj4 format )

			console.log( 'Survex .3d version ', this.version );

			this.pos = pos;

			return cave.setCRS( sourceCRS ).then( () => this.parse2() );

			function readLF () { // read until Line feed

				return readNSLF()[ 0 ];

			}

			function readNSLF () { // read until Line feed and split by null bytes

				const bytes = new Uint8Array( dataStream, 0 );
				const strings = [];

				let b;
				let start = pos;

				do {

					b = bytes[ pos++ ];

					if ( b === 0x0a || b === 0 ) {

						strings.push( decoder.decode( bytes.subarray( start, pos ) ).trim() );
						start = pos;

					}

				} while ( b !== 0x0a );

				return strings;

			}

		}

		parse2 () {

			const cave = this.cave;

			switch ( this.version ) {

			case 'Bv0.01':

				this.handleOld( 1 );

				break;

			case 'v3':
			case 'v4':
			case 'v5':
			case 'v6':
			case 'v7':
			case 'v8':

				this.handleVx( Number( this.version.charAt( 1 ) ), this.section );

				break;

			default:

				throw new Error( 'unsupported .3d version ' + this.version );

			}

			// if pre selecting a section - trim returned surveyTree
			if ( this.section !== null ) cave.surveyTree.trim( this.section.split( '.' ) );

			cave.addStations( this.stationMap );

			cave.addLineSegments( this.groups );
			cave.enableSplayFix();

			return cave;

		}

		handleOld ( version ) {

			const cave       = this.cave;
			const source     = this.dataStream;
			const surveyTree = cave.surveyTree;
			const projection = cave.projection;
			const limits     = cave.limits;

			const groups     = this.groups;
			const stationMap = this.stationMap;

			// init cmd handler table with error handler for unsupported records
			// or invalid records
			const cmd = Array( 256 ).fill( cmd_UNKNOWN );

			const stations = new Map();

			const dataView   = new DataView( source, 0 );
			const data       = new Uint8Array( source, 0 );
			const dataLength = data.length;

			let label     = '';
			const sectionId = 0;
			let legs      = [];
			let pos = this.pos;

			let lastPosition = new StationPosition(); // value to allow approach vector for xsect coord frame

			function cmd_UNKNOWN ( e ) { throw new Error( 'unhandled command: ' + e.toString( 16 ) + ' @ ' + pos.toString( 16 ) ); }

			cmd[ 0x00 ] = cmd_STOP;
			cmd[   -1 ] = cmd_STOP;

			cmd[ 0x01 ] = cmd_SKIP;

			cmd[ 0x02 ] = cmd_LABEL_V1; // version numbers not related to Survex versions
			cmd[ 0x03 ] = cmd_LABEL_V1;

			cmd[ 0x04 ] = cmd_MOVE;
			cmd[ 0x05 ] = cmd_LINE_V1;

			cmd[ 0x06 ] = cmd_LABEL_V2;
			cmd[ 0x07 ] = cmd_LABEL_V3;

			for ( let i = 0x40; i < 0x80; i++ ) {

				cmd[ i ] = cmd_LABEL_V4;

			}

			for ( let i = 0x80; i < 0x100; i++ ) {

				cmd[ i ] = cmd_LINE_V2;

			}

			// dispatch table end

			// common record iterator
			// loop though data, handling record types as required.

			if ( version === 1 ) {

				while ( pos < dataLength ) {

					const cmdCode = dataView.getInt32( pos, true );
					pos += 4;

					if ( ! cmd[ cmdCode ]() ) break;

				}

			} else {

				alert( 'Unsupported version' + version );

				while ( pos < dataLength ) {

					if ( ! cmd[ data[ pos ] ]( data[ pos++ ] ) ) break;

				}

			}

			groups.push( legs );

			// assign survey ids to all leg vertices by looking up tree node for coords

			for ( let i = 0, li = groups.length; i < li; i++ ) {

				const group = groups[ i ];

				for ( let j = 0, lj = group.length; j < lj; j++ ) {

					const leg = group[ j ];
					const coords = leg.coords;

					const node = stations.get( coords );

					if ( node === undefined ) continue;

					leg.survey = node.parent.id;

				}

			}

			function cmd_STOP ( /* c */ ) {

				return true;

			}

			function cmd_SKIP ( /* c */ ) {

				console.log( 'SKIP' );
				return false;

			}

			function cmd_LABEL_V1 ( /* c */ ) {

				const db = [];

				let nextByte = data[ pos++ ];

				while ( nextByte !== 10 ) {

					db.push( nextByte );
					nextByte = data[ pos++ ];

				}

				if ( db[ 0 ] === 92 ) db.shift(); // remove initial '/' characters

				label = String.fromCharCode.apply( null, db );
				lastPosition.type = STATION_NORMAL;

				const node = surveyTree.addLeaf( label.split( '.' ), lastPosition );

				// track coords to sectionId to allow survey ID's to be added to leg vertices
				stations.set( lastPosition, node );

				return true;

			}

			function cmd_LABEL_V2 ( /* c */ ) {

				console.log( 'LABEL_V2' );
				return false;

			}

			function cmd_LABEL_V3 ( /* c */ ) {

				console.log( 'LABEL_V3' );
				return false;

			}

			function cmd_LABEL_V4 ( /* c */ ) {

				console.log( 'LABEL_V4' );
				return false;

			}

			function cmd_MOVE ( /* c */ ) {

				const coords = readCoordinates();

				lastPosition = coords;

				// lookahead at next command
				if ( version === 1 && dataView.getInt32( pos, true ) === 2 ) {

					// version 1 uses MOVE+LABEL pairs to label stations
					return true;

				}

				if ( legs.length > 1 ) groups.push( legs );

				legs = [];

				legs.push( { coords: coords } );

				return true;

			}

			function cmd_LINE_V1 ( /* c */ ) {

				const coords = readCoordinates();

				legs.push( { coords: coords, type: LEG_CAVE, survey: sectionId } );

				lastPosition.connections++;
				coords.connections++;

				lastPosition = coords;

				return true;

			}

			function cmd_LINE_V2 ( /* c */ ) {

				console.log( 'LINE_V2' );
				return false;

			}

			function readCoordinates () {

				const l = new DataView( source, pos );

				let coords = new StationPosition(
					l.getInt32( 0, true ) / 100,
					l.getInt32( 4, true ) / 100,
					l.getInt32( 8, true ) / 100
				);

				pos += 12;

				const key = coords.x + ',' + coords.y + ',' + coords.z;
				const cachedCoords = stationMap.get( key );

				if ( cachedCoords !== undefined ) {

					coords = cachedCoords;

				} else {

					if ( projection !== null) {

						const projectedCoords = projection.forward( {
							x: coords.x,
							y: coords.y
						} );

						coords.x = projectedCoords.x;
						coords.y = projectedCoords.y;

					}

					limits.expandByPoint( coords );

					stationMap.set( key, coords );

				}

				return coords;

			}

		}

		handleVx ( version, section ) {

			const cave       = this.cave;
			const source     = this.dataStream;

			const surveyTree = cave.surveyTree;
			const messages   = cave.messages;
			const projection = cave.projection;
			const limits     = cave.limits;

			const groups     = this.groups;
			const xGroups    = [];
			const stationMap = this.stationMap;

			// init cmd handler table with error handler for unsupported records
			// or invalid records
			const cmd = Array( 256 ).fill( cmd_UNKNOWN );

			const stations = new Map();

			const data       = new Uint8Array( source, 0 );
			const dataView   = new DataView( source, 0 );
			const dataLength = data.length;
			const __coords = { x: 0.0, y: 0.0 };

			let pos = this.pos;
			let legs      = [];
			let label     = '';
			let xSects    = [];
			let sectionId = 0;

			let move = false;
			let lastPosition = new StationPosition();
			let lastKey = null; // map key for last coordinates read

			let lastXSectPosition = null; // value to indicate missing approach vector for xsect coord frame
			let labelChanged = false;
			let inSection = ( section === null );
			let splayExpected = false; // xsect expected to end on a splay

			let message;

			// functions

			let readLabel;

			function cmd_UNKNOWN ( e ) { throw new Error( 'unhandled command: ' + e.toString( 16 ) + ' @ ' + pos.toString( 16 ) ); }

			if ( version === 8 ) {
				// v8 dispatch table start

				cmd[ 0x00 ] = cmd_STYLE;
				cmd[ 0x01 ] = cmd_STYLE;
				cmd[ 0x02 ] = cmd_STYLE;
				cmd[ 0x03 ] = cmd_STYLE;
				cmd[ 0x04 ] = cmd_STYLE;

				cmd[ 0x0f ] = cmd_MOVE;
				cmd[ 0x10 ] = cmd_DATE_NODATE;
				cmd[ 0x11 ] = cmd_DATEV8_1;
				cmd[ 0x12 ] = cmd_DATEV8_2;
				cmd[ 0x13 ] = cmd_DATEV8_3;

				cmd[ 0x1F ] = cmd_ERROR;

				cmd[ 0x30 ] = cmd_XSECT16;
				cmd[ 0x31 ] = cmd_XSECT16;

				cmd[ 0x32 ] = cmd_XSECT32;
				cmd[ 0x33 ] = cmd_XSECT32;

				for ( let i = 0x40; i < 0x80; i++ ) {

					cmd[ i ] = cmd_LINE;

				}

				for ( let i = 0x80; i < 0x100; i++ ) {

					cmd[ i ] = cmd_LABEL;

				}

				// dispatch table end

				readLabel = readLabelV8;

				// skip v8 file wide flags after header
				pos++;

			} else {

				// dispatch table for v7 format

				for ( let i = 0x01; i < 0x0f; i++ ) {

					cmd[ i ] = cmd_TRIM_PLUS;

				}

				cmd[ 0x0f ] = cmd_MOVE;

				for ( let i = 0x10; i < 0x20; i++ ) {

					cmd[ i ] = cmd_TRIM;

				}

				cmd[ 0x00 ] = cmd_STOP;
				cmd[ 0x20 ] = cmd_DATE_V7;
				cmd[ 0x21 ] = cmd_DATE2_V7;
				cmd[ 0x23 ] = cmd_DATE3_V7;
				cmd[ 0x24 ] = cmd_DATE_NODATE;
				cmd[ 0x22 ] = cmd_ERROR;

				cmd[ 0x30 ] = cmd_XSECT16;
				cmd[ 0x31 ] = cmd_XSECT16;

				cmd[ 0x32 ] = cmd_XSECT32;
				cmd[ 0x33 ] = cmd_XSECT32;

				for ( let i = 0x40; i < 0x80; i++ ) {

					cmd[ i ] = cmd_LABEL;

				}

				for ( let i = 0x80; i < 0xc0; i++ ) {

					cmd[ i ] = cmd_LINE;

				}
				// dispatch table end

				readLabel = readLabelV7;

			}

			if ( version >= 4 && version <= 6 ) {

				cmd[ 0x20 ] = cmd_DATE_V4;
				cmd[ 0x21 ] = cmd_DATE2_V4;

			}

			// common record iterator
			// loop though data, handling record types as required.

			const batch = Math.round( dataLength / 10 );
			let c = 0;

			while ( pos < dataLength ) {

				if ( c++ == batch ) {

					c = 0;
					this.progress( Math.round( 25 * pos / dataLength ) + 75 );

				}

				if ( ! cmd[ data[ pos ] ]( data[ pos++ ] ) ) break;

			}

			// add last xSect group
			if ( xSects.length > 1 ) {

				xGroups.push( xSects );

			}

			const caveXgroups = cave.xGroups;

			xGroups.forEach( group => {
				if ( group.length > 1 ) caveXgroups.push( group );
			} );

			stationMap.forEach( coords => limits.expandByPoint( coords ) );

			groups.push( legs );

			return;

			function readLabelV7 () {
				// find length of label and read label = v3 - v7 .3d format

				let len = 0;

				switch ( data[ pos ] ) {

				case 0xfe:

					len = dataView.getUint16( pos, true ) + data[ pos ];
					pos += 2;

					break;

				case 0xff:

					len = dataView.getUint32( pos, true );
					pos += 4;

					break;

				default:

					len = data[ pos++ ];

				}

				if ( len === 0 ) return;

				label += String.fromCharCode.apply( null, data.subarray( pos, ( pos += len ) ) );

				labelChanged = true;

				if ( section !== null ) inSection = label.startsWith( section );

				return;

			}

			function readLabelV8 ( flags ) {

				if ( flags & 0x20 ) return; // no label change

				let b = data[ pos++ ];
				let add = 0;
				let del = 0;

				if ( b !== 0 ) {

					// handle 4b= bit del/add codes
					del = b >> 4; // left most 4 bits
					add = b & 0x0f; // right most 4 bits

				} else {

					// handle 8 bit and 32 bit del/add codes
					b = data[ pos++ ];

					if ( b !== 0xff ) {

						del = b;

					} else {

						del = dataView.getUint32( pos, true );
						pos += 4;

					}

					b = data[ pos++ ];

					if ( b !== 0xff ) {

						add = b;

					} else {

						add = dataView.getUint32( pos, true );
						pos += 4;

					}

				}

				if ( add === 0 && del === 0 ) return;

				if ( del ) label = label.slice( 0, -del );

				if ( add ) {

					label += String.fromCharCode.apply( null, data.subarray( pos, ( pos += add ) ) );

				}

				labelChanged = true;

				if ( section !== null ) inSection = label.startsWith( section );

				return;

			}

			function cmd_STOP ( /* c */ ) {

				if ( label ) label = '';

				return true;

			}

			function cmd_TRIM_PLUS ( c ) { // v7 and previous

				label = label.slice( 0, -16 );

				if ( label.charAt( label.length - 1 ) === '.' ) label = label.slice( 0, -1 ); // strip trailing '.'

				const parts = label.split( '.' );

				parts.splice( -( c ) );
				label = parts.join( '.' );

				if ( label ) label += '.';
				labelChanged = true;

				return true;

			}

			function cmd_TRIM ( c ) { // v7 and previous

				const trim = c - 15;

				label = label.slice( 0, -trim );
				labelChanged = true;

				return true;

			}

			function cmd_DATE_V4 ( /* c */ ) {

				pos += 4;

				return true;

			}

			function cmd_DATE_V7 ( /* c */ ) {

				pos += 2;

				return true;

			}

			function cmd_DATE3_V7 ( /* c */ ) {

				pos += 4;

				return true;

			}

			function cmd_DATE2_V4 ( /* c */ ) {

				pos += 8;

				return true;

			}

			function cmd_DATE2_V7 ( /* c */ ) {

				pos += 3;

				return true;

			}

			function cmd_STYLE ( /* c */ ) {

				return true;

			}

			function cmd_DATEV8_1 ( /* c */ ) {

				pos += 2;

				return true;

			}

			function cmd_DATEV8_2 ( /* c */ ) {

				pos += 3;

				return true;

			}

			function cmd_DATEV8_3 ( /* c */ ) {

				pos += 4;

				return true;
			}

			function cmd_DATE_NODATE ( /* c */ ) {

				return true;

			}

			function cmd_LINE ( c ) {

				const flags = c & 0x3f;

				readLabel( flags );

				if ( labelChanged ) {

					// if we have a new section name
					// add it to the survey tree

					sectionId = label === '' ? 0 : surveyTree.addPath( label ).id;
					labelChanged = false;

				}

				if ( inSection ) {

					// add start of run of legs
					if ( move ) {

						legs.push( { coords: lastPosition } );
						move = false;

					}

					const thisPosition = readCoordinates();

					if ( thisPosition === lastPosition ) return true;

					if ( ( flags & 0x07 ) === 0 ) {

						// reference count underground legs ignoring splay and surface legs
						// used for topology reconstruction

						lastPosition.connections++;
						thisPosition.connections++;

						legs.push( { coords: thisPosition, type: LEG_CAVE, survey: sectionId } );

					} else if ( flags & 0x04 ) {

						lastPosition.splays++;
						legs.push( { coords: thisPosition, type: LEG_SPLAY, survey: sectionId } );

						thisPosition.splays = -1;

					} else if ( flags & 0x01 ) {

						legs.push( { coords: thisPosition, type: LEG_SURFACE, survey: sectionId } );

					} else if ( flags & 0x02 ) {

						legs.push( { coords: thisPosition, type: LEG_DUPLICATE, survey: sectionId } );

					}

					lastPosition = thisPosition;

				} else {

					if ( move ) {

						// correct marking of last position moved to.
						dropLastCoordinates();
						move = false;

					}

					// skip coordinates
					pos += 12;

				}

				return true;

			}

			function cmd_MOVE ( /* c */ ) {

				// new set of line segments
				if ( legs.length > 1 ) groups.push( legs );

				legs = [];

				if ( ! inSection && move ) dropLastCoordinates();

				lastPosition = readCoordinates();

				move = true;

				return true;

			}

			function cmd_ERROR ( /* c */ ) {

				/*

				const l = new DataView( source, pos );

				const legs = l.getInt32( 0, true );
				const length = l.getInt32( 4, true );

				const E = l.getInt32( 8, true );
				const H = l.getInt32( 12, true );
				const V = l.getInt32( 16, true );

				*/

				pos += 20;

				return true;

			}

			function cmd_LABEL ( c ) {

				const flags = c & 0x7f;
				/*
				0x01	Station is on leg above ground
				0x02	Station is on an underground leg (both may be true at an entrance)
				0x04	Station is marked as an entrance (with *entrance)
				0x08	Station is exported (i.e. may be used as a connection point to other surveys)
				0x10	Station is a fixed point (control point)
				0x20	Station is anonymous
				0x40	Station is on the passage wall
				*/

				readLabel( 0 );

				if ( ( ! ( flags & 0x0E ) || flags & 0x20 ) || ! inSection ) { // skip surface only stations

					pos += 12; //skip coordinates
					return true;

				}

				const coords = readCoordinates();
				const path = label.split( '.' );
				const type = ( flags & 0x04 ) ? STATION_ENTRANCE : STATION_NORMAL;

				let useCoords = coords;

				if ( coords.parent !== null ) {

					useCoords = new StationPosition( coords.x, coords.y, coords.z );

					useCoords.type = type;

					coords.linkStation( useCoords );

					// add to station map to ensure correct offsetting in Handler.getSurvey()
					stationMap.set( {}, useCoords ); // use dummy object as map key

				} else {

					coords.type = type;

				}

				stations.set(
					label,
					surveyTree.addLeaf( path, useCoords )
				);

				return true;

			}

			function cmd_XSECT16 ( c ) {

				const flags = c & 0x01;

				readLabel( flags );

				const l = new DataView( source, pos );

				pos += 8;

				return commonXSECT(
					flags,
					{
						l: l.getInt16( 0, true ) / 100,
						r: l.getInt16( 2, true ) / 100,
						u: l.getInt16( 4, true ) / 100,
						d: l.getInt16( 6, true ) / 100
					}
				);

			}

			function cmd_XSECT32 ( c ) {

				const flags = c & 0x01;

				readLabel( flags );

				const l = new DataView( source, pos );

				pos += 16;

				return commonXSECT(
					flags,
					{
						l: l.getInt32( 0, true ) / 100,
						r: l.getInt32( 4, true ) / 100,
						u: l.getInt32( 8, true ) / 100,
						d: l.getInt32( 12, true ) / 100
					}
				);

			}

			function commonXSECT ( flags, lrud ) {

				if ( section !== null && ! label.startsWith( section ) ) return true;

				const node = stations.get( label );

				if ( ! node ) return true;

				const surveyId = node.parent.id;

				xSects.push( { start: lastXSectPosition, end: node, lrud: lrud, survey: surveyId, type: WALL_SQUARE } );

				// record which stations have associated LRUD coords
				node.type = node.type | STATION_XSECT;

				// some XSECTS are not flagged as last in passage
				// if a station has only one connection and is not the first in a set of XSECTS
				// it is at the end of a run of legs. Add a break to remove flyback artifacts

				let endRun = false;

				if ( flags ) {

					endRun = true;

				} else if ( node.connections === 1 && xSects.length > 1 && lastPosition.connections !== 0 ) {

					message = {
						station: node,
						text: 'LRUD fault'
					};

					if ( node.splays === 0 ) {

						endRun = true;
						messages.push( message );

					} else {

						// expecting next is a splay
						splayExpected = true;

					}

				} else if ( splayExpected && node.connections !== 0 ) {

					messages.push( message );

					splayExpected = false;

				}

				if ( endRun ) {

					if ( xSects.length > 0 ) xGroups.push( xSects );

					lastXSectPosition = null;
					xSects = [];
					splayExpected = false;

				} else {

					lastXSectPosition = node;

				}

				return true;

			}

			function readCoordinates () {

				const l = new DataView( source, pos );

				lastKey = String.fromCharCode.apply( null, data.subarray( pos, pos + 12 ) );

				let coords = new StationPosition(
					l.getInt32( 0, true ) / 100,
					l.getInt32( 4, true ) / 100,
					l.getInt32( 8, true ) / 100
				);

				pos += 12;

				const cachedCoords = stationMap.get( lastKey );

				if ( cachedCoords !== undefined ) {

					coords = cachedCoords;

				} else {

					if ( projection !== null ) {

						__coords.x = coords.x;
						__coords.y = coords.y;

						const projectedCoords = projection.forward( __coords );

						coords.x = projectedCoords.x;
						coords.y = projectedCoords.y;

					}

					stationMap.set( lastKey, coords );

				}

				return coords;

			}

			function dropLastCoordinates () {

				// don't drop coordinates we know are in the section being extracted
				if ( lastPosition.connections ) return;

				stationMap.delete( lastKey );

			}

		}

		getLineSegments () {

			const lineSegments = [];
			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i++ ) {

				const g = groups[ i ];

				for ( let v = 0, vMax = g.length - 1; v < vMax; v++ ) {

					// create vertex pairs for each line segment.
					// all vertices except first and last are duplicated.
					const from = g[ v ];
					const to   = g[ v + 1 ];

					const fromCoords = from.coords;
					const toCoords = to.coords;

					lineSegments.push( { from: fromCoords, to: toCoords, type: to.type, survey: to.survey } );

				}

			}

			return lineSegments;

		}

	}

	class loxHandler {

		static modelOffset = 0;

		type = 'arraybuffer';

		constructor ( fileName ) {

			this.fileName = fileName;
		}

		parse ( cave, source, metadata, section, progress ) {

			// assumes little endian data ATM - FIXME

			loxHandler.modelOffset += 100000;

			cave.metadata = metadata;

			cave.setCRS( null );

			const lineSegments = cave.lineSegments;
			const surveyTree   = cave.surveyTree;
			const limits       = cave.limits;
			const projection   = cave.projection;

			const xSects  = [];
			const terrain = {};

			const skipTerrain = ( projection !== null );
			const utf8Decoder = new TextDecoder( 'utf-8' );

			const l = source.byteLength;
			const idOffset = loxHandler.modelOffset;
			const stations = [];
			const shash = [];

			let pos = 0; // file position
			let dataStart;
			const f = new DataView( source, 0 );
			const bytes = new Uint8Array( source );

			let sectionId = 0;
			let lastParentId;
			let parentNode;

			// read file and parse chunk by chunk
			const __coords = {
				x: 0.0,
				y: 0.0
			};

			while ( pos < l ) readChunkHdr();

			// Drop data to give GC a chance ASAP

			source = null;

			cave.addStations( stations );

			cave.addXsects( xSects );

			return Promise.resolve( cave );

			// .lox parsing functions

			function readChunkHdr () {

				const m_type     = readUint();
				const m_recSize  = readUint();
				const m_recCount = readUint();
				const m_dataSize = readUint();

				let doFunction;

				// offset of data region for out of line strings/images/scrap data.
				dataStart = pos + m_recSize;

				switch ( m_type ) {

				case 1:

					doFunction = readSurvey;

					break;

				case 2:

					doFunction = readStation;

					break;

				case 3:

					doFunction = readShot;

					break;

				case 4:

					doFunction = readScrap;

					break;

				case 5:

					doFunction = readSurface;

					break;

				case 6:

					doFunction = readSurfaceBMP;

					break;

				default:

					throw new Error( 'unknown chunk header. type : ' + m_type );

				}

				for ( let i = 0; i < m_recCount; i++ ) doFunction();

				progress( Math.round( 25 * pos / l ) + 75 );

				pos += m_dataSize;

			}

			function readUint () {

				const i = f.getUint32( pos, true );

				pos += 4;

				return i;

			}

			function readFloat64 () {

				const i = f.getFloat64( pos, true );

				pos += 8;

				return i;

			}

			function readDataPtr () {

				const m_position = readUint();
				const m_size     = readUint();

				return { position: m_position, size: m_size };

			}

			function readString ( ptr ) {

				// strings are null terminated. Ignore last byte in string
				const bytes = new Uint8Array( source, dataStart + ptr.position, ptr.size - 1 );

				return utf8Decoder.decode( bytes );

			}

			function readSurvey () {

				const m_id     = readUint();
				const namePtr  = readDataPtr();
				const m_parent = readUint();
				const titlePtr = readDataPtr();

				if ( lastParentId !== m_parent ) {

					parentNode = surveyTree.findById( ( lastParentId === undefined ) ? 0 : m_parent + idOffset );
					lastParentId = m_parent;

					if ( parentNode === undefined ) parentNode = surveyTree;

				}

				if ( m_parent !== m_id ) {

					const node = parentNode.addById( readString( namePtr ), m_id + idOffset );

					if ( node === null ) throw new Error( 'error constructing survey tree for : ' + readString( titlePtr ) );

					if ( section !== null && node.getPath() === section ) {

						sectionId = m_id;

					}

				}

			}

			function readCoords ( m_flags ) {

				const lastKey = String.fromCharCode.apply( null, bytes.subarray( pos, pos + 24 ) );

				const oldcoords = shash[ lastKey ];

				const coords = new StationPosition(
					readFloat64(),
					readFloat64(),
					readFloat64()
				);

				coords.type = ( m_flags & 0x02 ) ? STATION_ENTRANCE : STATION_NORMAL;

				if ( oldcoords !== undefined ) {

					// mark as a duplicate
					oldcoords.linkStation( coords );

					// create zero length show to preserve topology
					lineSegments.push( { from: oldcoords, to: coords, type: LEG_CAVE, survey: oldcoords.parent.id } );

				} else {

					shash[ lastKey ] = coords;

				}

				if ( projection !== null ) {

					__coords.x = coords.x;
					__coords.y = coords.y;

					const projectedCoords = projection.forward( __coords );

					coords.x = projectedCoords.x;
					coords.y = projectedCoords.y;

				}

				limits.expandByPoint( coords );

				return coords;

			}

			function readStation () {

				const m_id       = readUint();
				const m_surveyId = readUint();
				const namePtr    = readDataPtr();
				const commentPtr = readDataPtr();

				const m_flags = readUint();
				const coords = readCoords( m_flags );

				stations[ m_id ] = coords;

				// add stations to surveyTree make station id negative to avoid clashes with survey id space.

				/*
				.lox station flags
				LXFILE_STATION_FLAG_SURFACE = 1,
				LXFILE_STATION_FLAG_ENTRANCE = 2,
				LXFILE_STATION_FLAG_FIXED = 4,
				LXFILE_STATION_FLAG_CONTINUATION = 8,
				LXFILE_STATION_FLAG_HAS_WALLS = 16,
				*/

				if ( lastParentId !== m_surveyId ) {

					parentNode = surveyTree.findById( m_surveyId + idOffset );
					lastParentId = m_surveyId;

				}

				const name = ( namePtr.size === 0 ) ? '[' + m_id + ']' : readString( namePtr );
				const comment = ( commentPtr.size > 0 ) ? readString( commentPtr ) : null;

				parentNode.addLeafById( name, - ( m_id + idOffset ), coords, comment );

			}

			function readShot () {

				const m_from_r = readUint();
				const m_to_r   = readUint();

				let m_from, m_to, fromLRUD, toLRUD;

				if ( m_to_r > m_from_r ) {

					m_from = m_from_r;
					m_to = m_to_r;
					fromLRUD = readLrudForward();
					toLRUD   = readLrudForward();

				} else {

					m_from = m_to_r;
					m_to = m_from_r;
					toLRUD   = readLrudReverse();
					fromLRUD = readLrudReverse();

				}

				const m_flags       = readUint();
				const m_sectionType = readUint();
				const m_surveyId    = readUint();

				pos += 8; // readFloat64(); // m_threshold

				if ( sectionId !== 0 && m_surveyId !== sectionId ) return;

				/*
				.lox shot flags
				LXFILE_SHOT_FLAG_SURFACE = 1,
				LXFILE_SHOT_FLAG_DUPLICATE = 2,
				LXFILE_SHOT_FLAG_NOT_VISIBLE = 4,
				LXFILE_SHOT_FLAG_NOT_LRUD = 8,
				LXFILE_SHOT_FLAG_SPLAY = 16,
				*/

				let type;

				if ( m_flags === 0 ) {

					type = LEG_CAVE;

				} else if ( m_flags & 0x08 || m_flags & 0x16 ) {

					type = LEG_SPLAY;

				} else if ( m_flags & 0x01 ) {

					type = LEG_SURFACE;

				} else if ( m_flags & 0x02 ) {

					type = LEG_DUPLICATE;

				} else {

					console.log( 'unexpected flags' + m_flags );
					return;

				}

				const from = stations[ m_from ];
				const to   = stations[ m_to ];

				/*
				.lox section types

				LXFILE_SHOT_SECTION_NONE 0
				LXFILE_SHOT_SECTION_OVAL 1
				LXFILE_SHOT_SECTION_SQUARE 2
				LXFILE_SHOT_SECTION_DIAMOND 3
				LXFILE_SHOT_SECTION_TUNNEL 4
				*/

				const surveyId = m_surveyId + idOffset;

				if ( m_sectionType !== 0x00 && type === LEG_CAVE ) {

					// record which stations have associated LRUD coords

					const node = surveyTree.findById( - m_to - idOffset );
					node.type = node.type | STATION_XSECT;

					xSects.push( { m_from: m_from, m_to: m_to, start: from, end: to, fromLRUD: fromLRUD, lrud: toLRUD, survey: surveyId, type: m_sectionType } );

				}

				if ( type === LEG_CAVE ) {

					from.connections++;
					to.connections++;

				}

				lineSegments.push( { from: from, to: to, type: type, survey: surveyId } );

			}

			function readLrudForward () {

				return {
					l: readFloat64(),
					r: readFloat64(),
					u: readFloat64(),
					d: readFloat64()
				};

			}

			function readLrudReverse () {

				return {
					r: readFloat64(),
					l: readFloat64(),
					u: readFloat64(),
					d: readFloat64()
				};

			}

			function readScrap () {

				readUint(); // m_id

				const m_surveyId   = readUint();

				const m_numPoints  = readUint();
				const pointsPtr    = readDataPtr();

				const m_num3Angles = readUint();
				const facesPtr     = readDataPtr();

				const scrap = { vertices: [], faces: [], survey: m_surveyId + idOffset };

				let lastFace;
				let i, j;

				if ( sectionId !== 0 && m_surveyId !== sectionId ) return;

				const vDV = new DataView( source, dataStart + pointsPtr.position );

				for ( i = 0; i < m_numPoints; i++ ) {

					const offset = i * 24; // 24 = 3 * sizeof( double )

					scrap.vertices.push( new Vector3(
						vDV.getFloat64( offset,      true ),
						vDV.getFloat64( offset + 8,  true ),
						vDV.getFloat64( offset + 16, true )
					) );

				}

				// read faces from out of line data area
				const fDV = new DataView( source, dataStart + facesPtr.position );

				for ( i = 0; i < m_num3Angles; i++ ) {

					const offset = i * 12; // 12 = 3 * sizeof( uint32 )

					const face = [
						fDV.getUint32( offset,     true ),
						fDV.getUint32( offset + 4, true ),
						fDV.getUint32( offset + 8, true )
					];

					if ( face[ 0 ] == face[ 1 ] || face[ 0 ] == face[ 2 ] || face[ 1 ] == face[ 2 ] ) {
						// some .lox files contain degenerate triangles
						continue;
					}

					// check for face winding order == orientation

					fix_direction: { if ( lastFace !== undefined ) {

						for ( j = 0; j < 3; j++ ) { // this case triggers more often than those below.

							if ( face[ j ] === lastFace[ ( j + 2 ) % 3 ] && face[ ( j + 1 ) % 3 ] === lastFace[ ( j + 3 ) % 3 ] ) {

								face.reverse();
								break fix_direction;

							}

						}

						for ( j = 0; j < 3; j++ ) {

							if ( face[ j ] === lastFace[ j ] && face[ ( j + 1 ) % 3 ] === lastFace[ ( j + 1 ) % 3 ] ) {

								face.reverse();
								break fix_direction;

							}

						}

						for ( j = 0; j < 3; j++ ) {

							if ( face[ j ] === lastFace[ ( j + 1 ) % 3 ] && face[ ( j + 1 ) % 3 ] === lastFace[ ( j + 2 ) % 3 ] ) {

								face.reverse();
								break fix_direction;

							}

						}

					} }

					scrap.faces.push( face );
					lastFace = face;

				}

				cave.scraps.push( scrap );

			}

			function readSurface () {

				readUint(); // m_id

				const m_width  = readUint();
				const m_height = readUint();

				const surfacePtr = readDataPtr();
				const m_calib    = readCalibration();

				if ( skipTerrain ) return;

				const ab = source.slice( pos, pos + surfacePtr.size ); // required for 64b alignment

				const dtm = new Float64Array( ab, 0 );

				terrain.dtm = {
					data: dtm,
					samples: m_width,
					lines:   m_height,
					calib:   m_calib
				};

				cave.terrains.push( terrain );
				cave.hasTerrain = true;

			}

			function readCalibration () {

				const xOrigin =	readFloat64(); // x origin
				const yOrigin =	readFloat64(); // y origin
				const xx = readFloat64(); // xx ( 2 x 2 ) rotate and scale matrix
				const xy = readFloat64(); // xy "
				const yx = readFloat64(); // yx "
				const yy = readFloat64(); // yy "

				return {
					xOrigin: xOrigin,
					yOrigin: yOrigin,
					xx: xx,
					xy: xy,
					yx: yx,
					yy: yy
				};

			}

			function readSurfaceBMP () {

				readUint(); // m_type
				readUint(); // m_surfaceId

				const imagePtr = readDataPtr();
				const m_calib = readCalibration();

				if ( skipTerrain ) return;

				terrain.bitmap = {
					image: extractImage( imagePtr ),
					calib: m_calib
				};

			}

			function extractImage ( imagePtr ) {

				const imgData = new Uint8Array( source, dataStart + imagePtr.position, imagePtr.size );

				const b1 = imgData[ 0 ];
				const b2 = imgData[ 1 ];

				let type;

				if ( b1 === 0xff && b2 === 0xd8 ) {

					type = 'image/jpeg';

				} else if ( b1 === 0x89 && b2 === 0x50 ) {

					type = 'image/png';

				} else {

					return '';

				}

				const blob = new Blob( [ imgData ], { type: type } );

				return URL.createObjectURL( blob );

			}

		}

	}

	const ftom = 12 * 0.0254;

	class pltHandler {

		constructor( fileName ) {

			this.fileName = fileName;
			this.type = 'text';

		}

		parse ( cave, dataStream, metadata /*, section */ ) {

			cave.metadata = metadata;

			cave.setCRS( null );

			const surveyTree  = cave.surveyTree;
			const limits      = cave.limits;
			const projection  = cave.projection;

			const stationMap  = new Map();
			const xSects      = [];
			const stations    = [];
			const groups      = [];

			const lines = dataStream.split( /[\n\r]+/ );
			const l = lines.length;

			let path = [];
			let segments = [];
			let stationName;
			let surveyName;
			let surveyId = 0;
			let lastStationIndex = -1;
			let section = 'root';
			let lrud, stationIndex, coords;

			for ( let i = 0; i < l; i++ ) {

				const parts = lines[ i ].split( /\s+/ );

				const cmd = parts[ 0 ].charAt( 0 );

				switch ( cmd ) {

				case 'M': // move

					if ( segments.length > 1 ) groups.push( segments );

					segments = [];
					lastStationIndex = -1;

				case 'D': // eslint-disable-line no-fallthrough

					stationName = parts[ 4 ].substring( 1 );

					path[ 2 ] = stationName;

					coords = readCoords( parts );
					coords.type = STATION_NORMAL;

					stationIndex = coords.stationIndex;

					segments.push( { coords: coords, type: LEG_CAVE, survey: surveyId } );

					if ( coords.connections === 0 ) {

						// parse comment
						const comment = ( parts[ 13 ] === undefined ) ? null : parts.slice( 13 ).join( ' ' );

						surveyTree.addLeaf( path, coords, comment );

					}

					coords.connections++;

					if ( parts[ 5 ] === 'P' ) {

						let l = +parts[ 6 ];
						let u = +parts[ 7 ];
						let d = +parts[ 8 ];
						let r = +parts[ 9 ];

						let nCount = 0;

						if ( l < 0 ) { l = 0; nCount++; }
						if ( u < 0 ) { u = 0; nCount++; }
						if ( d < 0 ) { d = 0; nCount++; }
						if ( r < 0 ) { r = 0; nCount++; }

						if ( nCount !== 4 ) {

							lrud = {
								l: l * ftom,
								u: u * ftom,
								d: d * ftom,
								r: r * ftom
							};

							const from = ( lastStationIndex !== -1 ) ? stations[ lastStationIndex ] : null;

							xSects.push( { m_from: lastStationIndex, m_to: stationIndex, start: from, end: coords, lrud: lrud, survey: surveyId, type: 2  } );

						}

						lastStationIndex = stationIndex;

					}

					break;

				case 'N': // line survey

					surveyName = parts[ 0 ].substring( 1 );

					path = [ section, surveyName ];
					surveyId = surveyTree.addPath( section + '.' + surveyName ).id;

					break;

				case 'Z': // end of survey

					/*
					limits.min.set(
						+parts[ 3 ],
						+parts[ 1 ],
						+parts[ 5 ]
					);

					limits.max.set(
						+parts[ 4 ],
						+parts[ 2 ],
						+parts[ 6 ]
					);
					*/

					break;

				case 'F': // feature survey
				case 'L': // feature location
				case 'X': // end of survey
				case 'O': // Datum
				case 'G': // UTM Zone
				case 'P': // fixed point
				case 'R': // loop spec
				case 'C': // loop count
				case '\x1A': // end of file

					break;

				case 'S':

					section = lines[ i ].substring( 1 );
					break;

				default:

					console.log( 'unknown command ', cmd );

				}

			}

			if ( segments.length > 1 ) groups.push( segments );

			cave.addStations( stations );

			cave.addLineSegments( groups );

			cave.addXsects( xSects );

			return Promise.resolve( cave );

			function readCoords( parts ) {

				const lastKey = parts[ 1 ] + ':' + parts[ 2 ] + ':' + parts[ 3 ];
				const cachedCoords = stationMap.get( lastKey );

				let coords;

				if ( cachedCoords !== undefined ) {

					coords = cachedCoords;

				} else {

					coords = new StationPosition(
						+parts[ 2 ] * ftom,
						+parts[ 1 ] * ftom,
						+parts[ 3 ] * ftom
					);

					if ( projection !== null ) {

						const projectedCoords = projection.forward( {
							x: coords.x,
							y: coords.y
						} );

						coords.x = projectedCoords.x;
						coords.y = projectedCoords.y;

					}

					coords.stationIndex = stations.length;

					stations.push( coords );
					stationMap.set( lastKey, coords );

					limits.expandByPoint( coords );

				}

				return coords;

			}

		}

	}

	function globals(defs) {
	  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
	  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
	  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

	  defs.WGS84 = defs['EPSG:4326'];
	  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
	  defs.GOOGLE = defs['EPSG:3857'];
	  defs['EPSG:900913'] = defs['EPSG:3857'];
	  defs['EPSG:102113'] = defs['EPSG:3857'];
	}

	var PJD_3PARAM = 1;
	var PJD_7PARAM = 2;
	var PJD_GRIDSHIFT = 3;
	var PJD_WGS84 = 4; // WGS84 or equivalent
	var PJD_NODATUM = 5; // WGS84 or equivalent
	var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
	var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
	var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
	var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
	var HALF_PI = Math.PI/2;
	// ellipoid pj_set_ell.c
	var SIXTH = 0.1666666666666666667;
	/* 1/6 */
	var RA4 = 0.04722222222222222222;
	/* 17/360 */
	var RA6 = 0.02215608465608465608;
	var EPSLN = 1.0e-10;
	// you'd think you could use Number.EPSILON above but that makes
	// Mollweide get into an infinate loop.

	var D2R$1 = 0.01745329251994329577;
	var R2D = 57.29577951308232088;
	var FORTPI = Math.PI/4;
	var TWO_PI = Math.PI * 2;
	// SPI is slightly greater than Math.PI, so values that exceed the -180..180
	// degree range by a tiny amount don't get wrapped. This prevents points that
	// have drifted from their original location along the 180th meridian (due to
	// floating point error) from changing their sign.
	var SPI = 3.14159265359;

	var exports$4 = {};

	exports$4.greenwich = 0.0; //"0dE",
	exports$4.lisbon = -9.131906111111; //"9d07'54.862\"W",
	exports$4.paris = 2.337229166667; //"2d20'14.025\"E",
	exports$4.bogota = -74.080916666667; //"74d04'51.3\"W",
	exports$4.madrid = -3.687938888889; //"3d41'16.58\"W",
	exports$4.rome = 12.452333333333; //"12d27'8.4\"E",
	exports$4.bern = 7.439583333333; //"7d26'22.5\"E",
	exports$4.jakarta = 106.807719444444; //"106d48'27.79\"E",
	exports$4.ferro = -17.666666666667; //"17d40'W",
	exports$4.brussels = 4.367975; //"4d22'4.71\"E",
	exports$4.stockholm = 18.058277777778; //"18d3'29.8\"E",
	exports$4.athens = 23.7163375; //"23d42'58.815\"E",
	exports$4.oslo = 10.722916666667; //"10d43'22.5\"E"

	var units = {
	  ft: {to_meter: 0.3048},
	  'us-ft': {to_meter: 1200 / 3937}
	};

	var ignoredChar = /[\s_\-\/\(\)]/g;
	function match(obj, key) {
	  if (obj[key]) {
	    return obj[key];
	  }
	  var keys = Object.keys(obj);
	  var lkey = key.toLowerCase().replace(ignoredChar, '');
	  var i = -1;
	  var testkey, processedKey;
	  while (++i < keys.length) {
	    testkey = keys[i];
	    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
	    if (processedKey === lkey) {
	      return obj[testkey];
	    }
	  }
	}

	function projStr(defData) {
	  var self = {};
	  var paramObj = defData.split('+').map(function(v) {
	    return v.trim();
	  }).filter(function(a) {
	    return a;
	  }).reduce(function(p, a) {
	    var split = a.split('=');
	    split.push(true);
	    p[split[0].toLowerCase()] = split[1];
	    return p;
	  }, {});
	  var paramName, paramVal, paramOutname;
	  var params = {
	    proj: 'projName',
	    datum: 'datumCode',
	    rf: function(v) {
	      self.rf = parseFloat(v);
	    },
	    lat_0: function(v) {
	      self.lat0 = v * D2R$1;
	    },
	    lat_1: function(v) {
	      self.lat1 = v * D2R$1;
	    },
	    lat_2: function(v) {
	      self.lat2 = v * D2R$1;
	    },
	    lat_ts: function(v) {
	      self.lat_ts = v * D2R$1;
	    },
	    lon_0: function(v) {
	      self.long0 = v * D2R$1;
	    },
	    lon_1: function(v) {
	      self.long1 = v * D2R$1;
	    },
	    lon_2: function(v) {
	      self.long2 = v * D2R$1;
	    },
	    alpha: function(v) {
	      self.alpha = parseFloat(v) * D2R$1;
	    },
	    gamma: function(v) {
	      self.rectified_grid_angle = parseFloat(v);
	    },
	    lonc: function(v) {
	      self.longc = v * D2R$1;
	    },
	    x_0: function(v) {
	      self.x0 = parseFloat(v);
	    },
	    y_0: function(v) {
	      self.y0 = parseFloat(v);
	    },
	    k_0: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    k: function(v) {
	      self.k0 = parseFloat(v);
	    },
	    a: function(v) {
	      self.a = parseFloat(v);
	    },
	    b: function(v) {
	      self.b = parseFloat(v);
	    },
	    r_a: function() {
	      self.R_A = true;
	    },
	    zone: function(v) {
	      self.zone = parseInt(v, 10);
	    },
	    south: function() {
	      self.utmSouth = true;
	    },
	    towgs84: function(v) {
	      self.datum_params = v.split(",").map(function(a) {
	        return parseFloat(a);
	      });
	    },
	    to_meter: function(v) {
	      self.to_meter = parseFloat(v);
	    },
	    units: function(v) {
	      self.units = v;
	      var unit = match(units, v);
	      if (unit) {
	        self.to_meter = unit.to_meter;
	      }
	    },
	    from_greenwich: function(v) {
	      self.from_greenwich = v * D2R$1;
	    },
	    pm: function(v) {
	      var pm = match(exports$4, v);
	      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R$1;
	    },
	    nadgrids: function(v) {
	      if (v === '@null') {
	        self.datumCode = 'none';
	      }
	      else {
	        self.nadgrids = v;
	      }
	    },
	    axis: function(v) {
	      var legalAxis = "ewnsud";
	      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
	        self.axis = v;
	      }
	    },
	    approx: function() {
	      self.approx = true;
	    }
	  };
	  for (paramName in paramObj) {
	    paramVal = paramObj[paramName];
	    if (paramName in params) {
	      paramOutname = params[paramName];
	      if (typeof paramOutname === 'function') {
	        paramOutname(paramVal);
	      }
	      else {
	        self[paramOutname] = paramVal;
	      }
	    }
	    else {
	      self[paramName] = paramVal;
	    }
	  }
	  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
	    self.datumCode = self.datumCode.toLowerCase();
	  }
	  return self;
	}

	var NEUTRAL = 1;
	var KEYWORD = 2;
	var NUMBER = 3;
	var QUOTED = 4;
	var AFTERQUOTE = 5;
	var ENDED = -1;
	var whitespace = /\s/;
	var latin = /[A-Za-z]/;
	var keyword = /[A-Za-z84_]/;
	var endThings = /[,\]]/;
	var digets = /[\d\.E\-\+]/;
	// const ignoredChar = /[\s_\-\/\(\)]/g;
	function Parser(text) {
	  if (typeof text !== 'string') {
	    throw new Error('not a string');
	  }
	  this.text = text.trim();
	  this.level = 0;
	  this.place = 0;
	  this.root = null;
	  this.stack = [];
	  this.currentObject = null;
	  this.state = NEUTRAL;
	}
	Parser.prototype.readCharicter = function() {
	  var char = this.text[this.place++];
	  if (this.state !== QUOTED) {
	    while (whitespace.test(char)) {
	      if (this.place >= this.text.length) {
	        return;
	      }
	      char = this.text[this.place++];
	    }
	  }
	  switch (this.state) {
	    case NEUTRAL:
	      return this.neutral(char);
	    case KEYWORD:
	      return this.keyword(char)
	    case QUOTED:
	      return this.quoted(char);
	    case AFTERQUOTE:
	      return this.afterquote(char);
	    case NUMBER:
	      return this.number(char);
	    case ENDED:
	      return;
	  }
	};
	Parser.prototype.afterquote = function(char) {
	  if (char === '"') {
	    this.word += '"';
	    this.state = QUOTED;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.word = this.word.trim();
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
	};
	Parser.prototype.afterItem = function(char) {
	  if (char === ',') {
	    if (this.word !== null) {
	      this.currentObject.push(this.word);
	    }
	    this.word = null;
	    this.state = NEUTRAL;
	    return;
	  }
	  if (char === ']') {
	    this.level--;
	    if (this.word !== null) {
	      this.currentObject.push(this.word);
	      this.word = null;
	    }
	    this.state = NEUTRAL;
	    this.currentObject = this.stack.pop();
	    if (!this.currentObject) {
	      this.state = ENDED;
	    }

	    return;
	  }
	};
	Parser.prototype.number = function(char) {
	  if (digets.test(char)) {
	    this.word += char;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.word = parseFloat(this.word);
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
	};
	Parser.prototype.quoted = function(char) {
	  if (char === '"') {
	    this.state = AFTERQUOTE;
	    return;
	  }
	  this.word += char;
	  return;
	};
	Parser.prototype.keyword = function(char) {
	  if (keyword.test(char)) {
	    this.word += char;
	    return;
	  }
	  if (char === '[') {
	    var newObjects = [];
	    newObjects.push(this.word);
	    this.level++;
	    if (this.root === null) {
	      this.root = newObjects;
	    } else {
	      this.currentObject.push(newObjects);
	    }
	    this.stack.push(this.currentObject);
	    this.currentObject = newObjects;
	    this.state = NEUTRAL;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
	};
	Parser.prototype.neutral = function(char) {
	  if (latin.test(char)) {
	    this.word = char;
	    this.state = KEYWORD;
	    return;
	  }
	  if (char === '"') {
	    this.word = '';
	    this.state = QUOTED;
	    return;
	  }
	  if (digets.test(char)) {
	    this.word = char;
	    this.state = NUMBER;
	    return;
	  }
	  if (endThings.test(char)) {
	    this.afterItem(char);
	    return;
	  }
	  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
	};
	Parser.prototype.output = function() {
	  while (this.place < this.text.length) {
	    this.readCharicter();
	  }
	  if (this.state === ENDED) {
	    return this.root;
	  }
	  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
	};

	function parseString(txt) {
	  var parser = new Parser(txt);
	  return parser.output();
	}

	function mapit(obj, key, value) {
	  if (Array.isArray(key)) {
	    value.unshift(key);
	    key = null;
	  }
	  var thing = key ? {} : obj;

	  var out = value.reduce(function(newObj, item) {
	    sExpr(item, newObj);
	    return newObj
	  }, thing);
	  if (key) {
	    obj[key] = out;
	  }
	}

	function sExpr(v, obj) {
	  if (!Array.isArray(v)) {
	    obj[v] = true;
	    return;
	  }
	  var key = v.shift();
	  if (key === 'PARAMETER') {
	    key = v.shift();
	  }
	  if (v.length === 1) {
	    if (Array.isArray(v[0])) {
	      obj[key] = {};
	      sExpr(v[0], obj[key]);
	      return;
	    }
	    obj[key] = v[0];
	    return;
	  }
	  if (!v.length) {
	    obj[key] = true;
	    return;
	  }
	  if (key === 'TOWGS84') {
	    obj[key] = v;
	    return;
	  }
	  if (key === 'AXIS') {
	    if (!(key in obj)) {
	      obj[key] = [];
	    }
	    obj[key].push(v);
	    return;
	  }
	  if (!Array.isArray(key)) {
	    obj[key] = {};
	  }

	  var i;
	  switch (key) {
	    case 'UNIT':
	    case 'PRIMEM':
	    case 'VERT_DATUM':
	      obj[key] = {
	        name: v[0].toLowerCase(),
	        convert: v[1]
	      };
	      if (v.length === 3) {
	        sExpr(v[2], obj[key]);
	      }
	      return;
	    case 'SPHEROID':
	    case 'ELLIPSOID':
	      obj[key] = {
	        name: v[0],
	        a: v[1],
	        rf: v[2]
	      };
	      if (v.length === 4) {
	        sExpr(v[3], obj[key]);
	      }
	      return;
	    case 'PROJECTEDCRS':
	    case 'PROJCRS':
	    case 'GEOGCS':
	    case 'GEOCCS':
	    case 'PROJCS':
	    case 'LOCAL_CS':
	    case 'GEODCRS':
	    case 'GEODETICCRS':
	    case 'GEODETICDATUM':
	    case 'EDATUM':
	    case 'ENGINEERINGDATUM':
	    case 'VERT_CS':
	    case 'VERTCRS':
	    case 'VERTICALCRS':
	    case 'COMPD_CS':
	    case 'COMPOUNDCRS':
	    case 'ENGINEERINGCRS':
	    case 'ENGCRS':
	    case 'FITTED_CS':
	    case 'LOCAL_DATUM':
	    case 'DATUM':
	      v[0] = ['name', v[0]];
	      mapit(obj, key, v);
	      return;
	    default:
	      i = -1;
	      while (++i < v.length) {
	        if (!Array.isArray(v[i])) {
	          return sExpr(v, obj[key]);
	        }
	      }
	      return mapit(obj, key, v);
	  }
	}

	var D2R = 0.01745329251994329577;



	function rename(obj, params) {
	  var outName = params[0];
	  var inName = params[1];
	  if (!(outName in obj) && (inName in obj)) {
	    obj[outName] = obj[inName];
	    if (params.length === 3) {
	      obj[outName] = params[2](obj[outName]);
	    }
	  }
	}

	function d2r(input) {
	  return input * D2R;
	}

	function cleanWKT(wkt) {
	  if (wkt.type === 'GEOGCS') {
	    wkt.projName = 'longlat';
	  } else if (wkt.type === 'LOCAL_CS') {
	    wkt.projName = 'identity';
	    wkt.local = true;
	  } else {
	    if (typeof wkt.PROJECTION === 'object') {
	      wkt.projName = Object.keys(wkt.PROJECTION)[0];
	    } else {
	      wkt.projName = wkt.PROJECTION;
	    }
	  }
	  if (wkt.AXIS) {
	    var axisOrder = '';
	    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
	      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
	      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
	        axisOrder += 'n';
	      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
	        axisOrder += 's';
	      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
	        axisOrder += 'e';
	      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
	        axisOrder += 'w';
	      }
	    }
	    if (axisOrder.length === 2) {
	      axisOrder += 'u';
	    }
	    if (axisOrder.length === 3) {
	      wkt.axis = axisOrder;
	    }
	  }
	  if (wkt.UNIT) {
	    wkt.units = wkt.UNIT.name.toLowerCase();
	    if (wkt.units === 'metre') {
	      wkt.units = 'meter';
	    }
	    if (wkt.UNIT.convert) {
	      if (wkt.type === 'GEOGCS') {
	        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
	          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
	        }
	      } else {
	        wkt.to_meter = wkt.UNIT.convert;
	      }
	    }
	  }
	  var geogcs = wkt.GEOGCS;
	  if (wkt.type === 'GEOGCS') {
	    geogcs = wkt;
	  }
	  if (geogcs) {
	    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
	    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
	    //}
	    if (geogcs.DATUM) {
	      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
	    } else {
	      wkt.datumCode = geogcs.name.toLowerCase();
	    }
	    if (wkt.datumCode.slice(0, 2) === 'd_') {
	      wkt.datumCode = wkt.datumCode.slice(2);
	    }
	    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
	      wkt.datumCode = 'nzgd49';
	    }
	    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
	      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
	        wkt.sphere = true;
	      }
	      wkt.datumCode = 'wgs84';
	    }
	    if (wkt.datumCode.slice(-6) === '_ferro') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 6);
	    }
	    if (wkt.datumCode.slice(-8) === '_jakarta') {
	      wkt.datumCode = wkt.datumCode.slice(0, - 8);
	    }
	    if (~wkt.datumCode.indexOf('belge')) {
	      wkt.datumCode = 'rnb72';
	    }
	    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
	      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
	      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
	        wkt.ellps = 'intl';
	      }

	      wkt.a = geogcs.DATUM.SPHEROID.a;
	      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
	    }

	    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
	      wkt.datum_params = geogcs.DATUM.TOWGS84;
	    }
	    if (~wkt.datumCode.indexOf('osgb_1936')) {
	      wkt.datumCode = 'osgb36';
	    }
	    if (~wkt.datumCode.indexOf('osni_1952')) {
	      wkt.datumCode = 'osni52';
	    }
	    if (~wkt.datumCode.indexOf('tm65')
	      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
	      wkt.datumCode = 'ire65';
	    }
	    if (wkt.datumCode === 'ch1903+') {
	      wkt.datumCode = 'ch1903';
	    }
	    if (~wkt.datumCode.indexOf('israel')) {
	      wkt.datumCode = 'isr93';
	    }
	  }
	  if (wkt.b && !isFinite(wkt.b)) {
	    wkt.b = wkt.a;
	  }

	  function toMeter(input) {
	    var ratio = wkt.to_meter || 1;
	    return input * ratio;
	  }
	  var renamer = function(a) {
	    return rename(wkt, a);
	  };
	  var list = [
	    ['standard_parallel_1', 'Standard_Parallel_1'],
	    ['standard_parallel_1', 'Latitude of 1st standard parallel'],
	    ['standard_parallel_2', 'Standard_Parallel_2'],
	    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
	    ['false_easting', 'False_Easting'],
	    ['false_easting', 'False easting'],
	    ['false-easting', 'Easting at false origin'],
	    ['false_northing', 'False_Northing'],
	    ['false_northing', 'False northing'],
	    ['false_northing', 'Northing at false origin'],
	    ['central_meridian', 'Central_Meridian'],
	    ['central_meridian', 'Longitude of natural origin'],
	    ['central_meridian', 'Longitude of false origin'],
	    ['latitude_of_origin', 'Latitude_Of_Origin'],
	    ['latitude_of_origin', 'Central_Parallel'],
	    ['latitude_of_origin', 'Latitude of natural origin'],
	    ['latitude_of_origin', 'Latitude of false origin'],
	    ['scale_factor', 'Scale_Factor'],
	    ['k0', 'scale_factor'],
	    ['latitude_of_center', 'Latitude_Of_Center'],
	    ['latitude_of_center', 'Latitude_of_center'],
	    ['lat0', 'latitude_of_center', d2r],
	    ['longitude_of_center', 'Longitude_Of_Center'],
	    ['longitude_of_center', 'Longitude_of_center'],
	    ['longc', 'longitude_of_center', d2r],
	    ['x0', 'false_easting', toMeter],
	    ['y0', 'false_northing', toMeter],
	    ['long0', 'central_meridian', d2r],
	    ['lat0', 'latitude_of_origin', d2r],
	    ['lat0', 'standard_parallel_1', d2r],
	    ['lat1', 'standard_parallel_1', d2r],
	    ['lat2', 'standard_parallel_2', d2r],
	    ['azimuth', 'Azimuth'],
	    ['alpha', 'azimuth', d2r],
	    ['srsCode', 'name']
	  ];
	  list.forEach(renamer);
	  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
	    wkt.long0 = wkt.longc;
	  }
	  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
	    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
	    wkt.lat_ts = wkt.lat1;
	  }
	}
	function wkt(wkt) {
	  var lisp = parseString(wkt);
	  var type = lisp.shift();
	  var name = lisp.shift();
	  lisp.unshift(['name', name]);
	  lisp.unshift(['type', type]);
	  var obj = {};
	  sExpr(lisp, obj);
	  cleanWKT(obj);
	  return obj;
	}

	function defs(name) {
	  /*global console*/
	  var that = this;
	  if (arguments.length === 2) {
	    var def = arguments[1];
	    if (typeof def === 'string') {
	      if (def.charAt(0) === '+') {
	        defs[name] = projStr(arguments[1]);
	      }
	      else {
	        defs[name] = wkt(arguments[1]);
	      }
	    } else {
	      defs[name] = def;
	    }
	  }
	  else if (arguments.length === 1) {
	    if (Array.isArray(name)) {
	      return name.map(function(v) {
	        if (Array.isArray(v)) {
	          defs.apply(that, v);
	        }
	        else {
	          defs(v);
	        }
	      });
	    }
	    else if (typeof name === 'string') {
	      if (name in defs) {
	        return defs[name];
	      }
	    }
	    else if ('EPSG' in name) {
	      defs['EPSG:' + name.EPSG] = name;
	    }
	    else if ('ESRI' in name) {
	      defs['ESRI:' + name.ESRI] = name;
	    }
	    else if ('IAU2000' in name) {
	      defs['IAU2000:' + name.IAU2000] = name;
	    }
	    else {
	      console.log(name);
	    }
	    return;
	  }


	}
	globals(defs);

	function testObj(code){
	  return typeof code === 'string';
	}
	function testDef(code){
	  return code in defs;
	}
	var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
	function testWKT(code){
	  return codeWords.some(function (word) {
	    return code.indexOf(word) > -1;
	  });
	}
	var codes = ['3857', '900913', '3785', '102113'];
	function checkMercator(item) {
	  var auth = match(item, 'authority');
	  if (!auth) {
	    return;
	  }
	  var code = match(auth, 'epsg');
	  return code && codes.indexOf(code) > -1;
	}
	function checkProjStr(item) {
	  var ext = match(item, 'extension');
	  if (!ext) {
	    return;
	  }
	  return match(ext, 'proj4');
	}
	function testProj(code){
	  return code[0] === '+';
	}
	function parse(code){
	  if (testObj(code)) {
	    //check to see if this is a WKT string
	    if (testDef(code)) {
	      return defs[code];
	    }
	    if (testWKT(code)) {
	      var out = wkt(code);
	      // test of spetial case, due to this being a very common and often malformed
	      if (checkMercator(out)) {
	        return defs['EPSG:3857'];
	      }
	      var maybeProjStr = checkProjStr(out);
	      if (maybeProjStr) {
	        return projStr(maybeProjStr);
	      }
	      return out;
	    }
	    if (testProj(code)) {
	      return projStr(code);
	    }
	  }else {
	    return code;
	  }
	}

	function extend(destination, source) {
	  destination = destination || {};
	  var value, property;
	  if (!source) {
	    return destination;
	  }
	  for (property in source) {
	    value = source[property];
	    if (value !== undefined) {
	      destination[property] = value;
	    }
	  }
	  return destination;
	}

	function msfnz(eccent, sinphi, cosphi) {
	  var con = eccent * sinphi;
	  return cosphi / (Math.sqrt(1 - con * con));
	}

	function sign(x) {
	  return x<0 ? -1 : 1;
	}

	function adjust_lon(x) {
	  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
	}

	function tsfnz(eccent, phi, sinphi) {
	  var con = eccent * sinphi;
	  var com = 0.5 * eccent;
	  con = Math.pow(((1 - con) / (1 + con)), com);
	  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
	}

	function phi2z(eccent, ts) {
	  var eccnth = 0.5 * eccent;
	  var con, dphi;
	  var phi = HALF_PI - 2 * Math.atan(ts);
	  for (var i = 0; i <= 15; i++) {
	    con = eccent * Math.sin(phi);
	    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }
	  //console.log("phi2z has NoConvergence");
	  return -9999;
	}

	function init$v() {
	  var con = this.b / this.a;
	  this.es = 1 - con * con;
	  if(!('x0' in this)){
	    this.x0 = 0;
	  }
	  if(!('y0' in this)){
	    this.y0 = 0;
	  }
	  this.e = Math.sqrt(this.es);
	  if (this.lat_ts) {
	    if (this.sphere) {
	      this.k0 = Math.cos(this.lat_ts);
	    }
	    else {
	      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	    }
	  }
	  else {
	    if (!this.k0) {
	      if (this.k) {
	        this.k0 = this.k;
	      }
	      else {
	        this.k0 = 1;
	      }
	    }
	  }
	}

	/* Mercator forward equations--mapping lat,long to x,y
	  --------------------------------------------------*/

	function forward$u(p) {
	  var lon = p.x;
	  var lat = p.y;
	  // convert to radians
	  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
	    return null;
	  }

	  var x, y;
	  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
	    return null;
	  }
	  else {
	    if (this.sphere) {
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
	    }
	    else {
	      var sinphi = Math.sin(lat);
	      var ts = tsfnz(this.e, lat, sinphi);
	      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
	      y = this.y0 - this.a * this.k0 * Math.log(ts);
	    }
	    p.x = x;
	    p.y = y;
	    return p;
	  }
	}

	/* Mercator inverse equations--mapping x,y to lat/long
	  --------------------------------------------------*/
	function inverse$u(p) {

	  var x = p.x - this.x0;
	  var y = p.y - this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
	  }
	  else {
	    var ts = Math.exp(-y / (this.a * this.k0));
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$w = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
	var merc = {
	  init: init$v,
	  forward: forward$u,
	  inverse: inverse$u,
	  names: names$w
	};

	function init$u() {
	  //no-op for longlat
	}

	function identity(pt) {
	  return pt;
	}
	var names$v = ["longlat", "identity"];
	var longlat = {
	  init: init$u,
	  forward: identity,
	  inverse: identity,
	  names: names$v
	};

	var projs = [merc, longlat];
	var names$u = {};
	var projStore = [];

	function add(proj, i) {
	  var len = projStore.length;
	  if (!proj.names) {
	    console.log(i);
	    return true;
	  }
	  projStore[len] = proj;
	  proj.names.forEach(function(n) {
	    names$u[n.toLowerCase()] = len;
	  });
	  return this;
	}

	function get(name) {
	  if (!name) {
	    return false;
	  }
	  var n = name.toLowerCase();
	  if (typeof names$u[n] !== 'undefined' && projStore[names$u[n]]) {
	    return projStore[names$u[n]];
	  }
	}

	function start() {
	  projs.forEach(add);
	}
	var projections = {
	  start: start,
	  add: add,
	  get: get
	};

	var exports$3 = {};
	exports$3.MERIT = {
	  a: 6378137.0,
	  rf: 298.257,
	  ellipseName: "MERIT 1983"
	};

	exports$3.SGS85 = {
	  a: 6378136.0,
	  rf: 298.257,
	  ellipseName: "Soviet Geodetic System 85"
	};

	exports$3.GRS80 = {
	  a: 6378137.0,
	  rf: 298.257222101,
	  ellipseName: "GRS 1980(IUGG, 1980)"
	};

	exports$3.IAU76 = {
	  a: 6378140.0,
	  rf: 298.257,
	  ellipseName: "IAU 1976"
	};

	exports$3.airy = {
	  a: 6377563.396,
	  b: 6356256.910,
	  ellipseName: "Airy 1830"
	};

	exports$3.APL4 = {
	  a: 6378137,
	  rf: 298.25,
	  ellipseName: "Appl. Physics. 1965"
	};

	exports$3.NWL9D = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "Naval Weapons Lab., 1965"
	};

	exports$3.mod_airy = {
	  a: 6377340.189,
	  b: 6356034.446,
	  ellipseName: "Modified Airy"
	};

	exports$3.andrae = {
	  a: 6377104.43,
	  rf: 300.0,
	  ellipseName: "Andrae 1876 (Den., Iclnd.)"
	};

	exports$3.aust_SA = {
	  a: 6378160.0,
	  rf: 298.25,
	  ellipseName: "Australian Natl & S. Amer. 1969"
	};

	exports$3.GRS67 = {
	  a: 6378160.0,
	  rf: 298.2471674270,
	  ellipseName: "GRS 67(IUGG 1967)"
	};

	exports$3.bessel = {
	  a: 6377397.155,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841"
	};

	exports$3.bess_nam = {
	  a: 6377483.865,
	  rf: 299.1528128,
	  ellipseName: "Bessel 1841 (Namibia)"
	};

	exports$3.clrk66 = {
	  a: 6378206.4,
	  b: 6356583.8,
	  ellipseName: "Clarke 1866"
	};

	exports$3.clrk80 = {
	  a: 6378249.145,
	  rf: 293.4663,
	  ellipseName: "Clarke 1880 mod."
	};

	exports$3.clrk58 = {
	  a: 6378293.645208759,
	  rf: 294.2606763692654,
	  ellipseName: "Clarke 1858"
	};

	exports$3.CPM = {
	  a: 6375738.7,
	  rf: 334.29,
	  ellipseName: "Comm. des Poids et Mesures 1799"
	};

	exports$3.delmbr = {
	  a: 6376428.0,
	  rf: 311.5,
	  ellipseName: "Delambre 1810 (Belgium)"
	};

	exports$3.engelis = {
	  a: 6378136.05,
	  rf: 298.2566,
	  ellipseName: "Engelis 1985"
	};

	exports$3.evrst30 = {
	  a: 6377276.345,
	  rf: 300.8017,
	  ellipseName: "Everest 1830"
	};

	exports$3.evrst48 = {
	  a: 6377304.063,
	  rf: 300.8017,
	  ellipseName: "Everest 1948"
	};

	exports$3.evrst56 = {
	  a: 6377301.243,
	  rf: 300.8017,
	  ellipseName: "Everest 1956"
	};

	exports$3.evrst69 = {
	  a: 6377295.664,
	  rf: 300.8017,
	  ellipseName: "Everest 1969"
	};

	exports$3.evrstSS = {
	  a: 6377298.556,
	  rf: 300.8017,
	  ellipseName: "Everest (Sabah & Sarawak)"
	};

	exports$3.fschr60 = {
	  a: 6378166.0,
	  rf: 298.3,
	  ellipseName: "Fischer (Mercury Datum) 1960"
	};

	exports$3.fschr60m = {
	  a: 6378155.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1960"
	};

	exports$3.fschr68 = {
	  a: 6378150.0,
	  rf: 298.3,
	  ellipseName: "Fischer 1968"
	};

	exports$3.helmert = {
	  a: 6378200.0,
	  rf: 298.3,
	  ellipseName: "Helmert 1906"
	};

	exports$3.hough = {
	  a: 6378270.0,
	  rf: 297.0,
	  ellipseName: "Hough"
	};

	exports$3.intl = {
	  a: 6378388.0,
	  rf: 297.0,
	  ellipseName: "International 1909 (Hayford)"
	};

	exports$3.kaula = {
	  a: 6378163.0,
	  rf: 298.24,
	  ellipseName: "Kaula 1961"
	};

	exports$3.lerch = {
	  a: 6378139.0,
	  rf: 298.257,
	  ellipseName: "Lerch 1979"
	};

	exports$3.mprts = {
	  a: 6397300.0,
	  rf: 191.0,
	  ellipseName: "Maupertius 1738"
	};

	exports$3.new_intl = {
	  a: 6378157.5,
	  b: 6356772.2,
	  ellipseName: "New International 1967"
	};

	exports$3.plessis = {
	  a: 6376523.0,
	  rf: 6355863.0,
	  ellipseName: "Plessis 1817 (France)"
	};

	exports$3.krass = {
	  a: 6378245.0,
	  rf: 298.3,
	  ellipseName: "Krassovsky, 1942"
	};

	exports$3.SEasia = {
	  a: 6378155.0,
	  b: 6356773.3205,
	  ellipseName: "Southeast Asia"
	};

	exports$3.walbeck = {
	  a: 6376896.0,
	  b: 6355834.8467,
	  ellipseName: "Walbeck"
	};

	exports$3.WGS60 = {
	  a: 6378165.0,
	  rf: 298.3,
	  ellipseName: "WGS 60"
	};

	exports$3.WGS66 = {
	  a: 6378145.0,
	  rf: 298.25,
	  ellipseName: "WGS 66"
	};

	exports$3.WGS7 = {
	  a: 6378135.0,
	  rf: 298.26,
	  ellipseName: "WGS 72"
	};

	var WGS84 = exports$3.WGS84 = {
	  a: 6378137.0,
	  rf: 298.257223563,
	  ellipseName: "WGS 84"
	};

	exports$3.sphere = {
	  a: 6370997.0,
	  b: 6370997.0,
	  ellipseName: "Normal Sphere (r=6370997)"
	};

	function eccentricity(a, b, rf, R_A) {
	  var a2 = a * a; // used in geocentric
	  var b2 = b * b; // used in geocentric
	  var es = (a2 - b2) / a2; // e ^ 2
	  var e = 0;
	  if (R_A) {
	    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
	    a2 = a * a;
	    es = 0;
	  } else {
	    e = Math.sqrt(es); // eccentricity
	  }
	  var ep2 = (a2 - b2) / b2; // used in geocentric
	  return {
	    es: es,
	    e: e,
	    ep2: ep2
	  };
	}
	function sphere(a, b, rf, ellps, sphere) {
	  if (!a) { // do we have an ellipsoid?
	    var ellipse = match(exports$3, ellps);
	    if (!ellipse) {
	      ellipse = WGS84;
	    }
	    a = ellipse.a;
	    b = ellipse.b;
	    rf = ellipse.rf;
	  }

	  if (rf && !b) {
	    b = (1.0 - 1.0 / rf) * a;
	  }
	  if (rf === 0 || Math.abs(a - b) < EPSLN) {
	    sphere = true;
	    b = a;
	  }
	  return {
	    a: a,
	    b: b,
	    rf: rf,
	    sphere: sphere
	  };
	}

	var exports$2 = {};
	exports$2.wgs84 = {
	  towgs84: "0,0,0",
	  ellipse: "WGS84",
	  datumName: "WGS84"
	};

	exports$2.ch1903 = {
	  towgs84: "674.374,15.056,405.346",
	  ellipse: "bessel",
	  datumName: "swiss"
	};

	exports$2.ggrs87 = {
	  towgs84: "-199.87,74.79,246.62",
	  ellipse: "GRS80",
	  datumName: "Greek_Geodetic_Reference_System_1987"
	};

	exports$2.nad83 = {
	  towgs84: "0,0,0",
	  ellipse: "GRS80",
	  datumName: "North_American_Datum_1983"
	};

	exports$2.nad27 = {
	  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
	  ellipse: "clrk66",
	  datumName: "North_American_Datum_1927"
	};

	exports$2.potsdam = {
	  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
	  ellipse: "bessel",
	  datumName: "Potsdam Rauenberg 1950 DHDN"
	};

	exports$2.carthage = {
	  towgs84: "-263.0,6.0,431.0",
	  ellipse: "clark80",
	  datumName: "Carthage 1934 Tunisia"
	};

	exports$2.hermannskogel = {
	  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
	  ellipse: "bessel",
	  datumName: "Hermannskogel"
	};

	exports$2.osni52 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "airy",
	  datumName: "Irish National"
	};

	exports$2.ire65 = {
	  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
	  ellipse: "mod_airy",
	  datumName: "Ireland 1965"
	};

	exports$2.rassadiran = {
	  towgs84: "-133.63,-157.5,-158.62",
	  ellipse: "intl",
	  datumName: "Rassadiran"
	};

	exports$2.nzgd49 = {
	  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
	  ellipse: "intl",
	  datumName: "New Zealand Geodetic Datum 1949"
	};

	exports$2.osgb36 = {
	  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
	  ellipse: "airy",
	  datumName: "Airy 1830"
	};

	exports$2.s_jtsk = {
	  towgs84: "589,76,480",
	  ellipse: 'bessel',
	  datumName: 'S-JTSK (Ferro)'
	};

	exports$2.beduaram = {
	  towgs84: '-106,-87,188',
	  ellipse: 'clrk80',
	  datumName: 'Beduaram'
	};

	exports$2.gunung_segara = {
	  towgs84: '-403,684,41',
	  ellipse: 'bessel',
	  datumName: 'Gunung Segara Jakarta'
	};

	exports$2.rnb72 = {
	  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
	  ellipse: "intl",
	  datumName: "Reseau National Belge 1972"
	};

	function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
	  var out = {};

	  if (datumCode === undefined || datumCode === 'none') {
	    out.datum_type = PJD_NODATUM;
	  } else {
	    out.datum_type = PJD_WGS84;
	  }

	  if (datum_params) {
	    out.datum_params = datum_params.map(parseFloat);
	    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
	      out.datum_type = PJD_3PARAM;
	    }
	    if (out.datum_params.length > 3) {
	      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
	        out.datum_type = PJD_7PARAM;
	        out.datum_params[3] *= SEC_TO_RAD;
	        out.datum_params[4] *= SEC_TO_RAD;
	        out.datum_params[5] *= SEC_TO_RAD;
	        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
	      }
	    }
	  }

	  if (nadgrids) {
	    out.datum_type = PJD_GRIDSHIFT;
	    out.grids = nadgrids;
	  }
	  out.a = a; //datum object also uses these values
	  out.b = b;
	  out.es = es;
	  out.ep2 = ep2;
	  return out;
	}

	/**
	 * Resources for details of NTv2 file formats:
	 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
	 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
	 */

	var loadedNadgrids = {};

	/**
	 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
	 * as an ArrayBuffer.
	 */
	function nadgrid(key, data) {
	  var view = new DataView(data);
	  var isLittleEndian = detectLittleEndian(view);
	  var header = readHeader(view, isLittleEndian);
	  if (header.nSubgrids > 1) {
	    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
	  }
	  var subgrids = readSubgrids(view, header, isLittleEndian);
	  var nadgrid = {header: header, subgrids: subgrids};
	  loadedNadgrids[key] = nadgrid;
	  return nadgrid;
	}

	/**
	 * Given a proj4 value for nadgrids, return an array of loaded grids
	 */
	function getNadgrids(nadgrids) {
	  // Format details: http://proj.maptools.org/gen_parms.html
	  if (nadgrids === undefined) { return null; }
	  var grids = nadgrids.split(',');
	  return grids.map(parseNadgridString);
	}

	function parseNadgridString(value) {
	  if (value.length === 0) {
	    return null;
	  }
	  var optional = value[0] === '@';
	  if (optional) {
	    value = value.slice(1);
	  }
	  if (value === 'null') {
	    return {name: 'null', mandatory: !optional, grid: null, isNull: true};
	  }
	  return {
	    name: value,
	    mandatory: !optional,
	    grid: loadedNadgrids[value] || null,
	    isNull: false
	  };
	}

	function secondsToRadians(seconds) {
	  return (seconds / 3600) * Math.PI / 180;
	}

	function detectLittleEndian(view) {
	  var nFields = view.getInt32(8, false);
	  if (nFields === 11) {
	    return false;
	  }
	  nFields = view.getInt32(8, true);
	  if (nFields !== 11) {
	    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
	  }
	  return true;
	}

	function readHeader(view, isLittleEndian) {
	  return {
	    nFields: view.getInt32(8, isLittleEndian),
	    nSubgridFields: view.getInt32(24, isLittleEndian),
	    nSubgrids: view.getInt32(40, isLittleEndian),
	    shiftType: decodeString(view, 56, 56 + 8).trim(),
	    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
	    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
	    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
	    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
	  };
	}

	function decodeString(view, start, end) {
	  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
	}

	function readSubgrids(view, header, isLittleEndian) {
	  var gridOffset = 176;
	  var grids = [];
	  for (var i = 0; i < header.nSubgrids; i++) {
	    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
	    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
	    var lngColumnCount = Math.round(
	      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
	    var latColumnCount = Math.round(
	      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
	    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
	    grids.push({
	      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
	      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
	      lim: [lngColumnCount, latColumnCount],
	      count: subHeader.gridNodeCount,
	      cvs: mapNodes(nodes)
	    });
	  }
	  return grids;
	}

	function mapNodes(nodes) {
	  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
	}

	function readGridHeader(view, offset, isLittleEndian) {
	  return {
	    name: decodeString(view, offset + 8, offset + 16).trim(),
	    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
	    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
	    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
	    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
	    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
	    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
	    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
	    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
	  };
	}

	function readGridNodes(view, offset, gridHeader, isLittleEndian) {
	  var nodesOffset = offset + 176;
	  var gridRecordLength = 16;
	  var gridShiftRecords = [];
	  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
	    var record = {
	      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
	      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
	      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
	      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
	    };
	    gridShiftRecords.push(record);
	  }
	  return gridShiftRecords;
	}

	function Projection(srsCode,callback) {
	  if (!(this instanceof Projection)) {
	    return new Projection(srsCode);
	  }
	  callback = callback || function(error){
	    if(error){
	      throw error;
	    }
	  };
	  var json = parse(srsCode);
	  if(typeof json !== 'object'){
	    callback(srsCode);
	    return;
	  }
	  var ourProj = Projection.projections.get(json.projName);
	  if(!ourProj){
	    callback(srsCode);
	    return;
	  }
	  if (json.datumCode && json.datumCode !== 'none') {
	    var datumDef = match(exports$2, json.datumCode);
	    if (datumDef) {
	      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
	      json.ellps = datumDef.ellipse;
	      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
	    }
	  }
	  json.k0 = json.k0 || 1.0;
	  json.axis = json.axis || 'enu';
	  json.ellps = json.ellps || 'wgs84';
	  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

	  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
	  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
	  var nadgrids = getNadgrids(json.nadgrids);
	  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
	    nadgrids);

	  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
	  extend(this, ourProj); // transfer all the methods from the projection

	  // copy the 4 things over we calculated in deriveConstants.sphere
	  this.a = sphere_.a;
	  this.b = sphere_.b;
	  this.rf = sphere_.rf;
	  this.sphere = sphere_.sphere;

	  // copy the 3 things we calculated in deriveConstants.eccentricity
	  this.es = ecc.es;
	  this.e = ecc.e;
	  this.ep2 = ecc.ep2;

	  // add in the datum object
	  this.datum = datumObj;

	  // init the projection
	  this.init();

	  // legecy callback from back in the day when it went to spatialreference.org
	  callback(null, this);

	}
	Projection.projections = projections;
	Projection.projections.start();

	function compareDatums(source, dest) {
	  if (source.datum_type !== dest.datum_type) {
	    return false; // false, datums are not equal
	  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
	    // the tolerance for es is to ensure that GRS80 and WGS84
	    // are considered identical
	    return false;
	  } else if (source.datum_type === PJD_3PARAM) {
	    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
	  } else if (source.datum_type === PJD_7PARAM) {
	    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
	  } else {
	    return true; // datums are equal
	  }
	} // cs_compare_datums()

	/*
	 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
	 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
	 * according to the current ellipsoid parameters.
	 *
	 *    Latitude  : Geodetic latitude in radians                     (input)
	 *    Longitude : Geodetic longitude in radians                    (input)
	 *    Height    : Geodetic height, in meters                       (input)
	 *    X         : Calculated Geocentric X coordinate, in meters    (output)
	 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
	 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
	 *
	 */
	function geodeticToGeocentric(p, es, a) {
	  var Longitude = p.x;
	  var Latitude = p.y;
	  var Height = p.z ? p.z : 0; //Z value not always supplied

	  var Rn; /*  Earth radius at location  */
	  var Sin_Lat; /*  Math.sin(Latitude)  */
	  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
	  var Cos_Lat; /*  Math.cos(Latitude)  */

	  /*
	   ** Don't blow up if Latitude is just a little out of the value
	   ** range as it may just be a rounding issue.  Also removed longitude
	   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
	   */
	  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
	    Latitude = -HALF_PI;
	  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
	    Latitude = HALF_PI;
	  } else if (Latitude < -HALF_PI) {
	    /* Latitude out of range */
	    //..reportError('geocent:lat out of range:' + Latitude);
	    return { x: -Infinity, y: -Infinity, z: p.z };
	  } else if (Latitude > HALF_PI) {
	    /* Latitude out of range */
	    return { x: Infinity, y: Infinity, z: p.z };
	  }

	  if (Longitude > Math.PI) {
	    Longitude -= (2 * Math.PI);
	  }
	  Sin_Lat = Math.sin(Latitude);
	  Cos_Lat = Math.cos(Latitude);
	  Sin2_Lat = Sin_Lat * Sin_Lat;
	  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
	  return {
	    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
	    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
	    z: ((Rn * (1 - es)) + Height) * Sin_Lat
	  };
	} // cs_geodetic_to_geocentric()

	function geocentricToGeodetic(p, es, a, b) {
	  /* local defintions and variables */
	  /* end-criterium of loop, accuracy of sin(Latitude) */
	  var genau = 1e-12;
	  var genau2 = (genau * genau);
	  var maxiter = 30;

	  var P; /* distance between semi-minor axis and location */
	  var RR; /* distance between center and location */
	  var CT; /* sin of geocentric latitude */
	  var ST; /* cos of geocentric latitude */
	  var RX;
	  var RK;
	  var RN; /* Earth radius at location */
	  var CPHI0; /* cos of start or old geodetic latitude in iterations */
	  var SPHI0; /* sin of start or old geodetic latitude in iterations */
	  var CPHI; /* cos of searched geodetic latitude */
	  var SPHI; /* sin of searched geodetic latitude */
	  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
	  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

	  var X = p.x;
	  var Y = p.y;
	  var Z = p.z ? p.z : 0.0; //Z value not always supplied
	  var Longitude;
	  var Latitude;
	  var Height;

	  P = Math.sqrt(X * X + Y * Y);
	  RR = Math.sqrt(X * X + Y * Y + Z * Z);

	  /*      special cases for latitude and longitude */
	  if (P / a < genau) {

	    /*  special case, if P=0. (X=0., Y=0.) */
	    Longitude = 0.0;

	    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
	     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
	    if (RR / a < genau) {
	      Latitude = HALF_PI;
	      Height = -b;
	      return {
	        x: p.x,
	        y: p.y,
	        z: p.z
	      };
	    }
	  } else {
	    /*  ellipsoidal (geodetic) longitude
	     *  interval: -PI < Longitude <= +PI */
	    Longitude = Math.atan2(Y, X);
	  }

	  /* --------------------------------------------------------------
	   * Following iterative algorithm was developped by
	   * "Institut for Erdmessung", University of Hannover, July 1988.
	   * Internet: www.ife.uni-hannover.de
	   * Iterative computation of CPHI,SPHI and Height.
	   * Iteration of CPHI and SPHI to 10**-12 radian resp.
	   * 2*10**-7 arcsec.
	   * --------------------------------------------------------------
	   */
	  CT = Z / RR;
	  ST = P / RR;
	  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
	  CPHI0 = ST * (1.0 - es) * RX;
	  SPHI0 = CT * RX;
	  iter = 0;

	  /* loop to find sin(Latitude) resp. Latitude
	   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
	  do {
	    iter++;
	    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

	    /*  ellipsoidal (geodetic) height */
	    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

	    RK = es * RN / (RN + Height);
	    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
	    CPHI = ST * (1.0 - RK) * RX;
	    SPHI = CT * RX;
	    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
	    CPHI0 = CPHI;
	    SPHI0 = SPHI;
	  }
	  while (SDPHI * SDPHI > genau2 && iter < maxiter);

	  /*      ellipsoidal (geodetic) latitude */
	  Latitude = Math.atan(SPHI / Math.abs(CPHI));
	  return {
	    x: Longitude,
	    y: Latitude,
	    z: Height
	  };
	} // cs_geocentric_to_geodetic()

	/****************************************************************/
	// pj_geocentic_to_wgs84( p )
	//  p = point to transform in geocentric coordinates (x,y,z)


	/** point object, nothing fancy, just allows values to be
	    passed back and forth by reference rather than by value.
	    Other point classes may be used as long as they have
	    x and y properties, which will get modified in the transform method.
	*/
	function geocentricToWgs84(p, datum_type, datum_params) {

	  if (datum_type === PJD_3PARAM) {
	    // if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: p.x + datum_params[0],
	      y: p.y + datum_params[1],
	      z: p.z + datum_params[2],
	    };
	  } else if (datum_type === PJD_7PARAM) {
	    var Dx_BF = datum_params[0];
	    var Dy_BF = datum_params[1];
	    var Dz_BF = datum_params[2];
	    var Rx_BF = datum_params[3];
	    var Ry_BF = datum_params[4];
	    var Rz_BF = datum_params[5];
	    var M_BF = datum_params[6];
	    // if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
	      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
	      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
	    };
	  }
	} // cs_geocentric_to_wgs84

	/****************************************************************/
	// pj_geocentic_from_wgs84()
	//  coordinate system definition,
	//  point to transform in geocentric coordinates (x,y,z)
	function geocentricFromWgs84(p, datum_type, datum_params) {

	  if (datum_type === PJD_3PARAM) {
	    //if( x[io] === HUGE_VAL )
	    //    continue;
	    return {
	      x: p.x - datum_params[0],
	      y: p.y - datum_params[1],
	      z: p.z - datum_params[2],
	    };

	  } else if (datum_type === PJD_7PARAM) {
	    var Dx_BF = datum_params[0];
	    var Dy_BF = datum_params[1];
	    var Dz_BF = datum_params[2];
	    var Rx_BF = datum_params[3];
	    var Ry_BF = datum_params[4];
	    var Rz_BF = datum_params[5];
	    var M_BF = datum_params[6];
	    var x_tmp = (p.x - Dx_BF) / M_BF;
	    var y_tmp = (p.y - Dy_BF) / M_BF;
	    var z_tmp = (p.z - Dz_BF) / M_BF;
	    //if( x[io] === HUGE_VAL )
	    //    continue;

	    return {
	      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
	      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
	      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
	    };
	  } //cs_geocentric_from_wgs84()
	}

	function checkParams(type) {
	  return (type === PJD_3PARAM || type === PJD_7PARAM);
	}

	function datum_transform(source, dest, point) {
	  // Short cut if the datums are identical.
	  if (compareDatums(source, dest)) {
	    return point; // in this case, zero is sucess,
	    // whereas cs_compare_datums returns 1 to indicate TRUE
	    // confusing, should fix this
	  }

	  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
	  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
	    return point;
	  }

	  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	  var source_a = source.a;
	  var source_es = source.es;
	  if (source.datum_type === PJD_GRIDSHIFT) {
	    var gridShiftCode = applyGridShift(source, false, point);
	    if (gridShiftCode !== 0) {
	      return undefined;
	    }
	    source_a = SRS_WGS84_SEMIMAJOR;
	    source_es = SRS_WGS84_ESQUARED;
	  }

	  var dest_a = dest.a;
	  var dest_b = dest.b;
	  var dest_es = dest.es;
	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    dest_a = SRS_WGS84_SEMIMAJOR;
	    dest_b = SRS_WGS84_SEMIMINOR;
	    dest_es = SRS_WGS84_ESQUARED;
	  }

	  // Do we need to go through geocentric coordinates?
	  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
	    return point;
	  }

	  // Convert to geocentric coordinates.
	  point = geodeticToGeocentric(point, source_es, source_a);
	  // Convert between datums
	  if (checkParams(source.datum_type)) {
	    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
	  }
	  if (checkParams(dest.datum_type)) {
	    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
	  }
	  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

	  if (dest.datum_type === PJD_GRIDSHIFT) {
	    var destGridShiftResult = applyGridShift(dest, true, point);
	    if (destGridShiftResult !== 0) {
	      return undefined;
	    }
	  }

	  return point;
	}

	function applyGridShift(source, inverse, point) {
	  if (source.grids === null || source.grids.length === 0) {
	    console.log('Grid shift grids not found');
	    return -1;
	  }
	  var input = {x: -point.x, y: point.y};
	  var output = {x: Number.NaN, y: Number.NaN};
	  var attemptedGrids = [];
	  for (var i = 0; i < source.grids.length; i++) {
	    var grid = source.grids[i];
	    attemptedGrids.push(grid.name);
	    if (grid.isNull) {
	      output = input;
	      break;
	    }
	    grid.mandatory;
	    if (grid.grid === null) {
	      if (grid.mandatory) {
	        console.log("Unable to find mandatory grid '" + grid.name + "'");
	        return -1;
	      }
	      continue;
	    }
	    var subgrid = grid.grid.subgrids[0];
	    // skip tables that don't match our point at all
	    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
	    var minX = subgrid.ll[0] - epsilon;
	    var minY = subgrid.ll[1] - epsilon;
	    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
	    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
	    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
	      continue;
	    }
	    output = applySubgridShift(input, inverse, subgrid);
	    if (!isNaN(output.x)) {
	      break;
	    }
	  }
	  if (isNaN(output.x)) {
	    console.log("Failed to find a grid shift table for location '"+
	      -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
	    return -1;
	  }
	  point.x = -output.x;
	  point.y = output.y;
	  return 0;
	}

	function applySubgridShift(pin, inverse, ct) {
	  var val = {x: Number.NaN, y: Number.NaN};
	  if (isNaN(pin.x)) { return val; }
	  var tb = {x: pin.x, y: pin.y};
	  tb.x -= ct.ll[0];
	  tb.y -= ct.ll[1];
	  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
	  var t = nadInterpolate(tb, ct);
	  if (inverse) {
	    if (isNaN(t.x)) {
	      return val;
	    }
	    t.x = tb.x - t.x;
	    t.y = tb.y - t.y;
	    var i = 9, tol = 1e-12;
	    var dif, del;
	    do {
	      del = nadInterpolate(t, ct);
	      if (isNaN(del.x)) {
	        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
	        break;
	      }
	      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
	      t.x += dif.x;
	      t.y += dif.y;
	    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
	    if (i < 0) {
	      console.log("Inverse grid shift iterator failed to converge.");
	      return val;
	    }
	    val.x = adjust_lon(t.x + ct.ll[0]);
	    val.y = t.y + ct.ll[1];
	  } else {
	    if (!isNaN(t.x)) {
	      val.x = pin.x + t.x;
	      val.y = pin.y + t.y;
	    }
	  }
	  return val;
	}

	function nadInterpolate(pin, ct) {
	  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
	  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
	  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
	  var val= {x: Number.NaN, y: Number.NaN};
	  var inx;
	  if (indx.x < 0 || indx.x >= ct.lim[0]) {
	    return val;
	  }
	  if (indx.y < 0 || indx.y >= ct.lim[1]) {
	    return val;
	  }
	  inx = (indx.y * ct.lim[0]) + indx.x;
	  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx++;
	  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx += ct.lim[0];
	  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  inx--;
	  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
	  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
	    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
	  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
	  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
	  return val;
	}

	function adjust_axis(crs, denorm, point) {
	  var xin = point.x,
	    yin = point.y,
	    zin = point.z || 0.0;
	  var v, t, i;
	  var out = {};
	  for (i = 0; i < 3; i++) {
	    if (denorm && i === 2 && point.z === undefined) {
	      continue;
	    }
	    if (i === 0) {
	      v = xin;
	      if ("ew".indexOf(crs.axis[i]) !== -1) {
	        t = 'x';
	      } else {
	        t = 'y';
	      }

	    }
	    else if (i === 1) {
	      v = yin;
	      if ("ns".indexOf(crs.axis[i]) !== -1) {
	        t = 'y';
	      } else {
	        t = 'x';
	      }
	    }
	    else {
	      v = zin;
	      t = 'z';
	    }
	    switch (crs.axis[i]) {
	    case 'e':
	      out[t] = v;
	      break;
	    case 'w':
	      out[t] = -v;
	      break;
	    case 'n':
	      out[t] = v;
	      break;
	    case 's':
	      out[t] = -v;
	      break;
	    case 'u':
	      if (point[t] !== undefined) {
	        out.z = v;
	      }
	      break;
	    case 'd':
	      if (point[t] !== undefined) {
	        out.z = -v;
	      }
	      break;
	    default:
	      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
	      return null;
	    }
	  }
	  return out;
	}

	function common (array){
	  var out = {
	    x: array[0],
	    y: array[1]
	  };
	  if (array.length>2) {
	    out.z = array[2];
	  }
	  if (array.length>3) {
	    out.m = array[3];
	  }
	  return out;
	}

	function checkSanity (point) {
	  checkCoord(point.x);
	  checkCoord(point.y);
	}
	function checkCoord(num) {
	  if (typeof Number.isFinite === 'function') {
	    if (Number.isFinite(num)) {
	      return;
	    }
	    throw new TypeError('coordinates must be finite numbers');
	  }
	  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
	    throw new TypeError('coordinates must be finite numbers');
	  }
	}

	function checkNotWGS(source, dest) {
	  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
	}

	function transform(source, dest, point, enforceAxis) {
	  var wgs84;
	  if (Array.isArray(point)) {
	    point = common(point);
	  }
	  checkSanity(point);
	  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
	  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
	    wgs84 = new Projection('WGS84');
	    point = transform(source, wgs84, point, enforceAxis);
	    source = wgs84;
	  }
	  // DGR, 2010/11/12
	  if (enforceAxis && source.axis !== 'enu') {
	    point = adjust_axis(source, false, point);
	  }
	  // Transform source points to long/lat, if they aren't already.
	  if (source.projName === 'longlat') {
	    point = {
	      x: point.x * D2R$1,
	      y: point.y * D2R$1,
	      z: point.z || 0
	    };
	  } else {
	    if (source.to_meter) {
	      point = {
	        x: point.x * source.to_meter,
	        y: point.y * source.to_meter,
	        z: point.z || 0
	      };
	    }
	    point = source.inverse(point); // Convert Cartesian to longlat
	    if (!point) {
	      return;
	    }
	  }
	  // Adjust for the prime meridian if necessary
	  if (source.from_greenwich) {
	    point.x += source.from_greenwich;
	  }

	  // Convert datums if needed, and if possible.
	  point = datum_transform(source.datum, dest.datum, point);
	  if (!point) {
	    return;
	  }

	  // Adjust for the prime meridian if necessary
	  if (dest.from_greenwich) {
	    point = {
	      x: point.x - dest.from_greenwich,
	      y: point.y,
	      z: point.z || 0
	    };
	  }

	  if (dest.projName === 'longlat') {
	    // convert radians to decimal degrees
	    point = {
	      x: point.x * R2D,
	      y: point.y * R2D,
	      z: point.z || 0
	    };
	  } else { // else project
	    point = dest.forward(point);
	    if (dest.to_meter) {
	      point = {
	        x: point.x / dest.to_meter,
	        y: point.y / dest.to_meter,
	        z: point.z || 0
	      };
	    }
	  }

	  // DGR, 2010/11/12
	  if (enforceAxis && dest.axis !== 'enu') {
	    return adjust_axis(dest, true, point);
	  }

	  return point;
	}

	var wgs84 = Projection('WGS84');

	function transformer(from, to, coords, enforceAxis) {
	  var transformedArray, out, keys;
	  if (Array.isArray(coords)) {
	    transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
	    if (coords.length > 2) {
	      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	        if (typeof transformedArray.z === 'number') {
	          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
	        } else {
	          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
	        }
	      } else {
	        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
	      }
	    } else {
	      return [transformedArray.x, transformedArray.y];
	    }
	  } else {
	    out = transform(from, to, coords, enforceAxis);
	    keys = Object.keys(coords);
	    if (keys.length === 2) {
	      return out;
	    }
	    keys.forEach(function (key) {
	      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
	        if (key === 'x' || key === 'y' || key === 'z') {
	          return;
	        }
	      } else {
	        if (key === 'x' || key === 'y') {
	          return;
	        }
	      }
	      out[key] = coords[key];
	    });
	    return out;
	  }
	}

	function checkProj(item) {
	  if (item instanceof Projection) {
	    return item;
	  }
	  if (item.oProj) {
	    return item.oProj;
	  }
	  return Projection(item);
	}

	function proj4(fromProj, toProj, coord) {
	  fromProj = checkProj(fromProj);
	  var single = false;
	  var obj;
	  if (typeof toProj === 'undefined') {
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
	    coord = toProj;
	    toProj = fromProj;
	    fromProj = wgs84;
	    single = true;
	  }
	  toProj = checkProj(toProj);
	  if (coord) {
	    return transformer(fromProj, toProj, coord);
	  } else {
	    obj = {
	      forward: function (coords, enforceAxis) {
	        return transformer(fromProj, toProj, coords, enforceAxis);
	      },
	      inverse: function (coords, enforceAxis) {
	        return transformer(toProj, fromProj, coords, enforceAxis);
	      }
	    };
	    if (single) {
	      obj.oProj = toProj;
	    }
	    return obj;
	  }
	}

	/**
	 * UTM zones are grouped, and assigned to one of a group of 6
	 * sets.
	 *
	 * {int} @private
	 */
	var NUM_100K_SETS = 6;

	/**
	 * The column letters (for easting) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

	/**
	 * The row letters (for northing) of the lower left value, per
	 * set.
	 *
	 * {string} @private
	 */
	var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

	var A = 65; // A
	var I = 73; // I
	var O = 79; // O
	var V = 86; // V
	var Z = 90; // Z
	var mgrs = {
	  forward: forward$t,
	  inverse: inverse$t,
	  toPoint: toPoint
	};
	/**
	 * Conversion of lat/lon to MGRS.
	 *
	 * @param {object} ll Object literal with lat and lon properties on a
	 *     WGS84 ellipsoid.
	 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
	 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
	 * @return {string} the MGRS string for the given location and accuracy.
	 */
	function forward$t(ll, accuracy) {
	  accuracy = accuracy || 5; // default accuracy 1m
	  return encode(LLtoUTM({
	    lat: ll[1],
	    lon: ll[0]
	  }), accuracy);
	}
	/**
	 * Conversion of MGRS to lat/lon.
	 *
	 * @param {string} mgrs MGRS string.
	 * @return {array} An array with left (longitude), bottom (latitude), right
	 *     (longitude) and top (latitude) values in WGS84, representing the
	 *     bounding box for the provided MGRS reference.
	 */
	function inverse$t(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
	  }
	  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
	}
	function toPoint(mgrs) {
	  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
	  if (bbox.lat && bbox.lon) {
	    return [bbox.lon, bbox.lat];
	  }
	  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
	}/**
	 * Conversion from degrees to radians.
	 *
	 * @private
	 * @param {number} deg the angle in degrees.
	 * @return {number} the angle in radians.
	 */
	function degToRad(deg) {
	  return (deg * (Math.PI / 180.0));
	}

	/**
	 * Conversion from radians to degrees.
	 *
	 * @private
	 * @param {number} rad the angle in radians.
	 * @return {number} the angle in degrees.
	 */
	function radToDeg(rad) {
	  return (180.0 * (rad / Math.PI));
	}

	/**
	 * Converts a set of Longitude and Latitude co-ordinates to UTM
	 * using the WGS84 ellipsoid.
	 *
	 * @private
	 * @param {object} ll Object literal with lat and lon properties
	 *     representing the WGS84 coordinate to be converted.
	 * @return {object} Object literal containing the UTM value with easting,
	 *     northing, zoneNumber and zoneLetter properties, and an optional
	 *     accuracy property in digits. Returns null if the conversion failed.
	 */
	function LLtoUTM(ll) {
	  var Lat = ll.lat;
	  var Long = ll.lon;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var k0 = 0.9996;
	  var LongOrigin;
	  var eccPrimeSquared;
	  var N, T, C, A, M;
	  var LatRad = degToRad(Lat);
	  var LongRad = degToRad(Long);
	  var LongOriginRad;
	  var ZoneNumber;
	  // (int)
	  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

	  //Make sure the longitude 180.00 is in Zone 60
	  if (Long === 180) {
	    ZoneNumber = 60;
	  }

	  // Special zone for Norway
	  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
	    ZoneNumber = 32;
	  }

	  // Special zones for Svalbard
	  if (Lat >= 72.0 && Lat < 84.0) {
	    if (Long >= 0.0 && Long < 9.0) {
	      ZoneNumber = 31;
	    }
	    else if (Long >= 9.0 && Long < 21.0) {
	      ZoneNumber = 33;
	    }
	    else if (Long >= 21.0 && Long < 33.0) {
	      ZoneNumber = 35;
	    }
	    else if (Long >= 33.0 && Long < 42.0) {
	      ZoneNumber = 37;
	    }
	  }

	  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
	  // in middle of
	  // zone
	  LongOriginRad = degToRad(LongOrigin);

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
	  T = Math.tan(LatRad) * Math.tan(LatRad);
	  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
	  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

	  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

	  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

	  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
	  if (Lat < 0.0) {
	    UTMNorthing += 10000000.0; //10000000 meter offset for
	    // southern hemisphere
	  }

	  return {
	    northing: Math.round(UTMNorthing),
	    easting: Math.round(UTMEasting),
	    zoneNumber: ZoneNumber,
	    zoneLetter: getLetterDesignator(Lat)
	  };
	}

	/**
	 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
	 * class where the Zone can be specified as a single string eg."60N" which
	 * is then broken down into the ZoneNumber and ZoneLetter.
	 *
	 * @private
	 * @param {object} utm An object literal with northing, easting, zoneNumber
	 *     and zoneLetter properties. If an optional accuracy property is
	 *     provided (in meters), a bounding box will be returned instead of
	 *     latitude and longitude.
	 * @return {object} An object literal containing either lat and lon values
	 *     (if no accuracy was provided), or top, right, bottom and left values
	 *     for the bounding box calculated according to the provided accuracy.
	 *     Returns null if the conversion failed.
	 */
	function UTMtoLL(utm) {

	  var UTMNorthing = utm.northing;
	  var UTMEasting = utm.easting;
	  var zoneLetter = utm.zoneLetter;
	  var zoneNumber = utm.zoneNumber;
	  // check the ZoneNummber is valid
	  if (zoneNumber < 0 || zoneNumber > 60) {
	    return null;
	  }

	  var k0 = 0.9996;
	  var a = 6378137.0; //ellip.radius;
	  var eccSquared = 0.00669438; //ellip.eccsq;
	  var eccPrimeSquared;
	  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
	  var N1, T1, C1, R1, D, M;
	  var LongOrigin;
	  var mu, phi1Rad;

	  // remove 500,000 meter offset for longitude
	  var x = UTMEasting - 500000.0;
	  var y = UTMNorthing;

	  // We must know somehow if we are in the Northern or Southern
	  // hemisphere, this is the only time we use the letter So even
	  // if the Zone letter isn't exactly correct it should indicate
	  // the hemisphere correctly
	  if (zoneLetter < 'N') {
	    y -= 10000000.0; // remove 10,000,000 meter offset used
	    // for southern hemisphere
	  }

	  // There are 60 zones with zone 1 being at West -180 to -174
	  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
	  // in middle of
	  // zone

	  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

	  M = y / k0;
	  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

	  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
	  // double phi1 = ProjMath.radToDeg(phi1Rad);

	  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
	  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
	  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
	  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
	  D = x / (N1 * k0);

	  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
	  lat = radToDeg(lat);

	  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
	  lon = LongOrigin + radToDeg(lon);

	  var result;
	  if (utm.accuracy) {
	    var topRight = UTMtoLL({
	      northing: utm.northing + utm.accuracy,
	      easting: utm.easting + utm.accuracy,
	      zoneLetter: utm.zoneLetter,
	      zoneNumber: utm.zoneNumber
	    });
	    result = {
	      top: topRight.lat,
	      right: topRight.lon,
	      bottom: lat,
	      left: lon
	    };
	  }
	  else {
	    result = {
	      lat: lat,
	      lon: lon
	    };
	  }
	  return result;
	}

	/**
	 * Calculates the MGRS letter designator for the given latitude.
	 *
	 * @private
	 * @param {number} lat The latitude in WGS84 to get the letter designator
	 *     for.
	 * @return {char} The letter designator.
	 */
	function getLetterDesignator(lat) {
	  //This is here as an error flag to show that the Latitude is
	  //outside MGRS limits
	  var LetterDesignator = 'Z';

	  if ((84 >= lat) && (lat >= 72)) {
	    LetterDesignator = 'X';
	  }
	  else if ((72 > lat) && (lat >= 64)) {
	    LetterDesignator = 'W';
	  }
	  else if ((64 > lat) && (lat >= 56)) {
	    LetterDesignator = 'V';
	  }
	  else if ((56 > lat) && (lat >= 48)) {
	    LetterDesignator = 'U';
	  }
	  else if ((48 > lat) && (lat >= 40)) {
	    LetterDesignator = 'T';
	  }
	  else if ((40 > lat) && (lat >= 32)) {
	    LetterDesignator = 'S';
	  }
	  else if ((32 > lat) && (lat >= 24)) {
	    LetterDesignator = 'R';
	  }
	  else if ((24 > lat) && (lat >= 16)) {
	    LetterDesignator = 'Q';
	  }
	  else if ((16 > lat) && (lat >= 8)) {
	    LetterDesignator = 'P';
	  }
	  else if ((8 > lat) && (lat >= 0)) {
	    LetterDesignator = 'N';
	  }
	  else if ((0 > lat) && (lat >= -8)) {
	    LetterDesignator = 'M';
	  }
	  else if ((-8 > lat) && (lat >= -16)) {
	    LetterDesignator = 'L';
	  }
	  else if ((-16 > lat) && (lat >= -24)) {
	    LetterDesignator = 'K';
	  }
	  else if ((-24 > lat) && (lat >= -32)) {
	    LetterDesignator = 'J';
	  }
	  else if ((-32 > lat) && (lat >= -40)) {
	    LetterDesignator = 'H';
	  }
	  else if ((-40 > lat) && (lat >= -48)) {
	    LetterDesignator = 'G';
	  }
	  else if ((-48 > lat) && (lat >= -56)) {
	    LetterDesignator = 'F';
	  }
	  else if ((-56 > lat) && (lat >= -64)) {
	    LetterDesignator = 'E';
	  }
	  else if ((-64 > lat) && (lat >= -72)) {
	    LetterDesignator = 'D';
	  }
	  else if ((-72 > lat) && (lat >= -80)) {
	    LetterDesignator = 'C';
	  }
	  return LetterDesignator;
	}

	/**
	 * Encodes a UTM location as MGRS string.
	 *
	 * @private
	 * @param {object} utm An object literal with easting, northing,
	 *     zoneLetter, zoneNumber
	 * @param {number} accuracy Accuracy in digits (1-5).
	 * @return {string} MGRS string for the given UTM location.
	 */
	function encode(utm, accuracy) {
	  // prepend with leading zeroes
	  var seasting = "00000" + utm.easting,
	    snorthing = "00000" + utm.northing;

	  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
	}

	/**
	 * Get the two letter 100k designator for a given UTM easting,
	 * northing and zone number value.
	 *
	 * @private
	 * @param {number} easting
	 * @param {number} northing
	 * @param {number} zoneNumber
	 * @return the two letter 100k designator for the given UTM location.
	 */
	function get100kID(easting, northing, zoneNumber) {
	  var setParm = get100kSetForZone(zoneNumber);
	  var setColumn = Math.floor(easting / 100000);
	  var setRow = Math.floor(northing / 100000) % 20;
	  return getLetter100kID(setColumn, setRow, setParm);
	}

	/**
	 * Given a UTM zone number, figure out the MGRS 100K set it is in.
	 *
	 * @private
	 * @param {number} i An UTM zone number.
	 * @return {number} the 100k set the UTM zone is in.
	 */
	function get100kSetForZone(i) {
	  var setParm = i % NUM_100K_SETS;
	  if (setParm === 0) {
	    setParm = NUM_100K_SETS;
	  }

	  return setParm;
	}

	/**
	 * Get the two-letter MGRS 100k designator given information
	 * translated from the UTM northing, easting and zone number.
	 *
	 * @private
	 * @param {number} column the column index as it relates to the MGRS
	 *        100k set spreadsheet, created from the UTM easting.
	 *        Values are 1-8.
	 * @param {number} row the row index as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM northing value. Values
	 *        are from 0-19.
	 * @param {number} parm the set block, as it relates to the MGRS 100k set
	 *        spreadsheet, created from the UTM zone. Values are from
	 *        1-60.
	 * @return two letter MGRS 100k code.
	 */
	function getLetter100kID(column, row, parm) {
	  // colOrigin and rowOrigin are the letters at the origin of the set
	  var index = parm - 1;
	  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
	  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

	  // colInt and rowInt are the letters to build to return
	  var colInt = colOrigin + column - 1;
	  var rowInt = rowOrigin + row;
	  var rollover = false;

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	    rollover = true;
	  }

	  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
	    colInt++;
	  }

	  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
	    colInt++;

	    if (colInt === I) {
	      colInt++;
	    }
	  }

	  if (colInt > Z) {
	    colInt = colInt - Z + A - 1;
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	    rollover = true;
	  }
	  else {
	    rollover = false;
	  }

	  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
	    rowInt++;
	  }

	  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
	    rowInt++;

	    if (rowInt === I) {
	      rowInt++;
	    }
	  }

	  if (rowInt > V) {
	    rowInt = rowInt - V + A - 1;
	  }

	  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
	  return twoLetter;
	}

	/**
	 * Decode the UTM parameters from a MGRS string.
	 *
	 * @private
	 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
	 * @return {object} An object literal with easting, northing, zoneLetter,
	 *     zoneNumber and accuracy (in meters) properties.
	 */
	function decode(mgrsString) {

	  if (mgrsString && mgrsString.length === 0) {
	    throw ("MGRSPoint coverting from nothing");
	  }

	  var length = mgrsString.length;

	  var hunK = null;
	  var sb = "";
	  var testChar;
	  var i = 0;

	  // get Zone number
	  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
	    if (i >= 2) {
	      throw ("MGRSPoint bad conversion from: " + mgrsString);
	    }
	    sb += testChar;
	    i++;
	  }

	  var zoneNumber = parseInt(sb, 10);

	  if (i === 0 || i + 3 > length) {
	    // A good MGRS string has to be 4-5 digits long,
	    // ##AAA/#AAA at least.
	    throw ("MGRSPoint bad conversion from: " + mgrsString);
	  }

	  var zoneLetter = mgrsString.charAt(i++);

	  // Should we check the zone letter here? Why not.
	  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
	    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
	  }

	  hunK = mgrsString.substring(i, i += 2);

	  var set = get100kSetForZone(zoneNumber);

	  var east100k = getEastingFromChar(hunK.charAt(0), set);
	  var north100k = getNorthingFromChar(hunK.charAt(1), set);

	  // We have a bug where the northing may be 2000000 too low.
	  // How
	  // do we know when to roll over?

	  while (north100k < getMinNorthing(zoneLetter)) {
	    north100k += 2000000;
	  }

	  // calculate the char index for easting/northing separator
	  var remainder = length - i;

	  if (remainder % 2 !== 0) {
	    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
	  }

	  var sep = remainder / 2;

	  var sepEasting = 0.0;
	  var sepNorthing = 0.0;
	  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
	  if (sep > 0) {
	    accuracyBonus = 100000.0 / Math.pow(10, sep);
	    sepEastingString = mgrsString.substring(i, i + sep);
	    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
	    sepNorthingString = mgrsString.substring(i + sep);
	    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
	  }

	  easting = sepEasting + east100k;
	  northing = sepNorthing + north100k;

	  return {
	    easting: easting,
	    northing: northing,
	    zoneLetter: zoneLetter,
	    zoneNumber: zoneNumber,
	    accuracy: accuracyBonus
	  };
	}

	/**
	 * Given the first letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the easting value that
	 * should be added to the other, secondary easting value.
	 *
	 * @private
	 * @param {char} e The first letter from a two-letter MGRS 100k zone.
	 * @param {number} set The MGRS table set for the zone number.
	 * @return {number} The easting value for the given letter and set.
	 */
	function getEastingFromChar(e, set) {
	  // colOrigin is the letter at the origin of the set for the
	  // column
	  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
	  var eastingValue = 100000.0;
	  var rewindMarker = false;

	  while (curCol !== e.charCodeAt(0)) {
	    curCol++;
	    if (curCol === I) {
	      curCol++;
	    }
	    if (curCol === O) {
	      curCol++;
	    }
	    if (curCol > Z) {
	      if (rewindMarker) {
	        throw ("Bad character: " + e);
	      }
	      curCol = A;
	      rewindMarker = true;
	    }
	    eastingValue += 100000.0;
	  }

	  return eastingValue;
	}

	/**
	 * Given the second letter from a two-letter MGRS 100k zone, and given the
	 * MGRS table set for the zone number, figure out the northing value that
	 * should be added to the other, secondary northing value. You have to
	 * remember that Northings are determined from the equator, and the vertical
	 * cycle of letters mean a 2000000 additional northing meters. This happens
	 * approx. every 18 degrees of latitude. This method does *NOT* count any
	 * additional northings. You have to figure out how many 2000000 meters need
	 * to be added for the zone letter of the MGRS coordinate.
	 *
	 * @private
	 * @param {char} n Second letter of the MGRS 100k zone
	 * @param {number} set The MGRS table set number, which is dependent on the
	 *     UTM zone number.
	 * @return {number} The northing value for the given letter and set.
	 */
	function getNorthingFromChar(n, set) {

	  if (n > 'V') {
	    throw ("MGRSPoint given invalid Northing " + n);
	  }

	  // rowOrigin is the letter at the origin of the set for the
	  // column
	  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
	  var northingValue = 0.0;
	  var rewindMarker = false;

	  while (curRow !== n.charCodeAt(0)) {
	    curRow++;
	    if (curRow === I) {
	      curRow++;
	    }
	    if (curRow === O) {
	      curRow++;
	    }
	    // fixing a bug making whole application hang in this loop
	    // when 'n' is a wrong character
	    if (curRow > V) {
	      if (rewindMarker) { // making sure that this loop ends
	        throw ("Bad character: " + n);
	      }
	      curRow = A;
	      rewindMarker = true;
	    }
	    northingValue += 100000.0;
	  }

	  return northingValue;
	}

	/**
	 * The function getMinNorthing returns the minimum northing value of a MGRS
	 * zone.
	 *
	 * Ported from Geotrans' c Lattitude_Band_Value structure table.
	 *
	 * @private
	 * @param {char} zoneLetter The MGRS zone to get the min northing for.
	 * @return {number}
	 */
	function getMinNorthing(zoneLetter) {
	  var northing;
	  switch (zoneLetter) {
	  case 'C':
	    northing = 1100000.0;
	    break;
	  case 'D':
	    northing = 2000000.0;
	    break;
	  case 'E':
	    northing = 2800000.0;
	    break;
	  case 'F':
	    northing = 3700000.0;
	    break;
	  case 'G':
	    northing = 4600000.0;
	    break;
	  case 'H':
	    northing = 5500000.0;
	    break;
	  case 'J':
	    northing = 6400000.0;
	    break;
	  case 'K':
	    northing = 7300000.0;
	    break;
	  case 'L':
	    northing = 8200000.0;
	    break;
	  case 'M':
	    northing = 9100000.0;
	    break;
	  case 'N':
	    northing = 0.0;
	    break;
	  case 'P':
	    northing = 800000.0;
	    break;
	  case 'Q':
	    northing = 1700000.0;
	    break;
	  case 'R':
	    northing = 2600000.0;
	    break;
	  case 'S':
	    northing = 3500000.0;
	    break;
	  case 'T':
	    northing = 4400000.0;
	    break;
	  case 'U':
	    northing = 5300000.0;
	    break;
	  case 'V':
	    northing = 6200000.0;
	    break;
	  case 'W':
	    northing = 7000000.0;
	    break;
	  case 'X':
	    northing = 7900000.0;
	    break;
	  default:
	    northing = -1.0;
	  }
	  if (northing >= 0.0) {
	    return northing;
	  }
	  else {
	    throw ("Invalid zone letter: " + zoneLetter);
	  }

	}

	function Point$1(x, y, z) {
	  if (!(this instanceof Point$1)) {
	    return new Point$1(x, y, z);
	  }
	  if (Array.isArray(x)) {
	    this.x = x[0];
	    this.y = x[1];
	    this.z = x[2] || 0.0;
	  } else if(typeof x === 'object') {
	    this.x = x.x;
	    this.y = x.y;
	    this.z = x.z || 0.0;
	  } else if (typeof x === 'string' && typeof y === 'undefined') {
	    var coords = x.split(',');
	    this.x = parseFloat(coords[0], 10);
	    this.y = parseFloat(coords[1], 10);
	    this.z = parseFloat(coords[2], 10) || 0.0;
	  } else {
	    this.x = x;
	    this.y = y;
	    this.z = z || 0.0;
	  }
	  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
	}

	Point$1.fromMGRS = function(mgrsStr) {
	  return new Point$1(toPoint(mgrsStr));
	};
	Point$1.prototype.toMGRS = function(accuracy) {
	  return forward$t([this.x, this.y], accuracy);
	};

	var C00 = 1;
	var C02 = 0.25;
	var C04 = 0.046875;
	var C06 = 0.01953125;
	var C08 = 0.01068115234375;
	var C22 = 0.75;
	var C44 = 0.46875;
	var C46 = 0.01302083333333333333;
	var C48 = 0.00712076822916666666;
	var C66 = 0.36458333333333333333;
	var C68 = 0.00569661458333333333;
	var C88 = 0.3076171875;

	function pj_enfn(es) {
	  var en = [];
	  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
	  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
	  var t = es * es;
	  en[2] = t * (C44 - es * (C46 + es * C48));
	  t *= es;
	  en[3] = t * (C66 - es * C68);
	  en[4] = t * es * C88;
	  return en;
	}

	function pj_mlfn(phi, sphi, cphi, en) {
	  cphi *= sphi;
	  sphi *= sphi;
	  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
	}

	var MAX_ITER$3 = 20;

	function pj_inv_mlfn(arg, es, en) {
	  var k = 1 / (1 - es);
	  var phi = arg;
	  for (var i = MAX_ITER$3; i; --i) { /* rarely goes over 2 iterations */
	    var s = Math.sin(phi);
	    var t = 1 - es * s * s;
	    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
	    //phi -= t * (t * Math.sqrt(t)) * k;
	    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
	    phi -= t;
	    if (Math.abs(t) < EPSLN) {
	      return phi;
	    }
	  }
	  //..reportError("cass:pj_inv_mlfn: Convergence error");
	  return phi;
	}

	// Heavily based on this tmerc projection implementation

	function init$t() {
	  this.x0 = this.x0 !== undefined ? this.x0 : 0;
	  this.y0 = this.y0 !== undefined ? this.y0 : 0;
	  this.long0 = this.long0 !== undefined ? this.long0 : 0;
	  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	  if (this.es) {
	    this.en = pj_enfn(this.es);
	    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
	  }
	}

	/**
	    Transverse Mercator Forward  - long/lat to x/y
	    long/lat in radians
	  */
	function forward$s(p) {
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var con;
	  var x, y;
	  var sin_phi = Math.sin(lat);
	  var cos_phi = Math.cos(lat);

	  if (!this.es) {
	    var b = cos_phi * Math.sin(delta_lon);

	    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
	      return (93);
	    }
	    else {
	      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
	      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
	      b = Math.abs(y);

	      if (b >= 1) {
	        if ((b - 1) > EPSLN) {
	          return (93);
	        }
	        else {
	          y = 0;
	        }
	      }
	      else {
	        y = Math.acos(y);
	      }

	      if (lat < 0) {
	        y = -y;
	      }

	      y = this.a * this.k0 * (y - this.lat0) + this.y0;
	    }
	  }
	  else {
	    var al = cos_phi * delta_lon;
	    var als = Math.pow(al, 2);
	    var c = this.ep2 * Math.pow(cos_phi, 2);
	    var cs = Math.pow(c, 2);
	    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
	    var t = Math.pow(tq, 2);
	    var ts = Math.pow(t, 2);
	    con = 1 - this.es * Math.pow(sin_phi, 2);
	    al = al / Math.sqrt(con);
	    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

	    x = this.a * (this.k0 * al * (1 +
	      als / 6 * (1 - t + c +
	      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
	      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
	      this.x0;

	    y = this.a * (this.k0 * (ml - this.ml0 +
	      sin_phi * delta_lon * al / 2 * (1 +
	      als / 12 * (5 - t + 9 * c + 4 * cs +
	      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
	      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
	      this.y0;
	  }

	  p.x = x;
	  p.y = y;

	  return p;
	}

	/**
	    Transverse Mercator Inverse  -  x/y to long/lat
	  */
	function inverse$s(p) {
	  var con, phi;
	  var lat, lon;
	  var x = (p.x - this.x0) * (1 / this.a);
	  var y = (p.y - this.y0) * (1 / this.a);

	  if (!this.es) {
	    var f = Math.exp(x / this.k0);
	    var g = 0.5 * (f - 1 / f);
	    var temp = this.lat0 + y / this.k0;
	    var h = Math.cos(temp);
	    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
	    lat = Math.asin(con);

	    if (y < 0) {
	      lat = -lat;
	    }

	    if ((g === 0) && (h === 0)) {
	      lon = 0;
	    }
	    else {
	      lon = adjust_lon(Math.atan2(g, h) + this.long0);
	    }
	  }
	  else { // ellipsoidal form
	    con = this.ml0 + y / this.k0;
	    phi = pj_inv_mlfn(con, this.es, this.en);

	    if (Math.abs(phi) < HALF_PI) {
	      var sin_phi = Math.sin(phi);
	      var cos_phi = Math.cos(phi);
	      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
	      var c = this.ep2 * Math.pow(cos_phi, 2);
	      var cs = Math.pow(c, 2);
	      var t = Math.pow(tan_phi, 2);
	      var ts = Math.pow(t, 2);
	      con = 1 - this.es * Math.pow(sin_phi, 2);
	      var d = x * Math.sqrt(con) / this.k0;
	      var ds = Math.pow(d, 2);
	      con = con * tan_phi;

	      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
	        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
	        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
	        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

	      lon = adjust_lon(this.long0 + (d * (1 -
	        ds / 6 * (1 + 2 * t + c -
	        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
	        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
	    }
	    else {
	      lat = HALF_PI * sign(y);
	      lon = 0;
	    }
	  }

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$t = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
	var tmerc = {
	  init: init$t,
	  forward: forward$s,
	  inverse: inverse$s,
	  names: names$t
	};

	function sinh(x) {
	  var r = Math.exp(x);
	  r = (r - 1 / r) / 2;
	  return r;
	}

	function hypot(x, y) {
	  x = Math.abs(x);
	  y = Math.abs(y);
	  var a = Math.max(x, y);
	  var b = Math.min(x, y) / (a ? a : 1);

	  return a * Math.sqrt(1 + Math.pow(b, 2));
	}

	function log1py(x) {
	  var y = 1 + x;
	  var z = y - 1;

	  return z === 0 ? x : x * Math.log(y) / z;
	}

	function asinhy(x) {
	  var y = Math.abs(x);
	  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

	  return x < 0 ? -y : y;
	}

	function gatg(pp, B) {
	  var cos_2B = 2 * Math.cos(2 * B);
	  var i = pp.length - 1;
	  var h1 = pp[i];
	  var h2 = 0;
	  var h;

	  while (--i >= 0) {
	    h = -h2 + cos_2B * h1 + pp[i];
	    h2 = h1;
	    h1 = h;
	  }

	  return (B + h * Math.sin(2 * B));
	}

	function clens(pp, arg_r) {
	  var r = 2 * Math.cos(arg_r);
	  var i = pp.length - 1;
	  var hr1 = pp[i];
	  var hr2 = 0;
	  var hr;

	  while (--i >= 0) {
	    hr = -hr2 + r * hr1 + pp[i];
	    hr2 = hr1;
	    hr1 = hr;
	  }

	  return Math.sin(arg_r) * hr;
	}

	function cosh(x) {
	  var r = Math.exp(x);
	  r = (r + 1 / r) / 2;
	  return r;
	}

	function clens_cmplx(pp, arg_r, arg_i) {
	  var sin_arg_r = Math.sin(arg_r);
	  var cos_arg_r = Math.cos(arg_r);
	  var sinh_arg_i = sinh(arg_i);
	  var cosh_arg_i = cosh(arg_i);
	  var r = 2 * cos_arg_r * cosh_arg_i;
	  var i = -2 * sin_arg_r * sinh_arg_i;
	  var j = pp.length - 1;
	  var hr = pp[j];
	  var hi1 = 0;
	  var hr1 = 0;
	  var hi = 0;
	  var hr2;
	  var hi2;

	  while (--j >= 0) {
	    hr2 = hr1;
	    hi2 = hi1;
	    hr1 = hr;
	    hi1 = hi;
	    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
	    hi = -hi2 + i * hr1 + r * hi1;
	  }

	  r = sin_arg_r * cosh_arg_i;
	  i = cos_arg_r * sinh_arg_i;

	  return [r * hr - i * hi, r * hi + i * hr];
	}

	// Heavily based on this etmerc projection implementation

	function init$s() {
	  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
	    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
	  }
	  if (this.approx) {
	    // When '+approx' is set, use tmerc instead
	    tmerc.init.apply(this);
	    this.forward = tmerc.forward;
	    this.inverse = tmerc.inverse;
	  }

	  this.x0 = this.x0 !== undefined ? this.x0 : 0;
	  this.y0 = this.y0 !== undefined ? this.y0 : 0;
	  this.long0 = this.long0 !== undefined ? this.long0 : 0;
	  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

	  this.cgb = [];
	  this.cbg = [];
	  this.utg = [];
	  this.gtu = [];

	  var f = this.es / (1 + Math.sqrt(1 - this.es));
	  var n = f / (2 - f);
	  var np = n;

	  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
	  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

	  np = np * n;
	  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
	  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

	  np = np * n;
	  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
	  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

	  np = np * n;
	  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
	  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

	  np = np * n;
	  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
	  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

	  np = np * n;
	  this.cgb[5] = np * (601676 / 22275);
	  this.cbg[5] = np * (444337 / 155925);

	  np = Math.pow(n, 2);
	  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

	  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
	  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

	  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
	  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

	  np = np * n;
	  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
	  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

	  np = np * n;
	  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
	  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

	  np = np * n;
	  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
	  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

	  np = np * n;
	  this.utg[5] = np * (-20648693 / 638668800);
	  this.gtu[5] = np * (212378941 / 319334400);

	  var Z = gatg(this.cbg, this.lat0);
	  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
	}

	function forward$r(p) {
	  var Ce = adjust_lon(p.x - this.long0);
	  var Cn = p.y;

	  Cn = gatg(this.cbg, Cn);
	  var sin_Cn = Math.sin(Cn);
	  var cos_Cn = Math.cos(Cn);
	  var sin_Ce = Math.sin(Ce);
	  var cos_Ce = Math.cos(Ce);

	  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
	  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
	  Ce = asinhy(Math.tan(Ce));

	  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

	  Cn = Cn + tmp[0];
	  Ce = Ce + tmp[1];

	  var x;
	  var y;

	  if (Math.abs(Ce) <= 2.623395162778) {
	    x = this.a * (this.Qn * Ce) + this.x0;
	    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
	  }
	  else {
	    x = Infinity;
	    y = Infinity;
	  }

	  p.x = x;
	  p.y = y;

	  return p;
	}

	function inverse$r(p) {
	  var Ce = (p.x - this.x0) * (1 / this.a);
	  var Cn = (p.y - this.y0) * (1 / this.a);

	  Cn = (Cn - this.Zb) / this.Qn;
	  Ce = Ce / this.Qn;

	  var lon;
	  var lat;

	  if (Math.abs(Ce) <= 2.623395162778) {
	    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

	    Cn = Cn + tmp[0];
	    Ce = Ce + tmp[1];
	    Ce = Math.atan(sinh(Ce));

	    var sin_Cn = Math.sin(Cn);
	    var cos_Cn = Math.cos(Cn);
	    var sin_Ce = Math.sin(Ce);
	    var cos_Ce = Math.cos(Ce);

	    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
	    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

	    lon = adjust_lon(Ce + this.long0);
	    lat = gatg(this.cgb, Cn);
	  }
	  else {
	    lon = Infinity;
	    lat = Infinity;
	  }

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$s = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
	var etmerc = {
	  init: init$s,
	  forward: forward$r,
	  inverse: inverse$r,
	  names: names$s
	};

	function adjust_zone(zone, lon) {
	  if (zone === undefined) {
	    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

	    if (zone < 0) {
	      return 0;
	    } else if (zone > 60) {
	      return 60;
	    }
	  }
	  return zone;
	}

	var dependsOn = 'etmerc';


	function init$r() {
	  var zone = adjust_zone(this.zone, this.long0);
	  if (zone === undefined) {
	    throw new Error('unknown utm zone');
	  }
	  this.lat0 = 0;
	  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R$1;
	  this.x0 = 500000;
	  this.y0 = this.utmSouth ? 10000000 : 0;
	  this.k0 = 0.9996;

	  etmerc.init.apply(this);
	  this.forward = etmerc.forward;
	  this.inverse = etmerc.inverse;
	}

	var names$r = ["Universal Transverse Mercator System", "utm"];
	var utm = {
	  init: init$r,
	  names: names$r,
	  dependsOn: dependsOn
	};

	function srat(esinp, exp) {
	  return (Math.pow((1 - esinp) / (1 + esinp), exp));
	}

	var MAX_ITER$2 = 20;

	function init$q() {
	  var sphi = Math.sin(this.lat0);
	  var cphi = Math.cos(this.lat0);
	  cphi *= cphi;
	  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
	  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
	  this.phic0 = Math.asin(sphi / this.C);
	  this.ratexp = 0.5 * this.C * this.e;
	  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
	}

	function forward$q(p) {
	  var lon = p.x;
	  var lat = p.y;

	  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
	  p.x = this.C * lon;
	  return p;
	}

	function inverse$q(p) {
	  var DEL_TOL = 1e-14;
	  var lon = p.x / this.C;
	  var lat = p.y;
	  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
	  for (var i = MAX_ITER$2; i > 0; --i) {
	    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
	    if (Math.abs(lat - p.y) < DEL_TOL) {
	      break;
	    }
	    p.y = lat;
	  }
	  /* convergence failed */
	  if (!i) {
	    return null;
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$q = ["gauss"];
	var gauss = {
	  init: init$q,
	  forward: forward$q,
	  inverse: inverse$q,
	  names: names$q
	};

	function init$p() {
	  gauss.init.apply(this);
	  if (!this.rc) {
	    return;
	  }
	  this.sinc0 = Math.sin(this.phic0);
	  this.cosc0 = Math.cos(this.phic0);
	  this.R2 = 2 * this.rc;
	  if (!this.title) {
	    this.title = "Oblique Stereographic Alternative";
	  }
	}

	function forward$p(p) {
	  var sinc, cosc, cosl, k;
	  p.x = adjust_lon(p.x - this.long0);
	  gauss.forward.apply(this, [p]);
	  sinc = Math.sin(p.y);
	  cosc = Math.cos(p.y);
	  cosl = Math.cos(p.x);
	  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
	  p.x = k * cosc * Math.sin(p.x);
	  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
	  p.x = this.a * p.x + this.x0;
	  p.y = this.a * p.y + this.y0;
	  return p;
	}

	function inverse$p(p) {
	  var sinc, cosc, lon, lat, rho;
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;
	  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    var c = 2 * Math.atan2(rho, this.R2);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);
	    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
	    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  gauss.inverse.apply(this, [p]);
	  p.x = adjust_lon(p.x + this.long0);
	  return p;
	}

	var names$p = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
	var sterea = {
	  init: init$p,
	  forward: forward$p,
	  inverse: inverse$p,
	  names: names$p
	};

	function ssfn_(phit, sinphi, eccen) {
	  sinphi *= eccen;
	  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
	}

	function init$o() {
	  this.coslat0 = Math.cos(this.lat0);
	  this.sinlat0 = Math.sin(this.lat0);
	  if (this.sphere) {
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
	    }
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (this.lat0 > 0) {
	        //North pole
	        //trace('stere:north pole');
	        this.con = 1;
	      }
	      else {
	        //South pole
	        //trace('stere:south pole');
	        this.con = -1;
	      }
	    }
	    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
	    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
	      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
	    }
	    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
	    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
	    this.cosX0 = Math.cos(this.X0);
	    this.sinX0 = Math.sin(this.X0);
	  }
	}

	// Stereographic forward equations--mapping lat,long to x,y
	function forward$o(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinlat = Math.sin(lat);
	  var coslat = Math.cos(lat);
	  var A, X, sinX, cosX, ts, rh;
	  var dlon = adjust_lon(lon - this.long0);

	  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
	    //case of the origine point
	    //trace('stere:this is the origin point');
	    p.x = NaN;
	    p.y = NaN;
	    return p;
	  }
	  if (this.sphere) {
	    //trace('stere:sphere case');
	    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
	    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
	    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
	    return p;
	  }
	  else {
	    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
	    cosX = Math.cos(X);
	    sinX = Math.sin(X);
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
	      rh = 2 * this.a * this.k0 * ts / this.cons;
	      p.x = this.x0 + rh * Math.sin(lon - this.long0);
	      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
	      //trace(p.toString());
	      return p;
	    }
	    else if (Math.abs(this.sinlat0) < EPSLN) {
	      //Eq
	      //trace('stere:equateur');
	      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
	      p.y = A * sinX;
	    }
	    else {
	      //other case
	      //trace('stere:normal case');
	      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
	      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
	    }
	    p.x = A * cosX * Math.sin(dlon) + this.x0;
	  }
	  //trace(p.toString());
	  return p;
	}

	//* Stereographic inverse equations--mapping x,y to lat/long
	function inverse$o(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat, ts, ce, Chi;
	  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  if (this.sphere) {
	    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
	    lon = this.long0;
	    lat = this.lat0;
	    if (rh <= EPSLN) {
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
	    if (Math.abs(this.coslat0) < EPSLN) {
	      if (this.lat0 > 0) {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      }
	      else {
	        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      }
	    }
	    else {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    if (Math.abs(this.coslat0) <= EPSLN) {
	      if (rh <= EPSLN) {
	        lat = this.lat0;
	        lon = this.long0;
	        p.x = lon;
	        p.y = lat;
	        //trace(p.toString());
	        return p;
	      }
	      p.x *= this.con;
	      p.y *= this.con;
	      ts = rh * this.cons / (2 * this.a * this.k0);
	      lat = this.con * phi2z(this.e, ts);
	      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
	    }
	    else {
	      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
	      lon = this.long0;
	      if (rh <= EPSLN) {
	        Chi = this.X0;
	      }
	      else {
	        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
	      }
	      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
	    }
	  }
	  p.x = lon;
	  p.y = lat;

	  //trace(p.toString());
	  return p;

	}

	var names$o = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
	var stere = {
	  init: init$o,
	  forward: forward$o,
	  inverse: inverse$o,
	  names: names$o,
	  ssfn_: ssfn_
	};

	/*
	  references:
	    Formules et constantes pour le Calcul pour la
	    projection cylindrique conforme  axe oblique et pour la transformation entre
	    des systmes de rfrence.
	    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
	  */

	function init$n() {
	  var phy0 = this.lat0;
	  this.lambda0 = this.long0;
	  var sinPhy0 = Math.sin(phy0);
	  var semiMajorAxis = this.a;
	  var invF = this.rf;
	  var flattening = 1 / invF;
	  var e2 = 2 * flattening - Math.pow(flattening, 2);
	  var e = this.e = Math.sqrt(e2);
	  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
	  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
	  this.b0 = Math.asin(sinPhy0 / this.alpha);
	  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
	  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
	  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
	  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
	}

	function forward$n(p) {
	  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
	  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
	  var S = -this.alpha * (Sa1 + Sa2) + this.K;

	  // spheric latitude
	  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

	  // spheric longitude
	  var I = this.alpha * (p.x - this.lambda0);

	  // psoeudo equatorial rotation
	  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

	  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

	  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
	  p.x = this.R * rotI + this.x0;
	  return p;
	}

	function inverse$n(p) {
	  var Y = p.x - this.x0;
	  var X = p.y - this.y0;

	  var rotI = Y / this.R;
	  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

	  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
	  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

	  var lambda = this.lambda0 + I / this.alpha;

	  var S = 0;
	  var phy = b;
	  var prevPhy = -1000;
	  var iteration = 0;
	  while (Math.abs(phy - prevPhy) > 0.0000001) {
	    if (++iteration > 20) {
	      //...reportError("omercFwdInfinity");
	      return;
	    }
	    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
	    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
	    prevPhy = phy;
	    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
	  }

	  p.x = lambda;
	  p.y = phy;
	  return p;
	}

	var names$n = ["somerc"];
	var somerc = {
	  init: init$n,
	  forward: forward$n,
	  inverse: inverse$n,
	  names: names$n
	};

	var TOL = 1e-7;

	function isTypeA(P) {
	  var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
	  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
	  
	  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
	}


	/* Initialize the Oblique Mercator  projection
	    ------------------------------------------*/
	function init$m() {  
	  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
	    gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
	  
	  // only Type A uses the no_off or no_uoff property
	  // https://github.com/OSGeo/proj.4/issues/104
	  this.no_off = isTypeA(this);
	  this.no_rot = 'no_rot' in this;
	  
	  var alp = false;
	  if ("alpha" in this) {
	    alp = true;
	  }

	  var gam = false;
	  if ("rectified_grid_angle" in this) {
	    gam = true;
	  }

	  if (alp) {
	    alpha_c = this.alpha;
	  }
	  
	  if (gam) {
	    gamma = (this.rectified_grid_angle * D2R$1);
	  }
	  
	  if (alp || gam) {
	    lamc = this.longc;
	  } else {
	    lam1 = this.long1;
	    phi1 = this.lat1;
	    lam2 = this.long2;
	    phi2 = this.lat2;
	    
	    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
	        Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
	        Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
	      throw new Error();
	    }
	  }
	  
	  var one_es = 1.0 - this.es;
	  com = Math.sqrt(one_es);
	  
	  if (Math.abs(this.lat0) > EPSLN) {
	    sinph0 = Math.sin(this.lat0);
	    cosph0 = Math.cos(this.lat0);
	    con = 1 - this.es * sinph0 * sinph0;
	    this.B = cosph0 * cosph0;
	    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
	    this.A = this.B * this.k0 * com / con;
	    D = this.B * com / (cosph0 * Math.sqrt(con));
	    F = D * D -1;
	    
	    if (F <= 0) {
	      F = 0;
	    } else {
	      F = Math.sqrt(F);
	      if (this.lat0 < 0) {
	        F = -F;
	      }
	    }
	    
	    this.E = F += D;
	    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
	  } else {
	    this.B = 1 / com;
	    this.A = this.k0;
	    this.E = D = F = 1;
	  }
	  
	  if (alp || gam) {
	    if (alp) {
	      gamma0 = Math.asin(Math.sin(alpha_c) / D);
	      if (!gam) {
	        gamma = alpha_c;
	      }
	    } else {
	      gamma0 = gamma;
	      alpha_c = Math.asin(D * Math.sin(gamma0));
	    }
	    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
	  } else {
	    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
	    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
	    F = this.E / H;
	    p = (L - H) / (L + H);
	    J = this.E * this.E;
	    J = (J - L * H) / (J + L * H);
	    con = lam1 - lam2;
	    
	    if (con < -Math.pi) {
	      lam2 -=TWO_PI;
	    } else if (con > Math.pi) {
	      lam2 += TWO_PI;
	    }
	    
	    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
	    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
	    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
	  }
	  
	  this.singam = Math.sin(gamma0);
	  this.cosgam = Math.cos(gamma0);
	  this.sinrot = Math.sin(gamma);
	  this.cosrot = Math.cos(gamma);
	  
	  this.rB = 1 / this.B;
	  this.ArB = this.A * this.rB;
	  this.BrA = 1 / this.ArB;
	  this.A * this.B;
	  
	  if (this.no_off) {
	    this.u_0 = 0;
	  } else {
	    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
	    
	    if (this.lat0 < 0) {
	      this.u_0 = - this.u_0;
	    }  
	  }
	    
	  F = 0.5 * gamma0;
	  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
	  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
	}


	/* Oblique Mercator forward equations--mapping lat,long to x,y
	    ----------------------------------------------------------*/
	function forward$m(p) {
	  var coords = {};
	  var S, T, U, V, W, temp, u, v;
	  p.x = p.x - this.lam0;
	  
	  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
	    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
	    
	    temp = 1 / W;
	    S = 0.5 * (W - temp);
	    T = 0.5 * (W + temp);
	    V = Math.sin(this.B * p.x);
	    U = (S * this.singam - V * this.cosgam) / T;
	        
	    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
	      throw new Error();
	    }
	    
	    v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
	    temp = Math.cos(this.B * p.x);
	    
	    if (Math.abs(temp) < TOL) {
	      u = this.A * p.x;
	    } else {
	      u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
	    }    
	  } else {
	    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
	    u = this.ArB * p.y;
	  }
	     
	  if (this.no_rot) {
	    coords.x = u;
	    coords.y = v;
	  } else {
	    u -= this.u_0;
	    coords.x = v * this.cosrot + u * this.sinrot;
	    coords.y = u * this.cosrot - v * this.sinrot;
	  }
	  
	  coords.x = (this.a * coords.x + this.x0);
	  coords.y = (this.a * coords.y + this.y0);
	  
	  return coords;
	}

	function inverse$m(p) {
	  var u, v, Qp, Sp, Tp, Vp, Up;
	  var coords = {};
	  
	  p.x = (p.x - this.x0) * (1.0 / this.a);
	  p.y = (p.y - this.y0) * (1.0 / this.a);

	  if (this.no_rot) {
	    v = p.y;
	    u = p.x;
	  } else {
	    v = p.x * this.cosrot - p.y * this.sinrot;
	    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
	  }
	  
	  Qp = Math.exp(-this.BrA * v);
	  Sp = 0.5 * (Qp - 1 / Qp);
	  Tp = 0.5 * (Qp + 1 / Qp);
	  Vp = Math.sin(this.BrA * u);
	  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
	  
	  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
	    coords.x = 0;
	    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
	  } else {
	    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
	    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
	    
	    if (coords.y === Infinity) {
	      throw new Error();
	    }
	        
	    coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
	  }
	  
	  coords.x += this.lam0;
	  
	  return coords;
	}

	var names$m = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
	var omerc = {
	  init: init$m,
	  forward: forward$m,
	  inverse: inverse$m,
	  names: names$m
	};

	function init$l() {
	  
	  //double lat0;                    /* the reference latitude               */
	  //double long0;                   /* the reference longitude              */
	  //double lat1;                    /* first standard parallel              */
	  //double lat2;                    /* second standard parallel             */
	  //double r_maj;                   /* major axis                           */
	  //double r_min;                   /* minor axis                           */
	  //double false_east;              /* x offset in meters                   */
	  //double false_north;             /* y offset in meters                   */
	  
	  //the above value can be set with proj4.defs
	  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

	  if (!this.lat2) {
	    this.lat2 = this.lat1;
	  } //if lat2 is not defined
	  if (!this.k0) {
	    this.k0 = 1;
	  }
	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }

	  var temp = this.b / this.a;
	  this.e = Math.sqrt(1 - temp * temp);

	  var sin1 = Math.sin(this.lat1);
	  var cos1 = Math.cos(this.lat1);
	  var ms1 = msfnz(this.e, sin1, cos1);
	  var ts1 = tsfnz(this.e, this.lat1, sin1);

	  var sin2 = Math.sin(this.lat2);
	  var cos2 = Math.cos(this.lat2);
	  var ms2 = msfnz(this.e, sin2, cos2);
	  var ts2 = tsfnz(this.e, this.lat2, sin2);

	  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
	  }
	  else {
	    this.ns = sin1;
	  }
	  if (isNaN(this.ns)) {
	    this.ns = sin1;
	  }
	  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
	  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
	  if (!this.title) {
	    this.title = "Lambert Conformal Conic";
	  }
	}

	// Lambert Conformal conic forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$l(p) {

	  var lon = p.x;
	  var lat = p.y;

	  // singular cases :
	  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
	    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
	  }

	  var con = Math.abs(Math.abs(lat) - HALF_PI);
	  var ts, rh1;
	  if (con > EPSLN) {
	    ts = tsfnz(this.e, lat, Math.sin(lat));
	    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
	  }
	  else {
	    con = lat * this.ns;
	    if (con <= 0) {
	      return null;
	    }
	    rh1 = 0;
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
	  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

	  return p;
	}

	// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$l(p) {

	  var rh1, con, ts;
	  var lat, lon;
	  var x = (p.x - this.x0) / this.k0;
	  var y = (this.rh - (p.y - this.y0) / this.k0);
	  if (this.ns > 0) {
	    rh1 = Math.sqrt(x * x + y * y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(x * x + y * y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2((con * x), (con * y));
	  }
	  if ((rh1 !== 0) || (this.ns > 0)) {
	    con = 1 / this.ns;
	    ts = Math.pow((rh1 / (this.a * this.f0)), con);
	    lat = phi2z(this.e, ts);
	    if (lat === -9999) {
	      return null;
	    }
	  }
	  else {
	    lat = -HALF_PI;
	  }
	  lon = adjust_lon(theta / this.ns + this.long0);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$l = [
	  "Lambert Tangential Conformal Conic Projection",
	  "Lambert_Conformal_Conic",
	  "Lambert_Conformal_Conic_1SP",
	  "Lambert_Conformal_Conic_2SP",
	  "lcc",
	  "Lambert Conic Conformal (1SP)",
	  "Lambert Conic Conformal (2SP)"
	];

	var lcc = {
	  init: init$l,
	  forward: forward$l,
	  inverse: inverse$l,
	  names: names$l
	};

	function init$k() {
	  this.a = 6377397.155;
	  this.es = 0.006674372230614;
	  this.e = Math.sqrt(this.es);
	  if (!this.lat0) {
	    this.lat0 = 0.863937979737193;
	  }
	  if (!this.long0) {
	    this.long0 = 0.7417649320975901 - 0.308341501185665;
	  }
	  /* if scale not set default to 0.9999 */
	  if (!this.k0) {
	    this.k0 = 0.9999;
	  }
	  this.s45 = 0.785398163397448; /* 45 */
	  this.s90 = 2 * this.s45;
	  this.fi0 = this.lat0;
	  this.e2 = this.es;
	  this.e = Math.sqrt(this.e2);
	  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
	  this.uq = 1.04216856380474;
	  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
	  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
	  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
	  this.k1 = this.k0;
	  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
	  this.s0 = 1.37008346281555;
	  this.n = Math.sin(this.s0);
	  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
	  this.ad = this.s90 - this.uq;
	}

	/* ellipsoid */
	/* calculate xy from lat/lon */
	/* Constants, identical to inverse transform function */
	function forward$k(p) {
	  var gfi, u, deltav, s, d, eps, ro;
	  var lon = p.x;
	  var lat = p.y;
	  var delta_lon = adjust_lon(lon - this.long0);
	  /* Transformation */
	  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
	  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
	  deltav = -delta_lon * this.alfa;
	  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
	  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
	  eps = this.n * d;
	  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
	  p.y = ro * Math.cos(eps) / 1;
	  p.x = ro * Math.sin(eps) / 1;

	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  return (p);
	}

	/* calculate lat/lon from xy */
	function inverse$k(p) {
	  var u, deltav, s, d, eps, ro, fi1;
	  var ok;

	  /* Transformation */
	  /* revert y, x*/
	  var tmp = p.x;
	  p.x = p.y;
	  p.y = tmp;
	  if (!this.czech) {
	    p.y *= -1;
	    p.x *= -1;
	  }
	  ro = Math.sqrt(p.x * p.x + p.y * p.y);
	  eps = Math.atan2(p.y, p.x);
	  d = eps / Math.sin(this.s0);
	  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
	  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
	  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
	  p.x = this.long0 - deltav / this.alfa;
	  fi1 = u;
	  ok = 0;
	  var iter = 0;
	  do {
	    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
	    if (Math.abs(fi1 - p.y) < 0.0000000001) {
	      ok = 1;
	    }
	    fi1 = p.y;
	    iter += 1;
	  } while (ok === 0 && iter < 15);
	  if (iter >= 15) {
	    return null;
	  }

	  return (p);
	}

	var names$k = ["Krovak", "krovak"];
	var krovak = {
	  init: init$k,
	  forward: forward$k,
	  inverse: inverse$k,
	  names: names$k
	};

	function mlfn(e0, e1, e2, e3, phi) {
	  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
	}

	function e0fn(x) {
	  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
	}

	function e1fn(x) {
	  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
	}

	function e2fn(x) {
	  return (0.05859375 * x * x * (1 + 0.75 * x));
	}

	function e3fn(x) {
	  return (x * x * x * (35 / 3072));
	}

	function gN(a, e, sinphi) {
	  var temp = e * sinphi;
	  return a / Math.sqrt(1 - temp * temp);
	}

	function adjust_lat(x) {
	  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
	}

	function imlfn(ml, e0, e1, e2, e3) {
	  var phi;
	  var dphi;

	  phi = ml / e0;
	  for (var i = 0; i < 15; i++) {
	    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
	  return NaN;
	}

	function init$j() {
	  if (!this.sphere) {
	    this.e0 = e0fn(this.es);
	    this.e1 = e1fn(this.es);
	    this.e2 = e2fn(this.es);
	    this.e3 = e3fn(this.es);
	    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  }
	}

	/* Cassini forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	function forward$j(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y;
	  var lam = p.x;
	  var phi = p.y;
	  lam = adjust_lon(lam - this.long0);

	  if (this.sphere) {
	    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
	    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
	  }
	  else {
	    //ellipsoid
	    var sinphi = Math.sin(phi);
	    var cosphi = Math.cos(phi);
	    var nl = gN(this.a, this.e, sinphi);
	    var tl = Math.tan(phi) * Math.tan(phi);
	    var al = lam * Math.cos(phi);
	    var asq = al * al;
	    var cl = this.es * cosphi * cosphi / (1 - this.es);
	    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

	    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
	    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


	  }

	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$j(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var phi, lam;

	  if (this.sphere) {
	    var dd = y + this.lat0;
	    phi = Math.asin(Math.sin(dd) * Math.cos(x));
	    lam = Math.atan2(Math.tan(x), Math.cos(dd));
	  }
	  else {
	    /* ellipsoid */
	    var ml1 = this.ml0 / this.a + y;
	    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
	    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
	      p.x = this.long0;
	      p.y = HALF_PI;
	      if (y < 0) {
	        p.y *= -1;
	      }
	      return p;
	    }
	    var nl1 = gN(this.a, this.e, Math.sin(phi1));

	    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
	    var tl1 = Math.pow(Math.tan(phi1), 2);
	    var dl = x * this.a / nl1;
	    var dsq = dl * dl;
	    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
	    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

	  }

	  p.x = adjust_lon(lam + this.long0);
	  p.y = adjust_lat(phi);
	  return p;

	}

	var names$j = ["Cassini", "Cassini_Soldner", "cass"];
	var cass = {
	  init: init$j,
	  forward: forward$j,
	  inverse: inverse$j,
	  names: names$j
	};

	function qsfnz(eccent, sinphi) {
	  var con;
	  if (eccent > 1.0e-7) {
	    con = eccent * sinphi;
	    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
	  }
	  else {
	    return (2 * sinphi);
	  }
	}

	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */

	var S_POLE = 1;

	var N_POLE = 2;
	var EQUIT = 3;
	var OBLIQ = 4;

	/* Initialize the Lambert Azimuthal Equal Area projection
	  ------------------------------------------------------*/
	function init$i() {
	  var t = Math.abs(this.lat0);
	  if (Math.abs(t - HALF_PI) < EPSLN) {
	    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
	  }
	  else if (Math.abs(t) < EPSLN) {
	    this.mode = this.EQUIT;
	  }
	  else {
	    this.mode = this.OBLIQ;
	  }
	  if (this.es > 0) {
	    var sinphi;

	    this.qp = qsfnz(this.e, 1);
	    this.mmf = 0.5 / (1 - this.es);
	    this.apa = authset(this.es);
	    switch (this.mode) {
	    case this.N_POLE:
	      this.dd = 1;
	      break;
	    case this.S_POLE:
	      this.dd = 1;
	      break;
	    case this.EQUIT:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      this.dd = 1 / this.rq;
	      this.xmf = 1;
	      this.ymf = 0.5 * this.qp;
	      break;
	    case this.OBLIQ:
	      this.rq = Math.sqrt(0.5 * this.qp);
	      sinphi = Math.sin(this.lat0);
	      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
	      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
	      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
	      this.ymf = (this.xmf = this.rq) / this.dd;
	      this.xmf *= this.dd;
	      break;
	    }
	  }
	  else {
	    if (this.mode === this.OBLIQ) {
	      this.sinph0 = Math.sin(this.lat0);
	      this.cosph0 = Math.cos(this.lat0);
	    }
	  }
	}

	/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------------------*/
	function forward$i(p) {

	  /* Forward equations
	      -----------------*/
	  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
	  var lam = p.x;
	  var phi = p.y;

	  lam = adjust_lon(lam - this.long0);
	  if (this.sphere) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    coslam = Math.cos(lam);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      if (y <= EPSLN) {
	        return null;
	      }
	      y = Math.sqrt(2 / y);
	      x = y * cosphi * Math.sin(lam);
	      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        coslam = -coslam;
	      }
	      if (Math.abs(phi + this.lat0) < EPSLN) {
	        return null;
	      }
	      y = FORTPI - phi * 0.5;
	      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
	      x = y * Math.sin(lam);
	      y *= coslam;
	    }
	  }
	  else {
	    sinb = 0;
	    cosb = 0;
	    b = 0;
	    coslam = Math.cos(lam);
	    sinlam = Math.sin(lam);
	    sinphi = Math.sin(phi);
	    q = qsfnz(this.e, sinphi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinb = q / this.qp;
	      cosb = Math.sqrt(1 - sinb * sinb);
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
	      break;
	    case this.EQUIT:
	      b = 1 + cosb * coslam;
	      break;
	    case this.N_POLE:
	      b = HALF_PI + phi;
	      q = this.qp - q;
	      break;
	    case this.S_POLE:
	      b = phi - HALF_PI;
	      q = this.qp + q;
	      break;
	    }
	    if (Math.abs(b) < EPSLN) {
	      return null;
	    }
	    switch (this.mode) {
	    case this.OBLIQ:
	    case this.EQUIT:
	      b = Math.sqrt(2 / b);
	      if (this.mode === this.OBLIQ) {
	        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
	      }
	      else {
	        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
	      }
	      x = this.xmf * b * cosb * sinlam;
	      break;
	    case this.N_POLE:
	    case this.S_POLE:
	      if (q >= 0) {
	        x = (b = Math.sqrt(q)) * sinlam;
	        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
	      }
	      else {
	        x = y = 0;
	      }
	      break;
	    }
	  }

	  p.x = this.a * x + this.x0;
	  p.y = this.a * y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$i(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var x = p.x / this.a;
	  var y = p.y / this.a;
	  var lam, phi, cCe, sCe, q, rho, ab;
	  if (this.sphere) {
	    var cosz = 0,
	      rh, sinz = 0;

	    rh = Math.sqrt(x * x + y * y);
	    phi = rh * 0.5;
	    if (phi > 1) {
	      return null;
	    }
	    phi = 2 * Math.asin(phi);
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      sinz = Math.sin(phi);
	      cosz = Math.cos(phi);
	    }
	    switch (this.mode) {
	    case this.EQUIT:
	      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
	      x *= sinz;
	      y = cosz * rh;
	      break;
	    case this.OBLIQ:
	      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
	      x *= sinz * this.cosph0;
	      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
	      break;
	    case this.N_POLE:
	      y = -y;
	      phi = HALF_PI - phi;
	      break;
	    case this.S_POLE:
	      phi -= HALF_PI;
	      break;
	    }
	    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
	  }
	  else {
	    ab = 0;
	    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
	      x /= this.dd;
	      y *= this.dd;
	      rho = Math.sqrt(x * x + y * y);
	      if (rho < EPSLN) {
	        p.x = this.long0;
	        p.y = this.lat0;
	        return p;
	      }
	      sCe = 2 * Math.asin(0.5 * rho / this.rq);
	      cCe = Math.cos(sCe);
	      x *= (sCe = Math.sin(sCe));
	      if (this.mode === this.OBLIQ) {
	        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
	        q = this.qp * ab;
	        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
	      }
	      else {
	        ab = y * sCe / rho;
	        q = this.qp * ab;
	        y = rho * cCe;
	      }
	    }
	    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
	      if (this.mode === this.N_POLE) {
	        y = -y;
	      }
	      q = (x * x + y * y);
	      if (!q) {
	        p.x = this.long0;
	        p.y = this.lat0;
	        return p;
	      }
	      ab = 1 - q / this.qp;
	      if (this.mode === this.S_POLE) {
	        ab = -ab;
	      }
	    }
	    lam = Math.atan2(x, y);
	    phi = authlat(Math.asin(ab), this.apa);
	  }

	  p.x = adjust_lon(this.long0 + lam);
	  p.y = phi;
	  return p;
	}

	/* determine latitude from authalic latitude */
	var P00 = 0.33333333333333333333;

	var P01 = 0.17222222222222222222;
	var P02 = 0.10257936507936507936;
	var P10 = 0.06388888888888888888;
	var P11 = 0.06640211640211640211;
	var P20 = 0.01641501294219154443;

	function authset(es) {
	  var t;
	  var APA = [];
	  APA[0] = es * P00;
	  t = es * es;
	  APA[0] += t * P01;
	  APA[1] = t * P10;
	  t *= es;
	  APA[0] += t * P02;
	  APA[1] += t * P11;
	  APA[2] = t * P20;
	  return APA;
	}

	function authlat(beta, APA) {
	  var t = beta + beta;
	  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
	}

	var names$i = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
	var laea = {
	  init: init$i,
	  forward: forward$i,
	  inverse: inverse$i,
	  names: names$i,
	  S_POLE: S_POLE,
	  N_POLE: N_POLE,
	  EQUIT: EQUIT,
	  OBLIQ: OBLIQ
	};

	function asinz(x) {
	  if (Math.abs(x) > 1) {
	    x = (x > 1) ? 1 : -1;
	  }
	  return Math.asin(x);
	}

	function init$h() {

	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e3 = Math.sqrt(this.es);

	  this.sin_po = Math.sin(this.lat1);
	  this.cos_po = Math.cos(this.lat1);
	  this.t1 = this.sin_po;
	  this.con = this.sin_po;
	  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat2);
	  this.cos_po = Math.cos(this.lat2);
	  this.t2 = this.sin_po;
	  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
	  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  this.sin_po = Math.sin(this.lat0);
	  this.cos_po = Math.cos(this.lat0);
	  this.t3 = this.sin_po;
	  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

	  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
	    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
	  }
	  else {
	    this.ns0 = this.con;
	  }
	  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
	  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
	}

	/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
	  -------------------------------------------------------------------*/
	function forward$h(p) {

	  var lon = p.x;
	  var lat = p.y;

	  this.sin_phi = Math.sin(lat);
	  this.cos_phi = Math.cos(lat);

	  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
	  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
	  var theta = this.ns0 * adjust_lon(lon - this.long0);
	  var x = rh1 * Math.sin(theta) + this.x0;
	  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$h(p) {
	  var rh1, qs, con, theta, lon, lat;

	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  if (this.ns0 >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }
	  con = rh1 * this.ns0 / this.a;
	  if (this.sphere) {
	    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
	  }
	  else {
	    qs = (this.c - con * con) / this.ns0;
	    lat = this.phi1z(this.e3, qs);
	  }

	  lon = adjust_lon(theta / this.ns0 + this.long0);
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	/* Function to compute phi1, the latitude for the inverse of the
	   Albers Conical Equal-Area projection.
	-------------------------------------------*/
	function phi1z(eccent, qs) {
	  var sinphi, cosphi, con, com, dphi;
	  var phi = asinz(0.5 * qs);
	  if (eccent < EPSLN) {
	    return phi;
	  }

	  var eccnts = eccent * eccent;
	  for (var i = 1; i <= 25; i++) {
	    sinphi = Math.sin(phi);
	    cosphi = Math.cos(phi);
	    con = eccent * sinphi;
	    com = 1 - con * con;
	    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi = phi + dphi;
	    if (Math.abs(dphi) <= 1e-7) {
	      return phi;
	    }
	  }
	  return null;
	}

	var names$h = ["Albers_Conic_Equal_Area", "Albers", "aea"];
	var aea = {
	  init: init$h,
	  forward: forward$h,
	  inverse: inverse$h,
	  names: names$h,
	  phi1z: phi1z
	};

	/*
	  reference:
	    Wolfram Mathworld "Gnomonic Projection"
	    http://mathworld.wolfram.com/GnomonicProjection.html
	    Accessed: 12th November 2009
	  */
	function init$g() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	  // Approximation for projecting points to the horizon (infinity)
	  this.infinity_dist = 1000 * this.a;
	  this.rc = 1;
	}

	/* Gnomonic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$g(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g;
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
	  }
	  else {

	    // Point is in the opposing hemisphere and is unprojectable
	    // We still need to return a reasonable point, so we project
	    // to infinity, on a bearing
	    // equivalent to the northern hemisphere equivalent
	    // This is a reasonable approximation for short shapes and lines that
	    // straddle the horizon.

	    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
	    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$g(p) {
	  var rh; /* Rho */
	  var sinc, cosc;
	  var c;
	  var lon, lat;

	  /* Inverse equations
	      -----------------*/
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  p.x /= this.k0;
	  p.y /= this.k0;

	  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
	    c = Math.atan2(rh, this.rc);
	    sinc = Math.sin(c);
	    cosc = Math.cos(c);

	    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
	    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
	    lon = adjust_lon(this.long0 + lon);
	  }
	  else {
	    lat = this.phic0;
	    lon = 0;
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$g = ["gnom"];
	var gnom = {
	  init: init$g,
	  forward: forward$g,
	  inverse: inverse$g,
	  names: names$g
	};

	function iqsfnz(eccent, q) {
	  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
	  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
	    if (q < 0) {
	      return (-1 * HALF_PI);
	    }
	    else {
	      return HALF_PI;
	    }
	  }
	  //var phi = 0.5* q/(1-eccent*eccent);
	  var phi = Math.asin(0.5 * q);
	  var dphi;
	  var sin_phi;
	  var cos_phi;
	  var con;
	  for (var i = 0; i < 30; i++) {
	    sin_phi = Math.sin(phi);
	    cos_phi = Math.cos(phi);
	    con = eccent * sin_phi;
	    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
	    phi += dphi;
	    if (Math.abs(dphi) <= 0.0000000001) {
	      return phi;
	    }
	  }

	  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
	  return NaN;
	}

	/*
	  reference:
	    "Cartographic Projection Procedures for the UNIX Environment-
	    A User's Manual" by Gerald I. Evenden,
	    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
	*/
	function init$f() {
	  //no-op
	  if (!this.sphere) {
	    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
	  }
	}

	/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	function forward$f(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  if (this.sphere) {
	    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
	    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
	  }
	  else {
	    var qs = qsfnz(this.e, Math.sin(lat));
	    x = this.x0 + this.a * this.k0 * dlon;
	    y = this.y0 + this.a * qs * 0.5 / this.k0;
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	function inverse$f(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var lon, lat;

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
	    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
	  }
	  else {
	    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
	    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$f = ["cea"];
	var cea = {
	  init: init$f,
	  forward: forward$f,
	  inverse: inverse$f,
	  names: names$f
	};

	function init$e() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

	  this.rc = Math.cos(this.lat_ts);
	}

	// forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$e(p) {

	  var lon = p.x;
	  var lat = p.y;

	  var dlon = adjust_lon(lon - this.long0);
	  var dlat = adjust_lat(lat - this.lat0);
	  p.x = this.x0 + (this.a * dlon * this.rc);
	  p.y = this.y0 + (this.a * dlat);
	  return p;
	}

	// inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$e(p) {

	  var x = p.x;
	  var y = p.y;

	  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
	  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
	  return p;
	}

	var names$e = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
	var eqc = {
	  init: init$e,
	  forward: forward$e,
	  inverse: inverse$e,
	  names: names$e
	};

	var MAX_ITER$1 = 20;

	function init$d() {
	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);
	  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
	}

	/* Polyconic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$d(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var x, y, el;
	  var dlon = adjust_lon(lon - this.long0);
	  el = dlon * Math.sin(lat);
	  if (this.sphere) {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.a * this.lat0;
	    }
	    else {
	      x = this.a * Math.sin(el) / Math.tan(lat);
	      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
	    }
	  }
	  else {
	    if (Math.abs(lat) <= EPSLN) {
	      x = this.a * dlon;
	      y = -1 * this.ml0;
	    }
	    else {
	      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
	      x = nl * Math.sin(el);
	      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
	    }

	  }
	  p.x = x + this.x0;
	  p.y = y + this.y0;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$d(p) {
	  var lon, lat, x, y, i;
	  var al, bl;
	  var phi, dphi;
	  x = p.x - this.x0;
	  y = p.y - this.y0;

	  if (this.sphere) {
	    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
	      lon = adjust_lon(x / this.a + this.long0);
	      lat = 0;
	    }
	    else {
	      al = this.lat0 + y / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var tanphi;
	      for (i = MAX_ITER$1; i; --i) {
	        tanphi = Math.tan(phi);
	        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
	        phi += dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }
	      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
	    }
	  }
	  else {
	    if (Math.abs(y + this.ml0) <= EPSLN) {
	      lat = 0;
	      lon = adjust_lon(this.long0 + x / this.a);
	    }
	    else {

	      al = (this.ml0 + y) / this.a;
	      bl = x * x / this.a / this.a + al * al;
	      phi = al;
	      var cl, mln, mlnp, ma;
	      var con;
	      for (i = MAX_ITER$1; i; --i) {
	        con = this.e * Math.sin(phi);
	        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
	        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
	        ma = mln / this.a;
	        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
	        phi -= dphi;
	        if (Math.abs(dphi) <= EPSLN) {
	          lat = phi;
	          break;
	        }
	      }

	      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
	      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
	      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
	    }
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$d = ["Polyconic", "poly"];
	var poly = {
	  init: init$d,
	  forward: forward$d,
	  inverse: inverse$d,
	  names: names$d
	};

	function init$c() {
	  this.A = [];
	  this.A[1] = 0.6399175073;
	  this.A[2] = -0.1358797613;
	  this.A[3] = 0.063294409;
	  this.A[4] = -0.02526853;
	  this.A[5] = 0.0117879;
	  this.A[6] = -0.0055161;
	  this.A[7] = 0.0026906;
	  this.A[8] = -0.001333;
	  this.A[9] = 0.00067;
	  this.A[10] = -0.00034;

	  this.B_re = [];
	  this.B_im = [];
	  this.B_re[1] = 0.7557853228;
	  this.B_im[1] = 0;
	  this.B_re[2] = 0.249204646;
	  this.B_im[2] = 0.003371507;
	  this.B_re[3] = -0.001541739;
	  this.B_im[3] = 0.041058560;
	  this.B_re[4] = -0.10162907;
	  this.B_im[4] = 0.01727609;
	  this.B_re[5] = -0.26623489;
	  this.B_im[5] = -0.36249218;
	  this.B_re[6] = -0.6870983;
	  this.B_im[6] = -1.1651967;

	  this.C_re = [];
	  this.C_im = [];
	  this.C_re[1] = 1.3231270439;
	  this.C_im[1] = 0;
	  this.C_re[2] = -0.577245789;
	  this.C_im[2] = -0.007809598;
	  this.C_re[3] = 0.508307513;
	  this.C_im[3] = -0.112208952;
	  this.C_re[4] = -0.15094762;
	  this.C_im[4] = 0.18200602;
	  this.C_re[5] = 1.01418179;
	  this.C_im[5] = 1.64497696;
	  this.C_re[6] = 1.9660549;
	  this.C_im[6] = 2.5127645;

	  this.D = [];
	  this.D[1] = 1.5627014243;
	  this.D[2] = 0.5185406398;
	  this.D[3] = -0.03333098;
	  this.D[4] = -0.1052906;
	  this.D[5] = -0.0368594;
	  this.D[6] = 0.007317;
	  this.D[7] = 0.01220;
	  this.D[8] = 0.00394;
	  this.D[9] = -0.0013;
	}

	/**
	    New Zealand Map Grid Forward  - long/lat to x/y
	    long/lat in radians
	  */
	function forward$c(p) {
	  var n;
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lat = lat - this.lat0;
	  var delta_lon = lon - this.long0;

	  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
	  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
	  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
	  var d_lambda = delta_lon;
	  var d_phi_n = 1; // d_phi^0

	  var d_psi = 0;
	  for (n = 1; n <= 10; n++) {
	    d_phi_n = d_phi_n * d_phi;
	    d_psi = d_psi + this.A[n] * d_phi_n;
	  }

	  // 2. Calculate theta
	  var th_re = d_psi;
	  var th_im = d_lambda;

	  // 3. Calculate z
	  var th_n_re = 1;
	  var th_n_im = 0; // theta^0
	  var th_n_re1;
	  var th_n_im1;

	  var z_re = 0;
	  var z_im = 0;
	  for (n = 1; n <= 6; n++) {
	    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	    th_n_re = th_n_re1;
	    th_n_im = th_n_im1;
	    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
	    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
	  }

	  // 4. Calculate easting and northing
	  p.x = (z_im * this.a) + this.x0;
	  p.y = (z_re * this.a) + this.y0;

	  return p;
	}

	/**
	    New Zealand Map Grid Inverse  -  x/y to long/lat
	  */
	function inverse$c(p) {
	  var n;
	  var x = p.x;
	  var y = p.y;

	  var delta_x = x - this.x0;
	  var delta_y = y - this.y0;

	  // 1. Calculate z
	  var z_re = delta_y / this.a;
	  var z_im = delta_x / this.a;

	  // 2a. Calculate theta - first approximation gives km accuracy
	  var z_n_re = 1;
	  var z_n_im = 0; // z^0
	  var z_n_re1;
	  var z_n_im1;

	  var th_re = 0;
	  var th_im = 0;
	  for (n = 1; n <= 6; n++) {
	    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
	    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
	    z_n_re = z_n_re1;
	    z_n_im = z_n_im1;
	    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
	    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
	  }

	  // 2b. Iterate to refine the accuracy of the calculation
	  //        0 iterations gives km accuracy
	  //        1 iteration gives m accuracy -- good enough for most mapping applications
	  //        2 iterations bives mm accuracy
	  for (var i = 0; i < this.iterations; i++) {
	    var th_n_re = th_re;
	    var th_n_im = th_im;
	    var th_n_re1;
	    var th_n_im1;

	    var num_re = z_re;
	    var num_im = z_im;
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    th_n_re = 1;
	    th_n_im = 0;
	    var den_re = this.B_re[1];
	    var den_im = this.B_im[1];
	    for (n = 2; n <= 6; n++) {
	      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
	      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
	      th_n_re = th_n_re1;
	      th_n_im = th_n_im1;
	      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
	      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
	    }

	    // Complex division
	    var den2 = den_re * den_re + den_im * den_im;
	    th_re = (num_re * den_re + num_im * den_im) / den2;
	    th_im = (num_im * den_re - num_re * den_im) / den2;
	  }

	  // 3. Calculate d_phi              ...                                    // and d_lambda
	  var d_psi = th_re;
	  var d_lambda = th_im;
	  var d_psi_n = 1; // d_psi^0

	  var d_phi = 0;
	  for (n = 1; n <= 9; n++) {
	    d_psi_n = d_psi_n * d_psi;
	    d_phi = d_phi + this.D[n] * d_psi_n;
	  }

	  // 4. Calculate latitude and longitude
	  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
	  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
	  var lon = this.long0 + d_lambda;

	  p.x = lon;
	  p.y = lat;

	  return p;
	}

	var names$c = ["New_Zealand_Map_Grid", "nzmg"];
	var nzmg = {
	  init: init$c,
	  forward: forward$c,
	  inverse: inverse$c,
	  names: names$c
	};

	/*
	  reference
	    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
	    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
	  */


	/* Initialize the Miller Cylindrical projection
	  -------------------------------------------*/
	function init$b() {
	  //no-op
	}

	/* Miller Cylindrical forward equations--mapping lat,long to x,y
	    ------------------------------------------------------------*/
	function forward$b(p) {
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x = this.x0 + this.a * dlon;
	  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Miller Cylindrical inverse equations--mapping x,y to lat/long
	    ------------------------------------------------------------*/
	function inverse$b(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;

	  var lon = adjust_lon(this.long0 + p.x / this.a);
	  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$b = ["Miller_Cylindrical", "mill"];
	var mill = {
	  init: init$b,
	  forward: forward$b,
	  inverse: inverse$b,
	  names: names$b
	};

	var MAX_ITER = 20;


	function init$a() {
	  /* Place parameters in static storage for common use
	    -------------------------------------------------*/


	  if (!this.sphere) {
	    this.en = pj_enfn(this.es);
	  }
	  else {
	    this.n = 1;
	    this.m = 0;
	    this.es = 0;
	    this.C_y = Math.sqrt((this.m + 1) / this.n);
	    this.C_x = this.C_y / (this.m + 1);
	  }

	}

	/* Sinusoidal forward equations--mapping lat,long to x,y
	  -----------------------------------------------------*/
	function forward$a(p) {
	  var x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	    -----------------*/
	  lon = adjust_lon(lon - this.long0);

	  if (this.sphere) {
	    if (!this.m) {
	      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
	    }
	    else {
	      var k = this.n * Math.sin(lat);
	      for (var i = MAX_ITER; i; --i) {
	        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
	        lat -= V;
	        if (Math.abs(V) < EPSLN) {
	          break;
	        }
	      }
	    }
	    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
	    y = this.a * this.C_y * lat;

	  }
	  else {

	    var s = Math.sin(lat);
	    var c = Math.cos(lat);
	    y = this.a * pj_mlfn(lat, s, c, this.en);
	    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
	  }

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$a(p) {
	  var lat, temp, lon, s;

	  p.x -= this.x0;
	  lon = p.x / this.a;
	  p.y -= this.y0;
	  lat = p.y / this.a;

	  if (this.sphere) {
	    lat /= this.C_y;
	    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
	    if (this.m) {
	      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
	    }
	    else if (this.n !== 1) {
	      lat = asinz(Math.sin(lat) / this.n);
	    }
	    lon = adjust_lon(lon + this.long0);
	    lat = adjust_lat(lat);
	  }
	  else {
	    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
	    s = Math.abs(lat);
	    if (s < HALF_PI) {
	      s = Math.sin(lat);
	      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
	      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
	      lon = adjust_lon(temp);
	    }
	    else if ((s - EPSLN) < HALF_PI) {
	      lon = this.long0;
	    }
	  }
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$a = ["Sinusoidal", "sinu"];
	var sinu = {
	  init: init$a,
	  forward: forward$a,
	  inverse: inverse$a,
	  names: names$a
	};

	function init$9() {}
	/* Mollweide forward equations--mapping lat,long to x,y
	    ----------------------------------------------------*/
	function forward$9(p) {

	  /* Forward equations
	      -----------------*/
	  var lon = p.x;
	  var lat = p.y;

	  var delta_lon = adjust_lon(lon - this.long0);
	  var theta = lat;
	  var con = Math.PI * Math.sin(lat);

	  /* Iterate using the Newton-Raphson method to find theta
	      -----------------------------------------------------*/
	  while (true) {
	    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
	    theta += delta_theta;
	    if (Math.abs(delta_theta) < EPSLN) {
	      break;
	    }
	  }
	  theta /= 2;

	  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
	       this is done here because of precision problems with "cos(theta)"
	       --------------------------------------------------------------------------*/
	  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
	    delta_lon = 0;
	  }
	  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
	  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$9(p) {
	  var theta;
	  var arg;

	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  arg = p.y / (1.4142135623731 * this.a);

	  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
	       a number very close to one is used instead.
	       -------------------------------------------------------------------*/
	  if (Math.abs(arg) > 0.999999999999) {
	    arg = 0.999999999999;
	  }
	  theta = Math.asin(arg);
	  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
	  if (lon < (-Math.PI)) {
	    lon = -Math.PI;
	  }
	  if (lon > Math.PI) {
	    lon = Math.PI;
	  }
	  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
	  if (Math.abs(arg) > 1) {
	    arg = 1;
	  }
	  var lat = Math.asin(arg);

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$9 = ["Mollweide", "moll"];
	var moll = {
	  init: init$9,
	  forward: forward$9,
	  inverse: inverse$9,
	  names: names$9
	};

	function init$8() {

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  // Standard Parallels cannot be equal and on opposite sides of the equator
	  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
	    return;
	  }
	  this.lat2 = this.lat2 || this.lat1;
	  this.temp = this.b / this.a;
	  this.es = 1 - Math.pow(this.temp, 2);
	  this.e = Math.sqrt(this.es);
	  this.e0 = e0fn(this.es);
	  this.e1 = e1fn(this.es);
	  this.e2 = e2fn(this.es);
	  this.e3 = e3fn(this.es);

	  this.sinphi = Math.sin(this.lat1);
	  this.cosphi = Math.cos(this.lat1);

	  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
	  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

	  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
	    this.ns = this.sinphi;
	  }
	  else {
	    this.sinphi = Math.sin(this.lat2);
	    this.cosphi = Math.cos(this.lat2);
	    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
	    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
	    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
	  }
	  this.g = this.ml1 + this.ms1 / this.ns;
	  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
	  this.rh = this.a * (this.g - this.ml0);
	}

	/* Equidistant Conic forward equations--mapping lat,long to x,y
	  -----------------------------------------------------------*/
	function forward$8(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var rh1;

	  /* Forward equations
	      -----------------*/
	  if (this.sphere) {
	    rh1 = this.a * (this.g - lat);
	  }
	  else {
	    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
	    rh1 = this.a * (this.g - ml);
	  }
	  var theta = this.ns * adjust_lon(lon - this.long0);
	  var x = this.x0 + rh1 * Math.sin(theta);
	  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Inverse equations
	  -----------------*/
	function inverse$8(p) {
	  p.x -= this.x0;
	  p.y = this.rh - p.y + this.y0;
	  var con, rh1, lat, lon;
	  if (this.ns >= 0) {
	    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
	    con = 1;
	  }
	  else {
	    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
	    con = -1;
	  }
	  var theta = 0;
	  if (rh1 !== 0) {
	    theta = Math.atan2(con * p.x, con * p.y);
	  }

	  if (this.sphere) {
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    lat = adjust_lat(this.g - rh1 / this.a);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    var ml = this.g - rh1 / this.a;
	    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
	    lon = adjust_lon(this.long0 + theta / this.ns);
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }

	}

	var names$8 = ["Equidistant_Conic", "eqdc"];
	var eqdc = {
	  init: init$8,
	  forward: forward$8,
	  inverse: inverse$8,
	  names: names$8
	};

	/* Initialize the Van Der Grinten projection
	  ----------------------------------------*/
	function init$7() {
	  //this.R = 6370997; //Radius of earth
	  this.R = this.a;
	}

	function forward$7(p) {

	  var lon = p.x;
	  var lat = p.y;

	  /* Forward equations
	    -----------------*/
	  var dlon = adjust_lon(lon - this.long0);
	  var x, y;

	  if (Math.abs(lat) <= EPSLN) {
	    x = this.x0 + this.R * dlon;
	    y = this.y0;
	  }
	  var theta = asinz(2 * Math.abs(lat / Math.PI));
	  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
	    x = this.x0;
	    if (lat >= 0) {
	      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
	    }
	    else {
	      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
	    }
	    //  return(OK);
	  }
	  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
	  var asq = al * al;
	  var sinth = Math.sin(theta);
	  var costh = Math.cos(theta);

	  var g = costh / (sinth + costh - 1);
	  var gsq = g * g;
	  var m = g * (2 / sinth - 1);
	  var msq = m * m;
	  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
	  if (dlon < 0) {
	    con = -con;
	  }
	  x = this.x0 + con;
	  //con = Math.abs(con / (Math.PI * this.R));
	  var q = asq + g;
	  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
	  if (lat >= 0) {
	    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 + con;
	  }
	  else {
	    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
	    y = this.y0 - con;
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	/* Van Der Grinten inverse equations--mapping x,y to lat/long
	  ---------------------------------------------------------*/
	function inverse$7(p) {
	  var lon, lat;
	  var xx, yy, xys, c1, c2, c3;
	  var a1;
	  var m1;
	  var con;
	  var th1;
	  var d;

	  /* inverse equations
	    -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  con = Math.PI * this.R;
	  xx = p.x / con;
	  yy = p.y / con;
	  xys = xx * xx + yy * yy;
	  c1 = -Math.abs(yy) * (1 + xys);
	  c2 = c1 - 2 * yy * yy + xx * xx;
	  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
	  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
	  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
	  m1 = 2 * Math.sqrt(-a1 / 3);
	  con = ((3 * d) / a1) / m1;
	  if (Math.abs(con) > 1) {
	    if (con >= 0) {
	      con = 1;
	    }
	    else {
	      con = -1;
	    }
	  }
	  th1 = Math.acos(con) / 3;
	  if (p.y >= 0) {
	    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }
	  else {
	    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
	  }

	  if (Math.abs(xx) < EPSLN) {
	    lon = this.long0;
	  }
	  else {
	    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
	  }

	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$7 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
	var vandg = {
	  init: init$7,
	  forward: forward$7,
	  inverse: inverse$7,
	  names: names$7
	};

	function init$6() {
	  this.sin_p12 = Math.sin(this.lat0);
	  this.cos_p12 = Math.cos(this.lat0);
	}

	function forward$6(p) {
	  var lon = p.x;
	  var lat = p.y;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var dlon = adjust_lon(lon - this.long0);
	  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
	  if (this.sphere) {
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
	      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
	      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //default case
	      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
	      c = Math.acos(cos_c);
	      kp = c ? c / Math.sin(c) : 1;
	      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
	      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
	      return p;
	    }
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
	      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South Pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
	      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
	      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
	      return p;
	    }
	    else {
	      //Default case
	      tanphi = sinphi / cosphi;
	      Nl1 = gN(this.a, this.e, this.sin_p12);
	      Nl = gN(this.a, this.e, sinphi);
	      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
	      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
	      if (Az === 0) {
	        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
	        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
	      }
	      else {
	        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
	      }
	      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
	      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
	      GH = G * H;
	      Hs = H * H;
	      s2 = s * s;
	      s3 = s2 * s;
	      s4 = s3 * s;
	      s5 = s4 * s;
	      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
	      p.x = this.x0 + c * Math.sin(Az);
	      p.y = this.y0 + c * Math.cos(Az);
	      return p;
	    }
	  }


	}

	function inverse$6(p) {
	  p.x -= this.x0;
	  p.y -= this.y0;
	  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
	  if (this.sphere) {
	    rh = Math.sqrt(p.x * p.x + p.y * p.y);
	    if (rh > (2 * HALF_PI * this.a)) {
	      return;
	    }
	    z = rh / this.a;

	    sinz = Math.sin(z);
	    cosz = Math.cos(z);

	    lon = this.long0;
	    if (Math.abs(rh) <= EPSLN) {
	      lat = this.lat0;
	    }
	    else {
	      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
	      con = Math.abs(this.lat0) - HALF_PI;
	      if (Math.abs(con) <= EPSLN) {
	        if (this.lat0 >= 0) {
	          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	        }
	        else {
	          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	        }
	      }
	      else {
	        /*con = cosz - this.sin_p12 * Math.sin(lat);
	        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
	          //no-op, just keep the lon value as is
	        } else {
	          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
	          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
	        }*/
	        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
	      }
	    }

	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  else {
	    e0 = e0fn(this.es);
	    e1 = e1fn(this.es);
	    e2 = e2fn(this.es);
	    e3 = e3fn(this.es);
	    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
	      //North pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = Mlp - rh;
	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
	      //South pole case
	      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      M = rh - Mlp;

	      lat = imlfn(M / this.a, e0, e1, e2, e3);
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	    else {
	      //default case
	      rh = Math.sqrt(p.x * p.x + p.y * p.y);
	      Az = Math.atan2(p.x, p.y);
	      N1 = gN(this.a, this.e, this.sin_p12);
	      cosAz = Math.cos(Az);
	      tmp = this.e * this.cos_p12 * cosAz;
	      A = -tmp * tmp / (1 - this.es);
	      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
	      D = rh / N1;
	      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
	      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
	      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
	      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
	      sinpsi = Math.sin(psi);
	      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
	      p.x = lon;
	      p.y = lat;
	      return p;
	    }
	  }

	}

	var names$6 = ["Azimuthal_Equidistant", "aeqd"];
	var aeqd = {
	  init: init$6,
	  forward: forward$6,
	  inverse: inverse$6,
	  names: names$6
	};

	function init$5() {
	  //double temp;      /* temporary variable    */

	  /* Place parameters in static storage for common use
	      -------------------------------------------------*/
	  this.sin_p14 = Math.sin(this.lat0);
	  this.cos_p14 = Math.cos(this.lat0);
	}

	/* Orthographic forward equations--mapping lat,long to x,y
	    ---------------------------------------------------*/
	function forward$5(p) {
	  var sinphi, cosphi; /* sin and cos value        */
	  var dlon; /* delta longitude value      */
	  var coslon; /* cos of longitude        */
	  var ksp; /* scale factor          */
	  var g, x, y;
	  var lon = p.x;
	  var lat = p.y;
	  /* Forward equations
	      -----------------*/
	  dlon = adjust_lon(lon - this.long0);

	  sinphi = Math.sin(lat);
	  cosphi = Math.cos(lat);

	  coslon = Math.cos(dlon);
	  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
	  ksp = 1;
	  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
	    x = this.a * ksp * cosphi * Math.sin(dlon);
	    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
	  }
	  p.x = x;
	  p.y = y;
	  return p;
	}

	function inverse$5(p) {
	  var rh; /* height above ellipsoid      */
	  var z; /* angle          */
	  var sinz, cosz; /* sin of z and cos of z      */
	  var con;
	  var lon, lat;
	  /* Inverse equations
	      -----------------*/
	  p.x -= this.x0;
	  p.y -= this.y0;
	  rh = Math.sqrt(p.x * p.x + p.y * p.y);
	  z = asinz(rh / this.a);

	  sinz = Math.sin(z);
	  cosz = Math.cos(z);

	  lon = this.long0;
	  if (Math.abs(rh) <= EPSLN) {
	    lat = this.lat0;
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
	  con = Math.abs(this.lat0) - HALF_PI;
	  if (Math.abs(con) <= EPSLN) {
	    if (this.lat0 >= 0) {
	      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
	    }
	    else {
	      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
	    }
	    p.x = lon;
	    p.y = lat;
	    return p;
	  }
	  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
	  p.x = lon;
	  p.y = lat;
	  return p;
	}

	var names$5 = ["ortho"];
	var ortho = {
	  init: init$5,
	  forward: forward$5,
	  inverse: inverse$5,
	  names: names$5
	};

	// QSC projection rewritten from the original PROJ4

	/* constants */
	var FACE_ENUM = {
	    FRONT: 1,
	    RIGHT: 2,
	    BACK: 3,
	    LEFT: 4,
	    TOP: 5,
	    BOTTOM: 6
	};

	var AREA_ENUM = {
	    AREA_0: 1,
	    AREA_1: 2,
	    AREA_2: 3,
	    AREA_3: 4
	};

	function init$4() {

	  this.x0 = this.x0 || 0;
	  this.y0 = this.y0 || 0;
	  this.lat0 = this.lat0 || 0;
	  this.long0 = this.long0 || 0;
	  this.lat_ts = this.lat_ts || 0;
	  this.title = this.title || "Quadrilateralized Spherical Cube";

	  /* Determine the cube face from the center of projection. */
	  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
	    this.face = FACE_ENUM.TOP;
	  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
	    this.face = FACE_ENUM.BOTTOM;
	  } else if (Math.abs(this.long0) <= FORTPI) {
	    this.face = FACE_ENUM.FRONT;
	  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
	    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
	  } else {
	    this.face = FACE_ENUM.BACK;
	  }

	  /* Fill in useful values for the ellipsoid <-> sphere shift
	   * described in [LK12]. */
	  if (this.es !== 0) {
	    this.one_minus_f = 1 - (this.a - this.b) / this.a;
	    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
	  }
	}

	// QSC forward equations--mapping lat,long to x,y
	// -----------------------------------------------------------------
	function forward$4(p) {
	  var xy = {x: 0, y: 0};
	  var lat, lon;
	  var theta, phi;
	  var t, mu;
	  /* nu; */
	  var area = {value: 0};

	  // move lon according to projection's lon
	  p.x -= this.long0;

	  /* Convert the geodetic latitude to a geocentric latitude.
	   * This corresponds to the shift from the ellipsoid to the sphere
	   * described in [LK12]. */
	  if (this.es !== 0) {//if (P->es != 0) {
	    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
	  } else {
	    lat = p.y;
	  }

	  /* Convert the input lat, lon into theta, phi as used by QSC.
	   * This depends on the cube face and the area on it.
	   * For the top and bottom face, we can compute theta and phi
	   * directly from phi, lam. For the other faces, we must use
	   * unit sphere cartesian coordinates as an intermediate step. */
	  lon = p.x; //lon = lp.lam;
	  if (this.face === FACE_ENUM.TOP) {
	    phi = HALF_PI - lat;
	    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	      theta = lon - HALF_PI;
	    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_1;
	      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
	    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = lon + HALF_PI;
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta = lon;
	    }
	  } else if (this.face === FACE_ENUM.BOTTOM) {
	    phi = HALF_PI + lat;
	    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	      theta = -lon + HALF_PI;
	    } else if (lon < FORTPI && lon >= -FORTPI) {
	      area.value = AREA_ENUM.AREA_1;
	      theta = -lon;
	    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = -lon - HALF_PI;
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
	    }
	  } else {
	    var q, r, s;
	    var sinlat, coslat;
	    var sinlon, coslon;

	    if (this.face === FACE_ENUM.RIGHT) {
	      lon = qsc_shift_lon_origin(lon, +HALF_PI);
	    } else if (this.face === FACE_ENUM.BACK) {
	      lon = qsc_shift_lon_origin(lon, +SPI);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      lon = qsc_shift_lon_origin(lon, -HALF_PI);
	    }
	    sinlat = Math.sin(lat);
	    coslat = Math.cos(lat);
	    sinlon = Math.sin(lon);
	    coslon = Math.cos(lon);
	    q = coslat * coslon;
	    r = coslat * sinlon;
	    s = sinlat;

	    if (this.face === FACE_ENUM.FRONT) {
	      phi = Math.acos(q);
	      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
	    } else if (this.face === FACE_ENUM.RIGHT) {
	      phi = Math.acos(r);
	      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
	    } else if (this.face === FACE_ENUM.BACK) {
	      phi = Math.acos(-q);
	      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      phi = Math.acos(-r);
	      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
	    } else {
	      /* Impossible */
	      phi = theta = 0;
	      area.value = AREA_ENUM.AREA_0;
	    }
	  }

	  /* Compute mu and nu for the area of definition.
	   * For mu, see Eq. (3-21) in [OL76], but note the typos:
	   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
	  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
	  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

	  /* Apply the result to the real area. */
	  if (area.value === AREA_ENUM.AREA_1) {
	    mu += HALF_PI;
	  } else if (area.value === AREA_ENUM.AREA_2) {
	    mu += SPI;
	  } else if (area.value === AREA_ENUM.AREA_3) {
	    mu += 1.5 * SPI;
	  }

	  /* Now compute x, y from mu and nu */
	  xy.x = t * Math.cos(mu);
	  xy.y = t * Math.sin(mu);
	  xy.x = xy.x * this.a + this.x0;
	  xy.y = xy.y * this.a + this.y0;

	  p.x = xy.x;
	  p.y = xy.y;
	  return p;
	}

	// QSC inverse equations--mapping x,y to lat/long
	// -----------------------------------------------------------------
	function inverse$4(p) {
	  var lp = {lam: 0, phi: 0};
	  var mu, nu, cosmu, tannu;
	  var tantheta, theta, cosphi, phi;
	  var t;
	  var area = {value: 0};

	  /* de-offset */
	  p.x = (p.x - this.x0) / this.a;
	  p.y = (p.y - this.y0) / this.a;

	  /* Convert the input x, y to the mu and nu angles as used by QSC.
	   * This depends on the area of the cube face. */
	  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
	  mu = Math.atan2(p.y, p.x);
	  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
	    area.value = AREA_ENUM.AREA_0;
	  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
	    area.value = AREA_ENUM.AREA_1;
	    mu -= HALF_PI;
	  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
	    area.value = AREA_ENUM.AREA_2;
	    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
	  } else {
	    area.value = AREA_ENUM.AREA_3;
	    mu += HALF_PI;
	  }

	  /* Compute phi and theta for the area of definition.
	   * The inverse projection is not described in the original paper, but some
	   * good hints can be found here (as of 2011-12-14):
	   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
	   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
	  t = (SPI / 12) * Math.tan(mu);
	  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
	  theta = Math.atan(tantheta);
	  cosmu = Math.cos(mu);
	  tannu = Math.tan(nu);
	  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
	  if (cosphi < -1) {
	    cosphi = -1;
	  } else if (cosphi > +1) {
	    cosphi = +1;
	  }

	  /* Apply the result to the real area on the cube face.
	   * For the top and bottom face, we can compute phi and lam directly.
	   * For the other faces, we must use unit sphere cartesian coordinates
	   * as an intermediate step. */
	  if (this.face === FACE_ENUM.TOP) {
	    phi = Math.acos(cosphi);
	    lp.phi = HALF_PI - phi;
	    if (area.value === AREA_ENUM.AREA_0) {
	      lp.lam = theta + HALF_PI;
	    } else if (area.value === AREA_ENUM.AREA_1) {
	      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      lp.lam = theta - HALF_PI;
	    } else /* area.value == AREA_ENUM.AREA_3 */ {
	      lp.lam = theta;
	    }
	  } else if (this.face === FACE_ENUM.BOTTOM) {
	    phi = Math.acos(cosphi);
	    lp.phi = phi - HALF_PI;
	    if (area.value === AREA_ENUM.AREA_0) {
	      lp.lam = -theta + HALF_PI;
	    } else if (area.value === AREA_ENUM.AREA_1) {
	      lp.lam = -theta;
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      lp.lam = -theta - HALF_PI;
	    } else /* area.value == AREA_ENUM.AREA_3 */ {
	      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
	    }
	  } else {
	    /* Compute phi and lam via cartesian unit sphere coordinates. */
	    var q, r, s;
	    q = cosphi;
	    t = q * q;
	    if (t >= 1) {
	      s = 0;
	    } else {
	      s = Math.sqrt(1 - t) * Math.sin(theta);
	    }
	    t += s * s;
	    if (t >= 1) {
	      r = 0;
	    } else {
	      r = Math.sqrt(1 - t);
	    }
	    /* Rotate q,r,s into the correct area. */
	    if (area.value === AREA_ENUM.AREA_1) {
	      t = r;
	      r = -s;
	      s = t;
	    } else if (area.value === AREA_ENUM.AREA_2) {
	      r = -r;
	      s = -s;
	    } else if (area.value === AREA_ENUM.AREA_3) {
	      t = r;
	      r = s;
	      s = -t;
	    }
	    /* Rotate q,r,s into the correct cube face. */
	    if (this.face === FACE_ENUM.RIGHT) {
	      t = q;
	      q = -r;
	      r = t;
	    } else if (this.face === FACE_ENUM.BACK) {
	      q = -q;
	      r = -r;
	    } else if (this.face === FACE_ENUM.LEFT) {
	      t = q;
	      q = r;
	      r = -t;
	    }
	    /* Now compute phi and lam from the unit sphere coordinates. */
	    lp.phi = Math.acos(-s) - HALF_PI;
	    lp.lam = Math.atan2(r, q);
	    if (this.face === FACE_ENUM.RIGHT) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
	    } else if (this.face === FACE_ENUM.BACK) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
	    } else if (this.face === FACE_ENUM.LEFT) {
	      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
	    }
	  }

	  /* Apply the shift from the sphere to the ellipsoid as described
	   * in [LK12]. */
	  if (this.es !== 0) {
	    var invert_sign;
	    var tanphi, xa;
	    invert_sign = (lp.phi < 0 ? 1 : 0);
	    tanphi = Math.tan(lp.phi);
	    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
	    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
	    if (invert_sign) {
	      lp.phi = -lp.phi;
	    }
	  }

	  lp.lam += this.long0;
	  p.x = lp.lam;
	  p.y = lp.phi;
	  return p;
	}

	/* Helper function for forward projection: compute the theta angle
	 * and determine the area number. */
	function qsc_fwd_equat_face_theta(phi, y, x, area) {
	  var theta;
	  if (phi < EPSLN) {
	    area.value = AREA_ENUM.AREA_0;
	    theta = 0.0;
	  } else {
	    theta = Math.atan2(y, x);
	    if (Math.abs(theta) <= FORTPI) {
	      area.value = AREA_ENUM.AREA_0;
	    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
	      area.value = AREA_ENUM.AREA_1;
	      theta -= HALF_PI;
	    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
	      area.value = AREA_ENUM.AREA_2;
	      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
	    } else {
	      area.value = AREA_ENUM.AREA_3;
	      theta += HALF_PI;
	    }
	  }
	  return theta;
	}

	/* Helper function: shift the longitude. */
	function qsc_shift_lon_origin(lon, offset) {
	  var slon = lon + offset;
	  if (slon < -SPI) {
	    slon += TWO_PI;
	  } else if (slon > +SPI) {
	    slon -= TWO_PI;
	  }
	  return slon;
	}

	var names$4 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
	var qsc = {
	  init: init$4,
	  forward: forward$4,
	  inverse: inverse$4,
	  names: names$4
	};

	// Robinson projection

	var COEFS_X = [
	    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
	    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
	    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
	    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
	    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
	    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
	    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
	    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
	    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
	    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
	    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
	    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
	    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
	    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
	    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
	    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
	    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
	    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
	    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
	];

	var COEFS_Y = [
	    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
	    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
	    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
	    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
	    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
	    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
	    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
	    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
	    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
	    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
	    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
	    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
	    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
	    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
	    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
	    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
	    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
	    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
	    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
	];

	var FXC = 0.8487;
	var FYC = 1.3523;
	var C1 = R2D/5; // rad to 5-degree interval
	var RC1 = 1/C1;
	var NODES = 18;

	var poly3_val = function(coefs, x) {
	    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
	};

	var poly3_der = function(coefs, x) {
	    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
	};

	function newton_rapshon(f_df, start, max_err, iters) {
	    var x = start;
	    for (; iters; --iters) {
	        var upd = f_df(x);
	        x -= upd;
	        if (Math.abs(upd) < max_err) {
	            break;
	        }
	    }
	    return x;
	}

	function init$3() {
	    this.x0 = this.x0 || 0;
	    this.y0 = this.y0 || 0;
	    this.long0 = this.long0 || 0;
	    this.es = 0;
	    this.title = this.title || "Robinson";
	}

	function forward$3(ll) {
	    var lon = adjust_lon(ll.x - this.long0);

	    var dphi = Math.abs(ll.y);
	    var i = Math.floor(dphi * C1);
	    if (i < 0) {
	        i = 0;
	    } else if (i >= NODES) {
	        i = NODES - 1;
	    }
	    dphi = R2D * (dphi - RC1 * i);
	    var xy = {
	        x: poly3_val(COEFS_X[i], dphi) * lon,
	        y: poly3_val(COEFS_Y[i], dphi)
	    };
	    if (ll.y < 0) {
	        xy.y = -xy.y;
	    }

	    xy.x = xy.x * this.a * FXC + this.x0;
	    xy.y = xy.y * this.a * FYC + this.y0;
	    return xy;
	}

	function inverse$3(xy) {
	    var ll = {
	        x: (xy.x - this.x0) / (this.a * FXC),
	        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
	    };

	    if (ll.y >= 1) { // pathologic case
	        ll.x /= COEFS_X[NODES][0];
	        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
	    } else {
	        // find table interval
	        var i = Math.floor(ll.y * NODES);
	        if (i < 0) {
	            i = 0;
	        } else if (i >= NODES) {
	            i = NODES - 1;
	        }
	        for (;;) {
	            if (COEFS_Y[i][0] > ll.y) {
	                --i;
	            } else if (COEFS_Y[i+1][0] <= ll.y) {
	                ++i;
	            } else {
	                break;
	            }
	        }
	        // linear interpolation in 5 degree interval
	        var coefs = COEFS_Y[i];
	        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
	        // find t so that poly3_val(coefs, t) = ll.y
	        t = newton_rapshon(function(x) {
	            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
	        }, t, EPSLN, 100);

	        ll.x /= poly3_val(COEFS_X[i], t);
	        ll.y = (5 * i + t) * D2R$1;
	        if (xy.y < 0) {
	            ll.y = -ll.y;
	        }
	    }

	    ll.x = adjust_lon(ll.x + this.long0);
	    return ll;
	}

	var names$3 = ["Robinson", "robin"];
	var robin = {
	  init: init$3,
	  forward: forward$3,
	  inverse: inverse$3,
	  names: names$3
	};

	function init$2() {
	    this.name = 'geocent';

	}

	function forward$2(p) {
	    var point = geodeticToGeocentric(p, this.es, this.a);
	    return point;
	}

	function inverse$2(p) {
	    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
	    return point;
	}

	var names$2 = ["Geocentric", 'geocentric', "geocent", "Geocent"];
	var geocent = {
	    init: init$2,
	    forward: forward$2,
	    inverse: inverse$2,
	    names: names$2
	};

	var mode$1 = {
	  N_POLE: 0,
	  S_POLE: 1,
	  EQUIT: 2,
	  OBLIQ: 3
	};

	var params = {
	  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
	  azi:   { def: 0, num: true, degrees: true }, // default is North
	  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
	  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
	  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
	};

	function init$1() {
	  Object.keys(params).forEach(function (p) {
	    if (typeof this[p] === "undefined") {
	      this[p] = params[p].def;
	    } else if (params[p].num && isNaN(this[p])) {
	      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
	    } else if (params[p].num) {
	      this[p] = parseFloat(this[p]);
	    }
	    if (params[p].degrees) {
	      this[p] = this[p] * D2R$1;
	    }
	  }.bind(this));

	  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
	    this.mode = this.lat0 < 0 ? mode$1.S_POLE : mode$1.N_POLE;
	  } else if (Math.abs(this.lat0) < EPSLN) {
	    this.mode = mode$1.EQUIT;
	  } else {
	    this.mode = mode$1.OBLIQ;
	    this.sinph0 = Math.sin(this.lat0);
	    this.cosph0 = Math.cos(this.lat0);
	  }

	  this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

	  if (this.pn1 <= 0 || this.pn1 > 1e10) {
	    throw new Error("Invalid height");
	  }
	  
	  this.p = 1 + this.pn1;
	  this.rp = 1 / this.p;
	  this.h1 = 1 / this.pn1;
	  this.pfact = (this.p + 1) * this.h1;
	  this.es = 0;

	  var omega = this.tilt;
	  var gamma = this.azi;
	  this.cg = Math.cos(gamma);
	  this.sg = Math.sin(gamma);
	  this.cw = Math.cos(omega);
	  this.sw = Math.sin(omega);
	}

	function forward$1(p) {
	  p.x -= this.long0;
	  var sinphi = Math.sin(p.y);
	  var cosphi = Math.cos(p.y);
	  var coslam = Math.cos(p.x);
	  var x, y;
	  switch (this.mode) {
	    case mode$1.OBLIQ:
	      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
	      break;
	    case mode$1.EQUIT:
	      y = cosphi * coslam;
	      break;
	    case mode$1.S_POLE:
	      y = -sinphi;
	      break;
	    case mode$1.N_POLE:
	      y = sinphi;
	      break;
	  }
	  y = this.pn1 / (this.p - y);
	  x = y * cosphi * Math.sin(p.x);

	  switch (this.mode) {
	    case mode$1.OBLIQ:
	      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
	      break;
	    case mode$1.EQUIT:
	      y *= sinphi;
	      break;
	    case mode$1.N_POLE:
	      y *= -(cosphi * coslam);
	      break;
	    case mode$1.S_POLE:
	      y *= cosphi * coslam;
	      break;
	  }

	  // Tilt 
	  var yt, ba;
	  yt = y * this.cg + x * this.sg;
	  ba = 1 / (yt * this.sw * this.h1 + this.cw);
	  x = (x * this.cg - y * this.sg) * this.cw * ba;
	  y = yt * ba;

	  p.x = x * this.a;
	  p.y = y * this.a;
	  return p;
	}

	function inverse$1(p) {
	  p.x /= this.a;
	  p.y /= this.a;
	  var r = { x: p.x, y: p.y };

	  // Un-Tilt
	  var bm, bq, yt;
	  yt = 1 / (this.pn1 - p.y * this.sw);
	  bm = this.pn1 * p.x * yt;
	  bq = this.pn1 * p.y * this.cw * yt;
	  p.x = bm * this.cg + bq * this.sg;
	  p.y = bq * this.cg - bm * this.sg;

	  var rh = hypot(p.x, p.y);
	  if (Math.abs(rh) < EPSLN) {
	    r.x = 0;
	    r.y = p.y;
	  } else {
	    var cosz, sinz;
	    sinz = 1 - rh * rh * this.pfact;
	    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
	    cosz = Math.sqrt(1 - sinz * sinz);
	    switch (this.mode) {
	      case mode$1.OBLIQ:
	        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
	        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
	        p.x *= sinz * this.cosph0;
	        break;
	      case mode$1.EQUIT:
	        r.y = Math.asin(p.y * sinz / rh);
	        p.y = cosz * rh;
	        p.x *= sinz;
	        break;
	      case mode$1.N_POLE:
	        r.y = Math.asin(cosz);
	        p.y = -p.y;
	        break;
	      case mode$1.S_POLE:
	        r.y = -Math.asin(cosz);
	        break;
	    }
	    r.x = Math.atan2(p.x, p.y);
	  }

	  p.x = r.x + this.long0;
	  p.y = r.y;
	  return p;
	}

	var names$1 = ["Tilted_Perspective", "tpers"];
	var tpers = {
	  init: init$1,
	  forward: forward$1,
	  inverse: inverse$1,
	  names: names$1
	};

	function init() {
	    this.flip_axis = (this.sweep === 'x' ? 1 : 0);
	    this.h = Number(this.h);
	    this.radius_g_1 = this.h / this.a;

	    if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
	        throw new Error();
	    }

	    this.radius_g = 1.0 + this.radius_g_1;
	    this.C = this.radius_g * this.radius_g - 1.0;

	    if (this.es !== 0.0) {
	        var one_es = 1.0 - this.es;
	        var rone_es = 1 / one_es;

	        this.radius_p = Math.sqrt(one_es);
	        this.radius_p2 = one_es;
	        this.radius_p_inv2 = rone_es;

	        this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
	    } else {
	        this.radius_p = 1.0;
	        this.radius_p2 = 1.0;
	        this.radius_p_inv2 = 1.0;

	        this.shape = 'sphere';  // Use as a condition in the forward and inverse functions.
	    }

	    if (!this.title) {
	        this.title = "Geostationary Satellite View";
	    }
	}

	function forward(p) {
	    var lon = p.x;
	    var lat = p.y;
	    var tmp, v_x, v_y, v_z;
	    lon = lon - this.long0;

	    if (this.shape === 'ellipse') {
	        lat = Math.atan(this.radius_p2 * Math.tan(lat));
	        var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));

	        v_x = r * Math.cos(lon) * Math.cos(lat);
	        v_y = r * Math.sin(lon) * Math.cos(lat);
	        v_z = r * Math.sin(lat);

	        if (((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2) < 0.0) {
	            p.x = Number.NaN;
	            p.y = Number.NaN;
	            return p;
	        }

	        tmp = this.radius_g - v_x;
	        if (this.flip_axis) {
	            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
	            p.y = this.radius_g_1 * Math.atan(v_z / tmp);
	        } else {
	            p.x = this.radius_g_1 * Math.atan(v_y / tmp);
	            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
	        }
	    } else if (this.shape === 'sphere') {
	        tmp = Math.cos(lat);
	        v_x = Math.cos(lon) * tmp;
	        v_y = Math.sin(lon) * tmp;
	        v_z = Math.sin(lat);
	        tmp = this.radius_g - v_x;

	        if (this.flip_axis) {
	            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
	            p.y = this.radius_g_1 * Math.atan(v_z / tmp);
	        } else {
	            p.x = this.radius_g_1 * Math.atan(v_y / tmp);
	            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
	        }
	    }
	    p.x = p.x * this.a;
	    p.y = p.y * this.a;
	    return p;
	}

	function inverse(p) {
	    var v_x = -1.0;
	    var v_y = 0.0;
	    var v_z = 0.0;
	    var a, b, det, k;

	    p.x = p.x / this.a;
	    p.y = p.y / this.a;

	    if (this.shape === 'ellipse') {
	        if (this.flip_axis) {
	            v_z = Math.tan(p.y / this.radius_g_1);
	            v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
	        } else {
	            v_y = Math.tan(p.x / this.radius_g_1);
	            v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
	        }

	        var v_zp = v_z / this.radius_p;
	        a = v_y * v_y + v_zp * v_zp + v_x * v_x;
	        b = 2 * this.radius_g * v_x;
	        det = (b * b) - 4 * a * this.C;

	        if (det < 0.0) {
	            p.x = Number.NaN;
	            p.y = Number.NaN;
	            return p;
	        }

	        k = (-b - Math.sqrt(det)) / (2.0 * a);
	        v_x = this.radius_g + k * v_x;
	        v_y *= k;
	        v_z *= k;

	        p.x = Math.atan2(v_y, v_x);
	        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
	        p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
	    } else if (this.shape === 'sphere') {
	        if (this.flip_axis) {
	            v_z = Math.tan(p.y / this.radius_g_1);
	            v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
	        } else {
	            v_y = Math.tan(p.x / this.radius_g_1);
	            v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
	        }

	        a = v_y * v_y + v_z * v_z + v_x * v_x;
	        b = 2 * this.radius_g * v_x;
	        det = (b * b) - 4 * a * this.C;
	        if (det < 0.0) {
	            p.x = Number.NaN;
	            p.y = Number.NaN;
	            return p;
	        }

	        k = (-b - Math.sqrt(det)) / (2.0 * a);
	        v_x = this.radius_g + k * v_x;
	        v_y *= k;
	        v_z *= k;

	        p.x = Math.atan2(v_y, v_x);
	        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
	    }
	    p.x = p.x + this.long0;
	    return p;
	}

	var names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
	var geos = {
	    init: init,
	    forward: forward,
	    inverse: inverse,
	    names: names,
	};

	function includedProjections(proj4){
	  proj4.Proj.projections.add(tmerc);
	  proj4.Proj.projections.add(etmerc);
	  proj4.Proj.projections.add(utm);
	  proj4.Proj.projections.add(sterea);
	  proj4.Proj.projections.add(stere);
	  proj4.Proj.projections.add(somerc);
	  proj4.Proj.projections.add(omerc);
	  proj4.Proj.projections.add(lcc);
	  proj4.Proj.projections.add(krovak);
	  proj4.Proj.projections.add(cass);
	  proj4.Proj.projections.add(laea);
	  proj4.Proj.projections.add(aea);
	  proj4.Proj.projections.add(gnom);
	  proj4.Proj.projections.add(cea);
	  proj4.Proj.projections.add(eqc);
	  proj4.Proj.projections.add(poly);
	  proj4.Proj.projections.add(nzmg);
	  proj4.Proj.projections.add(mill);
	  proj4.Proj.projections.add(sinu);
	  proj4.Proj.projections.add(moll);
	  proj4.Proj.projections.add(eqdc);
	  proj4.Proj.projections.add(vandg);
	  proj4.Proj.projections.add(aeqd);
	  proj4.Proj.projections.add(ortho);
	  proj4.Proj.projections.add(qsc);
	  proj4.Proj.projections.add(robin);
	  proj4.Proj.projections.add(geocent);
	  proj4.Proj.projections.add(tpers);
	  proj4.Proj.projections.add(geos);
	}

	proj4.defaultDatum = 'WGS84'; //default datum
	proj4.Proj = Projection;
	proj4.WGS84 = new proj4.Proj('WGS84');
	proj4.Point = Point$1;
	proj4.toPoint = common;
	proj4.defs = defs;
	proj4.nadgrid = nadgrid;
	proj4.transform = transform;
	proj4.mgrs = mgrs;
	proj4.version = '__VERSION__';
	includedProjections(proj4);

	class Handler {

		constructor ( ctx ) {

			this.surveyTree = new Tree();
			this.limits     = new Box3();
			this.offsets    = new Vector3();
			this.allStations  = [];
			this.lineSegments = [];
			this.xGroups      = [];
			this.scraps     = [];
			this.terrains   = [];
			this.sourceCRS  = null;
			this.targetCRS  = 'EPSG:3857'; // "web mercator"
			this.displayCRS = null;
			this.projection = null;
			this.hasTerrain  = false;
			this.messages = [];
			this.metadata = null;
			this.fileCount = 0;
			this.splayFix = false;
			this.ctx = ctx;

		}

		setCRS ( sourceCRS ) {

			if ( sourceCRS !== null ) {

				// work around lack of +init string support in proj4js

				const matches = sourceCRS.match( /\+init=(.*)\s/ );

				let init;

				if ( matches && matches.length === 2 ) {

					init = matches[ 1 ];

				} else {

					init = sourceCRS.toLowerCase();

				}

				let code;

				switch ( init ) {

				case 'epsg:27700' :

					sourceCRS = '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs';

					break;

				default:

					code = init.match( /(epsg|esri):([0-9]+)/ );

					if ( code !== null ) {

						console.log( 'looking up CRS code EPSG:' + code [ 2 ] );

						return fetch( 'https://epsg.io/' + code[ 2 ] + '.proj4' )
							.then( response => {

								return response.text();

							} ).then( text => {

								this._setCRS( text );

							} ).catch( function () { console.log( 'CRS lookup failed' ); } );

					} else {

						if ( ! sourceCRS.match( /^\+proj/ ) ) {

							sourceCRS = null;
							console.log( 'got proj');

						}

					}

				}

			}

			this._setCRS( sourceCRS );

			return Promise.resolve( null );

		}

		_setCRS ( sourceCRS ) {

			const cfg = this.ctx.cfg;
			const displayCRS = cfg.value( 'displayCRS', 'EPSG:3857' );

			if ( sourceCRS === null ) {

				sourceCRS = cfg.value( 'defaultCRS', null );

				if ( sourceCRS !== null ) console.log( 'Using default projection.' );

			}

			// FIXME use NAD grid corrections OSTM15 etc ( UK Centric )
			if ( sourceCRS !== null ) {

				this.sourceCRS = sourceCRS;

				if ( displayCRS === 'ORIGINAL' ) {

					this.displayCRS = 'ORIGINAL';

				} else {

					console.log( 'Reprojecting from', sourceCRS, 'to', this.targetCRS );

					this.projection = proj4( this.sourceCRS, this.targetCRS );
					this.displayCRS = this.targetCRS;

				}

			}

		}

		addStations ( stations ) {

			this.fileCount++;

			this.allStations.push( stations );

		}

		addLineSegments ( groups ) {

			const lineSegments = this.lineSegments;
			const l = groups.length;

			for ( let i = 0; i < l; i++ ) {

				const g = groups[ i ];
				const vMax = g.length - 1;

				for ( let v = 0; v < vMax; v++ ) {

					// create vertex pairs for each line segment.
					// all vertices except first and last are duplicated.
					const from = g[ v ];
					const to   = g[ v + 1 ];

					const fromCoords = from.coords;
					const toCoords = to.coords;

					lineSegments.push( { from: fromCoords, to: toCoords, type: to.type, survey: to.survey } );

				}

			}

		}

		addXsects ( xSects ) {

			const xGroups = [];
			const ends = [];

			let lastTo, xGroup;

			xSects.sort( function ( a, b ) { return a.m_from - b.m_from; } );

			for ( let i = 0; i < xSects.length; i++ ) {

				const xSect = xSects[ i ];

				if ( xSect.m_from !== lastTo ) {

					xGroup = [];
					xGroups.push( xGroup );

				}

				lastTo = xSect.m_to;

				xGroup.push( xSect );

			}

			for ( let i = 0; i < xGroups.length; i++ ) {

				const group = xGroups[ i ];

				const start = group[ 0 ].m_from;
				const end = group[ group.length - 1 ].m_to;

				// concatenate adjacent groups

				const prepend = ends.indexOf( start );

				if ( prepend !== -1 ) {

					// keep the new run in the same slot - thus end record remains correct
					xGroups[ i ] = xGroups[ prepend ].concat( group );

					// remove entry from moved group
					xGroups[ prepend ] = [];
					ends[ prepend ] = undefined;

				}

				ends.push( end );

			}

			for ( let i = 0; i < xGroups.length; i++ ) {

				const group = xGroups[ i ];

				if ( group.length < 2 ) continue;

				const xSect = group[ 0 ];
				const xSectNext = group[ 1 ];

				if ( xSect === undefined ) continue; // groups that have been merged

				const start = xSectNext.start;
				const end = xSectNext.end;

				// fake approach vector for initial xSect ( mirrors first section vector )

				xSect.start = new Vector3().copy( start ).multiplyScalar( 2 ).sub( end );

				// add to model
				this.xGroups.push( group );

			}

		}

		enableSplayFix () {

			this.splayFix = true;

		}

		getSurvey () {

			const limits = this.limits;

			// convert to origin centered coordinates

			const offsets = limits.getCenter( this.offsets );
			const allStations = this.allStations;

			allStations.forEach( all => all.forEach( s => s.sub( offsets ) ) );

			// convert scraps if present

			const scraps = this.scraps;

			// covert scraps coordinates

			for ( let i = 0; i < scraps.length; i++ ) {

				const vertices = scraps[ i ].vertices;

				for ( let j = 0; j < vertices.length; j++ ) {

					vertices[ j ].sub( offsets );

				}

			}

			return {
				title: this.fileName,
				surveyTree: this.surveyTree,
				sourceCRS: this.sourceCRS,
				displayCRS: this.displayCRS,
				lineSegments: this.lineSegments,
				crossSections: this.xGroups,
				scraps: this.scraps,
				hasTerrain: this.hasTerrain,
				metadata: this.metadata,
				terrains: this.terrains,
				limits: this.limits,
				offsets: this.offsets,
				splayFix: this.splayFix
			};

		}

	}

	const setProgressEvent = { type: 'progress', name: 'set', progress: 0 };

	class CaveLoader extends EventDispatcher {

		constructor ( ctx, callback ) {

			super();

			if ( ! callback ) {

				alert( 'No callback specified' );

			}

			this.callback = callback;
			this.dataResponse = null;
			this.metadataResponse = null;
			this.requests = [];
			this.ctx = ctx;

			this.reset();

		}

		reset () {

			this.source = null;
			this.sourceIndex = 0;
			this.handler = null;
			this.section = null;

			this.requests.forEach( request => request.abort() );
			this.requests = [];
			this.models = new Handler( this.ctx );

		}

		setHandler ( fileName ) {

			const extention = fileName.split( '.' ).reverse().shift().toLowerCase();

			switch ( extention ) {

			case '3d':

				this.handler = new Svx3dHandler( fileName );

				break;

			case 'lox':

				this.handler = new loxHandler( fileName );

				break;

			case 'plt':

				this.handler = new pltHandler( fileName );

				break;

			default:

				console.warn( 'CaveView: unknown file extension [', extention, ']' );
				return false;

			}

			return true;

		}

		loadSource ( source, section = null ) {

			this.source = source;
			this.section = section;

			this.loadNext();

		}

		loadNext () {

			const source = this.source;
			const file = source.files[ this.sourceIndex++ ];

			if ( source.local ) {

				this.loadLocalFile( file );

			} else {

				this.loadURL( file );

			}

		}

		progress ( v ) {

			setProgressEvent.progress = v;
			this.dispatchEvent( setProgressEvent );

		}

		loadURL ( fileDesc, section ) {

			const fileName = fileDesc.name;
			const cfg = this.ctx.cfg;

			this.dispatchEvent( { type: 'progress', name: 'start' } );

			if ( section !== undefined ) this.section = section;

			const self = this;
			const prefix = cfg.value( 'surveyDirectory', '' );
			const loadMetadata = cfg.value( 'loadMetadata', false );

			// setup file handler
			if ( ! this.setHandler( fileName ) ) return false;

			const taskCount = loadMetadata ? 2 : 1;

			let doneCount = 0;

			const loader = new FileLoader().setPath( prefix );

			if ( loadMetadata ) {

				loader.setResponseType( 'json' );

				const req = loader.load( replaceExtension( fileName, 'json' ), _metadataLoaded, undefined, _metadataError );
				if ( req ) this.requests.push( req );

			}

			loader.setResponseType( this.handler.type );

			const req = loader.load( fileName, _dataLoaded, _progress, _dataError );
			if ( req ) this.requests.push( req );

			const end = () => { if ( ++doneCount === taskCount ) this.callHandler(); };

			return true;

			function _dataLoaded ( result ) {

				self.dataResponse = result;

				self.progress( 75 );

				end();

			}

			function _metadataLoaded ( result ) {

				self.metadataResponse = result;

				end();

			}

			function _progress ( event ) {

				if ( event.total > 0 ) self.progress( Math.round( 75 * event.loaded / event.total ) );

			}

			function _dataError ( event ) {

				if ( event.type === 'abort' ) return;

				console.warn( 'error event', event );

				end();

			}

			function _metadataError ( event ) {

				if ( event.type === 'abort' ) return;

				end();

			}

		}

		loadLocalFile ( file, section ) {

			this.dispatchEvent( { type: 'progress', name: 'start' } );

			if ( section !== undefined ) this.section = section;

			const self = this;
			const fileName = file.name;

			if ( ! this.setHandler( fileName ) ) return false;

			const fLoader = new FileReader();

			fLoader.addEventListener( 'load', _loaded );
			fLoader.addEventListener( 'progress', _progress );

			switch ( this.handler.type ) {

			case 'arraybuffer':

				fLoader.readAsArrayBuffer( file );

				break;

			case 'text':

				fLoader.readAsText( file );

				break;

			default:

				alert( 'unknown file data type' );
				return false;

			}

			return true;

			function _loaded () {

				self.dataResponse = fLoader.result;
				self.callHandler();

				self.progress( 75 );

				fLoader.removeEventListener( 'load', _loaded );
				fLoader.removeEventListener( 'progress', _progress );

			}

			function _progress ( e ) {

				if ( e.total > 0 ) self.progress( Math.round( 75 * e.loaded / e.total ) );

			}

		}

		callHandler () {

			if ( this.dataResponse === null ) {

				this.callback( false );
				this.dispatchEvent( { type: 'progress', name: 'end' } );
				this.reset();

				return;

			}

			const data = this.dataResponse;
			const metadata = this.metadataResponse;
			const section = this.section;

			this.dataResponse = null;
			this.metadataResponse = null;

			const moreFiles = ( this.sourceIndex < this.source.files.length );

			// start the next download to overlap parsing previous file
			const handler = this.handler;

			this.handler = null;

			if ( moreFiles ) this.loadNext();

			const progress = this.progress.bind( this );

			handler.parse( this.models, data, metadata, section, progress ).then( models => {

				if ( ! moreFiles ) {

					this.callback( models );
					this.dispatchEvent( { type: 'progress', name: 'end' } );
					this.reset();

				}

			} );

		}

	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var x18n_build = {exports: {}};

	var observable = {exports: {}};

	var hasRequiredObservable;

	function requireObservable () {
		if (hasRequiredObservable) return observable.exports;
		hasRequiredObservable = 1;
		(function (module, exports) {
			// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/observable
			(function() {
			  var Observable, isPlainObject, isType, toArray;

			  isType = function(type, value) {
			    return Object.prototype.toString.call(value).match(/\s(\w+)/)[1].toLowerCase() === type;
			  };

			  isPlainObject = function(value) {
			    return !!value && isType('object', value);
			  };

			  toArray = function(value) {
			    if (isType('array', value)) {
			      return value;
			    } else {
			      return [value];
			    }
			  };

			  Observable = (function() {
			    function Observable() {
			      this.__eventStore = {};
			      this.__asyncEvents = true;
			    }

			    Observable.mixin = function(host) {
			      var fn, key, ref, results;
			      host.__eventStore = {};
			      ref = Observable.prototype;
			      results = [];
			      for (key in ref) {
			        fn = ref[key];
			        results.push(host[key] = fn);
			      }
			      return results;
			    };

			    Observable.prototype.on = function(topics, fn, once) {
			      var base, i, len, ref, topic;
			      if (once == null) {
			        once = false;
			      }
			      if (isPlainObject(topics)) {
			        for (topic in topics) {
			          fn = topics[topic];
			          this.on(topic, fn);
			        }
			      } else {
			        ref = toArray(topics);
			        for (i = 0, len = ref.length; i < len; i++) {
			          topic = ref[i];
			          (base = this.__eventStore)[topic] || (base[topic] = []);
			          this.__eventStore[topic].push({
			            fn: fn,
			            once: once
			          });
			        }
			      }
			      return this;
			    };

			    Observable.prototype.once = function(topics, fn) {
			      if (fn) {
			        return this.on(topics, fn, true);
			      } else {
			        return this.on(topics, true);
			      }
			    };

			    Observable.prototype.off = function(topics, fn) {
			      var i, j, len, len1, ref, ref1, topic;
			      if (!fn) {
			        ref = toArray(topics);
			        for (i = 0, len = ref.length; i < len; i++) {
			          topic = ref[i];
			          this.__eventStore[topic] = [];
			        }
			      }
			      if (isPlainObject(topics)) {
			        for (topic in topics) {
			          fn = topics[topic];
			          this.off(topic, fn);
			        }
			      } else {
			        ref1 = toArray(topics);
			        for (j = 0, len1 = ref1.length; j < len1; j++) {
			          topic = ref1[j];
			          this.__eventStore[topic] = (this.__eventStore[topic] || []).filter(function(subscriber) {
			            return subscriber.fn !== fn;
			          });
			        }
			      }
			      return this;
			    };

			    Observable.prototype.trigger = function(topic, args) {
			      var ref;
			      args || (args = []);
			      if ((ref = this.__eventStore[topic]) != null) {
			        ref.forEach((function(_this) {
			          return function(arg) {
			            var fn, once;
			            fn = arg.fn, once = arg.once;
			            if (_this.__asyncEvents) {
			              setTimeout((function() {
			                return fn.apply(null, args);
			              }), 1);
			            } else {
			              fn.apply(null, args);
			            }
			            if (once) {
			              return _this.off(topic, fn);
			            }
			          };
			        })(this));
			      }
			      return this;
			    };

			    return Observable;

			  })();

			  {
			    module.exports = Observable;
			  }

			}).call(commonjsGlobal);
	} (observable));
		return observable.exports;
	}

	(function (module, exports) {
		// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/x18n
		// Copyright (c) 2012-2016 Florian Hartmann, https://github.com/florian/observable
		(function() {
		  var Observable, isPlainObject, isType, toArray;

		  isType = function(type, value) {
		    return Object.prototype.toString.call(value).match(/\s(\w+)/)[1].toLowerCase() === type;
		  };

		  isPlainObject = function(value) {
		    return !!value && isType('object', value);
		  };

		  toArray = function(value) {
		    if (isType('array', value)) {
		      return value;
		    } else {
		      return [value];
		    }
		  };

		  Observable = (function() {
		    function Observable() {
		      this.__eventStore = {};
		      this.__asyncEvents = true;
		    }

		    Observable.mixin = function(host) {
		      var fn, key, ref, results;
		      host.__eventStore = {};
		      ref = Observable.prototype;
		      results = [];
		      for (key in ref) {
		        fn = ref[key];
		        results.push(host[key] = fn);
		      }
		      return results;
		    };

		    Observable.prototype.on = function(topics, fn, once) {
		      var base, i, len, ref, topic;
		      if (once == null) {
		        once = false;
		      }
		      if (isPlainObject(topics)) {
		        for (topic in topics) {
		          fn = topics[topic];
		          this.on(topic, fn);
		        }
		      } else {
		        ref = toArray(topics);
		        for (i = 0, len = ref.length; i < len; i++) {
		          topic = ref[i];
		          (base = this.__eventStore)[topic] || (base[topic] = []);
		          this.__eventStore[topic].push({
		            fn: fn,
		            once: once
		          });
		        }
		      }
		      return this;
		    };

		    Observable.prototype.once = function(topics, fn) {
		      if (fn) {
		        return this.on(topics, fn, true);
		      } else {
		        return this.on(topics, true);
		      }
		    };

		    Observable.prototype.off = function(topics, fn) {
		      var i, j, len, len1, ref, ref1, topic;
		      if (!fn) {
		        ref = toArray(topics);
		        for (i = 0, len = ref.length; i < len; i++) {
		          topic = ref[i];
		          this.__eventStore[topic] = [];
		        }
		      }
		      if (isPlainObject(topics)) {
		        for (topic in topics) {
		          fn = topics[topic];
		          this.off(topic, fn);
		        }
		      } else {
		        ref1 = toArray(topics);
		        for (j = 0, len1 = ref1.length; j < len1; j++) {
		          topic = ref1[j];
		          this.__eventStore[topic] = (this.__eventStore[topic] || []).filter(function(subscriber) {
		            return subscriber.fn !== fn;
		          });
		        }
		      }
		      return this;
		    };

		    Observable.prototype.trigger = function(topic, args) {
		      var ref;
		      args || (args = []);
		      if ((ref = this.__eventStore[topic]) != null) {
		        ref.forEach((function(_this) {
		          return function(arg) {
		            var fn, once;
		            fn = arg.fn, once = arg.once;
		            if (_this.__asyncEvents) {
		              setTimeout((function() {
		                return fn.apply(null, args);
		              }), 1);
		            } else {
		              fn.apply(null, args);
		            }
		            if (once) {
		              return _this.off(topic, fn);
		            }
		          };
		        })(this));
		      }
		      return this;
		    };

		    return Observable;

		  })();

		  {
		    module.exports = Observable;
		  }

		}).call(commonjsGlobal);

		(function() {
		  var Observable, base,
		    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
		    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		    hasProp = {}.hasOwnProperty,
		    slice = [].slice,
		    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

		  base = function(Observable) {
		    var X18n;
		    X18n = (function(superClass) {
		      extend(X18n, superClass);

		      function X18n() {
		        this.t = bind(this.t, this);
		        X18n.__super__.constructor.call(this);
		        this.dict = {};
		        this.defaultlocal = 'en';
		        this.chosenLocal = void 0;
		        this.availableLocales = [];
		        this.locales = [];
		        this.missingTranslations = {};
		        this.on('dict:change', (function(_this) {
		          return function() {
		            return _this.sortLocales();
		          };
		        })(this));
		      }

		      X18n.prototype.utils = {
		        merge: function(one, two) {
		          var k, results, v;
		          results = [];
		          for (k in two) {
		            v = two[k];
		            if (typeof v === 'object' && typeof one[k] === 'object') {
		              results.push(this.merge(one[k], v));
		            } else {
		              results.push(one[k] = v);
		            }
		          }
		          return results;
		        },
		        filter: function(arr, fn) {
		          var i, len, results, v;
		          results = [];
		          for (i = 0, len = arr.length; i < len; i++) {
		            v = arr[i];
		            if (fn(v)) {
		              results.push(v);
		            }
		          }
		          return results;
		        },
		        unique: function(arr) {
		          var i, k, len, results, ret, v;
		          ret = {};
		          for (i = 0, len = arr.length; i < len; i++) {
		            v = arr[i];
		            ret[v] = v;
		          }
		          results = [];
		          for (k in ret) {
		            v = ret[k];
		            results.push(v);
		          }
		          return results;
		        },
		        getByDotNotation: function(obj, key) {
		          var keys;
		          keys = key.split('.');
		          while (!(keys.length === 0 || obj === void 0)) {
		            obj = obj[keys[0]];
		            keys.shift();
		          }
		          return obj;
		        },
		        isPlainObject: function(value) {
		          return !!value && Object.prototype.toString.call(value) === '[object Object]';
		        }
		      };

		      X18n.prototype.register = function(local, dict) {
		        if (!(local in this.dict)) {
		          this.dict[local] = {};
		          this.availableLocales.push(local);
		        }
		        this.utils.merge(this.dict[local], dict);
		        return this.trigger('dict:change', [local]);
		      };

		      X18n.prototype.set = function(local) {
		        this.chosenLocal = local;
		        return this.sortLocales();
		      };

		      X18n.prototype.setDefault = function(local) {
		        this.defaultLocal = local;
		        return this.sortLocales();
		      };

		      X18n.prototype.detectLocal = function() {
		        return navigator.userLanguage || navigator.language;
		      };

		      X18n.prototype.similiarLocales = function(local) {
		        local = String(local).slice(0, 2).toLowerCase();
		        return this.utils.filter(this.availableLocales, function(l) {
		          if (local === l) {
		            return false;
		          }
		          return l.toLowerCase().indexOf(local) === 0;
		        });
		      };

		      X18n.prototype.sortLocales = function() {
		        var _locales, i, len, local, locales, oldLocales;
		        oldLocales = this.locales.slice();
		        _locales = [this.chosenLocal].concat(slice.call(this.similiarLocales(this.chosenLocal)), [this.detectLocal()], slice.call(this.similiarLocales(this.detectLocal())), [this.defaultLocal], slice.call(this.similiarLocales(this.defaultlocal)), ['en'], slice.call(this.similiarLocales('en')));
		        locales = [];
		        for (i = 0, len = _locales.length; i < len; i++) {
		          local = _locales[i];
		          if (indexOf.call(this.availableLocales, local) >= 0) {
		            locales.push(local);
		          }
		        }
		        locales.push.apply(locales, this.availableLocales);
		        this.locales = this.utils.unique(locales);
		        if (oldLocales.join(',') !== this.locales.join(',')) {
		          return this.trigger('lang:change', [this.locales, oldLocales]);
		        }
		      };

		      X18n.prototype.interpolate = function() {
		        var interpolation, str;
		        str = arguments[0], interpolation = 2 <= arguments.length ? slice.call(arguments, 1) : [];
		        if (this.utils.isPlainObject(interpolation[0])) {
		          str = str.replace(/%\{([^}]+)\}/g, function(_, key) {
		            return interpolation[0][key];
		          });
		        } else {
		          str = str.replace(/%(\d+)/g, function(_, n) {
		            return interpolation[Number(n) - 1];
		          });
		        }
		        return str;
		      };

		      X18n.prototype.t = function() {
		        var i, interpolation, key, len, local, ref, tr;
		        key = arguments[0], interpolation = 2 <= arguments.length ? slice.call(arguments, 1) : [];
		        tr = void 0;
		        ref = this.locales;
		        for (i = 0, len = ref.length; i < len; i++) {
		          local = ref[i];
		          tr = this.utils.getByDotNotation(this.dict[local], key);
		          if (tr) {
		            break;
		          } else {
		            if (!(local in this.missingTranslations)) {
		              this.missingTranslations[local] = [];
		            }
		            this.missingTranslations[local].push(key);
		            this.missingTranslations[local] = this.utils.unique(this.missingTranslations[local]);
		            this.trigger('missing-translation', [local, key]);
		          }
		        }
		        if (typeof tr === 'string') {
		          tr = this.interpolate.apply(this, [tr].concat(slice.call(interpolation)));
		        } else if (tr !== void 0) {
		          tr.plural = (function(_this) {
		            return function(n) {
		              if (n in tr) {
		                return tr[n];
		              } else {
		                return _this.interpolate(tr.n, n);
		              }
		            };
		          })(this);
		        }
		        return tr;
		      };

		      return X18n;

		    })(Observable);
		    return new X18n();
		  };

		  if ((module !== null) && (module.exports != null)) {
		    Observable = requireObservable();
		    module.exports = base(Observable);
		  } else {
		    window.x18n = base(window.Observable);
		  }

		}).call(commonjsGlobal);
	} (x18n_build));

	var x18n = x18n_build.exports;

	const settings = {
		title: "Settings",
		survey: {
			header: "Survey",
			caption: "File"
		},
		view: {
			header: "View",
			camera: {
				caption: "Camera type",
				orthographic: "Orthographic",
				perspective: "Perspective",
				anaglyph: "Anaglyph"
			},
			viewpoints: {
				caption: "Viewpoint",
				none: "<select viewpoint>",
				plan: "Plan",
				elevation_n: "N Elevation",
				elevation_s: "S Elevation",
				elevation_e: "E Elevation",
				elevation_w: "W Elevation"
			},
			eye_separation: "Eye Separation",
			vertical_scaling: "Vertical Scaling",
			linewidth: "Line width",
			autorotate: "Auto Rotate",
			rotation_speed: "Rotation Speed"
		},
		shading: {
			header: "Shading",
			caption: "Underground legs",
			height: "by height",
			length: "by leg length",
			inclination: "by leg inclination",
			height_cursor: "height cursor",
			fixed: "fixed",
			survey: "survey",
			route: "route",
			depth: "depth",
			depth_cursor: "depth cursor",
			distance: "distance",
			beck: "beck"
		},
		selected_route: "Selected route",
		no_routes: "no routes defined",
		visibility: {
			header: "Visibility",
			legs: "Center lines",
			entrances: "Entrance labels",
			entrance_dots: "Entrance dots",
			stations: "Stations",
			labels: "Station Labels",
			comments: "Station Comments",
			walls: "Walls (LRUD)",
			scraps: "Scraps",
			splays: "Splay Legs",
			duplicates: "Duplicate Legs",
			traces: "Dye Traces",
			warnings: "Warnings",
			box: "Bounding box",
			hud: "Indicators",
			fog: "Fog",
			grid: "Grid"
		},
		controls: {
			header: "Controls",
			svx_control_mode: "'Aven' controls",
			zoom_to_cursor: "Zoom to cursor",
			wheel_tilt: "Mouse wheel - tilt"
		},
		ui: {
			selection_tree: "Use tree selection"
		},
		"default": {
			header: "Defaults",
			save: "Save default settings",
			reset: "Reset default settings"
		},
		colors: {
			header: "Colours",
			background_color: "Background",
			entrance_text: "Entrance text",
			entrance_background: "Entrance background",
			entrance_marker: "Entrance marker",
			bounding_box: "Bounding box",
			legs_fixed: "Passage lines (fixed)",
			surface_fixed: "Surface lines (fixed)",
			duplicate_fixed: "Duplicate lines (fixed)",
			hud_text: "Scale text",
			defaults: "Restore default colours"
		}
	};
	const surface = {
		title: "Surface",
		surface: {
			header: "Surface Features",
			legs: "Surface Legs",
			shading: {
				caption: "Shading",
				height: "by height",
				inclination: "by inclination",
				height_cursor: "height cursor",
				fixed: "fixed"
			}
		},
		terrain: {
			header: "Terrain",
			terrain: "Terrain visible",
			shading: {
				caption: "Shading",
				relief: "relief shading",
				height: "by height",
				overlay: "map overlay",
				contours: "contours"
			},
			overlay: {
				caption: "Overlay"
			},
			opacity: "Opacity",
			datum_shift: "Apply datum shift",
			datum_shift_value: "Vertical datum shift",
			lighting: "Directional Lighting",
			downloadTileSet: "download tile set spec",
			lightingmode: "Lighting",
			lightingmodes: {
				none: "flat",
				single: "directional",
				multiple: "muti-directional"
			}
		}
	};
	const selection = {
		title: "Selection",
		header: "Selection"
	};
	const edit = {
		title: "Edit",
		mode: "edit mode",
		intro: "select edit mode",
		modes: {
			none: "- none -",
			route: "Routes",
			trace: "Traces",
			entrances: "Entrances"
		},
		entrance: {
			header: "Entrances"
		},
		route: {
			header: "Routes",
			current: "Current route",
			save: "Save",
			"new": "New route",
			add: "Add",
			download: "Download"
		},
		trace: {
			header: "Traces",
			start: "Start",
			end: "End"
		}
	};
	const info = {
		title: "Information",
		header: "Information",
		file: "file",
		more: "For more information see",
		summary: "A WebGL 3d cave viewer for Survex (.3d), Therion (.lox) and Compass (.plt) models.",
		github: "CaveView on GitHub",
		stats: {
			header: "Survey Stats",
			legs: "Leg count",
			totalLength: "Total length",
			minLength: "Shortest leg",
			maxLength: "Longest leg",
			splayCount: "Splay leg count",
			surfaceCount: "Surface leg count",
			duplicateCount: "Duplicate leg count",
			otherLegs: "Other legs"
		}
	};
	const help = {
		title: "Help",
		header_svx: "Key commands (survex)",
		header_native: "Key commands (native)",
		shading: {
			header: "Shading",
			height: "height",
			inclination: "leg inclination",
			length: "leg length",
			height_cursor: "height cursor",
			single: "single colour",
			survey: "survey section",
			route: "route",
			depth: "depth below surface",
			depth_cursor: "depth cursor",
			cursor_up: "move cursor up",
			cursor_down: "move cursor down",
			distance: "distance",
			flat: "Flat shading"
		},
		view: {
			header: "View",
			full_screen: "toggle full screen",
			orthogonal: "orthogonal view",
			perspective: "perspective view",
			reset: "reset to inital view",
			center: "center on selected feature",
			next: "next cave",
			plan: "plan",
			elevation: "elevation",
			north: "face north",
			east: "face east",
			south: "face south",
			west: "face west",
			rotate_clockwise: "rotate clockwise",
			rotate_anticlockwise: "rotate anticlockwise",
			zoom_in: "zoom in",
			zoom_out: "zoom out",
			auto_rotate: "rotate continuosly",
			rotate_speed_up: "increase speed of rotation",
			rotate_speed_down: "decrease speed of rotation",
			reverse_rotation: "reverse direction of rotation",
			zoom_to_cursor: "toggle zoom to cursor mode",
			control_mode: "toggle control mode",
			decrease_focal_length: "decrease focal length",
			increase_focal_length: "increase focal length",
			show_labels: "show station names when under mouse"
		},
		visibility: {
			header: "Visibility",
			scraps: "scraps on/off [lox only]",
			bounding_box: "bounding box on/off",
			station_labels: "station labels on/off",
			entrance_labels: "entrance labels on/off",
			splays: "splay legs on/off",
			survey: "underground legs on/off",
			surface: "surface legs on/off",
			terrain: "terrain on/off",
			walls: "LRUD walls on/off",
			stations: "station markers on/off",
			opacity_down: "decrease terrain opacity",
			opacity_up: "increase terrain opacity"
		},
		selection: {
			header: "Selection",
			remove: "remove all except selected section"
		}
	};
	const exports$1 = {
		title: "Exports",
		gltf_export: {
			header: "glTF Export",
			walls: "include LRUD walls",
			scraps: "include scraps",
			legs: "include centre lines",
			rotate_axes: "rotate axes",
			"export": "Download",
			binary_format: "Export as .glb"
		},
		png_export: {
			header: "Image (PNG) Export",
			"export": "Snapshot",
			size: "Size (px)",
			line_scale: "Line scale"
		}
	};
	const hud = {
		height: "height",
		leg_length: "leg length",
		depth: "depth",
		inclination: "inclination"
	};
	const dnd = {
		splash_text: "Drag&nbsp;and&nbsp;drop a .3d or .lox model here to&nbsp;load"
	};
	const popup = {
		leg_length: "Leg length",
		segment_length: "Segment length",
		direct_length: "Direct length",
		depth_from_surface: "depth from surface",
		adjusted_depth: "adjusted depth",
		distance: "distance"
	};
	var lang_en = {
		settings: settings,
		surface: surface,
		selection: selection,
		edit: edit,
		info: info,
		help: help,
		exports: exports$1,
		hud: hud,
		dnd: dnd,
		popup: popup
	};

	const defaultTheme = {
		fieldOfView: 50,
		background: 'black',
		sky: 0x106f8d,
		maxPolarAngle: 180,
		saturatedGradient: false,
		lighting: {
			azimuth: 315,
			inclination: 45
		},
		entrance_dot_size: 5,
		hud: {
			font: 'normal Arial, sans-serif',
			text: 'white',
			progress: 'green',
			progressBackground: 'dimgray',
			bezel: 'gray',
			widgetSize: 40,
			scale: {
				bar1: 'white',
				bar2: 'red',
			},
			compass: {
				top1: 0xb03a14,
				top2: 0x1ab4e5,
				bottom1: 0x581d0a,
				bottom2: 0x0c536a
			},
			ahi: {
				sky: 0x106f8d,
				earth: 0x802100,
				bar: 'yellow',
				marks: 'white'
			},
			cursor: 'yellow'
		},
		box: {
			bounding: 'white',
			select: 'blue',
			highlight: 'red'
		},
		routes: {
			active: 'yellow',
			adjacent: 'red',
			default: 'gray'
		},
		stations: {
			font: 'normal Arial, sans-serif',
			default: {
				text: 'white',
				background: 'rgba( 0.0, 0.0, 0.0, 0.75 ) ',
				font: 'normal Arial, sans-serif',
				marker: 'red'
			},
			entrances: {
				text: 'white',
				background: 'darkred',
				marker: 'white',
				angle: 45,
			},
			junctions: {
				text: 'yellow',
				font: 'normal Arial, sans-serif',
				marker: 'yellow'
			},
			linked: {
				text: 'cyan',
				font: 'normal Arial, sans-serif',
				marker: 'cyan'
			}
		},
		shading: {
			single: 'red',
			surface: 'yellow',
			duplicate: 'white',
			cursor: 'yellow',
			cursorBase: 'gray',
			unselected: 'gray',
			contours: {
				line: 0xe1bba2,
				line10: 0xf29d62,
				interval: 10,
				base: 'white'
			},
			/*
			hypsometric: {
				min: 0,
				max: 400
			},
			*/
			unconnected: 'gray'
		},
		popup: {
			text: 'white',
			border: 'white',
			background: 0x111111
		},
		grid: {
			base: 'gray'
		}
	};

	// setup default language

	x18n.register( 'en', lang_en );
	x18n.set( 'en' );

	class Cfg extends EventDispatcher {

		constructor ( envs ) {

			super();

			this.environment = new Map();
			this.themeColors = new Map();
			this.i18n = x18n.t;

			if ( envs === undefined ) return;

			for ( const pName in envs ) {

				this.environment.set ( pName, envs[ pName ] );

			}

			if ( Cfg.home !== undefined ) this.environment.set( 'home', Cfg.home );

			this.setLanguage( this.value( 'language', navigator.language.slice( 0, 2 ) ) );

		}

		setLanguage ( lang ) {

			if ( lang === 'en' ) {

				x18n.set( 'en' );

			} else {

				// attempt to register non-default language

				console.log( 'loading language file for:', lang );

				const loader = new FileLoader().setPath( this.value( 'home' ) + 'lib/' );

				loader.load( 'lang-' + lang + '.json', _languageLoaded, null, _languageError );

			}

			const self = this;

			x18n.on( [ 'lang:change' ], function () { self.dispatchEvent( { type: 'change', name: 'language' } ); } );

			return;

			function _languageLoaded ( response ) {

				console.log( 'loaded language [' + lang + ']' );

				x18n.register( lang, JSON.parse( response ) );
				x18n.set( lang );

			}

			function _languageError () {

				console.log( 'error loading language file', lang );

			}

		}

		value ( item, defaultValue ) {

			if ( this.environment.has( item ) ) {

				return this.environment.get( item );

			} else {

				return defaultValue;

			}

		}

		setValue ( item, value ) {

			this.environment.set( item, value );

		}

		setPropertyValue ( item, defaultValue ) {

			// set to defined value or default
			this.environment.set( item, this.value( item, defaultValue ) );

			Object.defineProperty( this, item, {

				set( value ) {

					this.environment.set( item, value );
					this.dispatchEvent( { type: 'change', name: item } );

				},
				get() {
					return this.environment.get( item ); }
			} );

		}

		themeValue ( name, defaultValue = undefined ) {

			const theme = this.environment.get( 'theme' );
			const parts = name.split( '.' );

			let value;

			if ( theme !== undefined ) {

				value = this.treeValue( theme, parts );

			}

			if ( value === undefined ) {

				value = this.treeValue( defaultTheme, parts );

			}

			return value || defaultValue;

		}

		themeAngle ( name ) {

			return degToRad$1( this.themeValue ( name ) );

		}

		treeValue ( theme, parts ) {

			let top = theme;

			for ( let i = 0; i < parts.length; i++ ) {

				const part = parts[ i ];

				if ( top[ part ] === undefined ) return undefined;

				top = top[ part ];

			}

			return top;

		}

		themeColorCSS ( name ) {

			return this.themeColor( name ).getStyle();

		}

		themeColor ( name ) {

			let color = this.themeColors.get( name );

			if ( color === undefined ) {

				const savedColorName = window.localStorage.getItem( 'cv-color:' + name );

				color = new Color( savedColorName ? savedColorName : this.themeValue( name ) );
				this.themeColors.set( name, color );

			}

			return color;

		}

		themeColorHex ( name ) {

			return '#' + this.themeColor( name ).getHexString();

		}

		setThemeColorCSS ( name, color ) {

			const ls = window.localStorage;
			const c = new Color( color );

			this.themeColors.set( name, c );
			ls.setItem( 'cv-color:' + name, '#' + c.getHexString() );

			this.dispatchEvent( { type: 'colors', name: name } );

		}

		resetColors () {

			const ls = window.localStorage;

			this.themeColors.forEach( ( colour, name ) => ls.removeItem( `cv-color:${name}` ) );
			this.themeColors.clear();

			this.dispatchEvent( { type: 'colors', name: 'all' } );

		}

	}

	if ( document.currentScript !== undefined ) {

		Cfg.home = document.currentScript.src.match( /^(.*\/)js\// )[ 1 ];

	}

	class DepthMapMaterial extends ShaderMaterial {

		constructor ( terrain ) {

			const boundingBox = terrain.boundingBox;

			const minHeight = boundingBox.min.z;
			const maxHeight = boundingBox.max.z;

			super( {
				vertexShader: Shaders.depthMapVertexShader,
				fragmentShader: Shaders.depthMapFragmentShader,
				type: 'CV.DepthMapMaterial',
				depthWrite: false,
				uniforms: {
					minZ:   { value: minHeight },
					scaleZ: { value: 1 / ( maxHeight - minHeight ) }
				}
			} );

		}

	}

	// unpack GLSL created RGBA packed float values

	const unpackDownscale = 255 / ( 256 * 256 );

	const unpackFactor0 = unpackDownscale / ( 256 * 256 * 256 );
	const unpackFactor1 = unpackDownscale / ( 256 * 256 );
	const unpackFactor2 = unpackDownscale / 256;
	const unpackFactor3 = unpackDownscale / 1;

	function unpackRGBA( buffer ) {

		return unpackFactor0 * buffer[ 0 ] +
			unpackFactor1 * buffer[ 1 ] +
			unpackFactor2 * buffer[ 2 ] +
			unpackFactor3 * buffer[ 3 ];

	}

	const __v$2 = new Vector3();

	class TextureLookup {

		base = null;
		buffer = null;
		range = null;
		tranform = new Matrix3();
		width = null;

		constructor ( renderer, renderTarget, boundingBox ) {

			const width = renderTarget.width;
			const height = renderTarget.height;

			this.buffer = new Uint8ClampedArray( width * height * 4 );

			// copy texture data into ArrayBuffer

			renderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, this.buffer );


			// calculate tranform matrix from Model coordinates to texure coordinates.

			const base = boundingBox.min;
			const range = boundingBox.getSize( new Vector3() );

			this.tranform.scale( width / range.x, height/ range.y, 1 );
			this.tranform.multiply( new Matrix3().translate( - base.x, - base.y ) );

			this.base = base;
			this.range = range;
			this.width = width;

		}

		lookup ( point ) {

			const v = __v$2.copy( point).setZ( 1 ).applyMatrix3( this.tranform ).round();

			const offset = ( v.x + v.y * this.width ) * 4;

			// convert to survey units and return

			return unpackRGBA( this.buffer.subarray( offset, offset + 4 ) );

		}

	}

	class HeightLookup extends TextureLookup {

		zOffset = 0;

		constructor ( renderer, renderTarget, boundingBox ) {

			super( renderer, renderTarget, boundingBox );

			this.zOffset = boundingBox.min.z;

		}

		lookup ( point ) {

			// return height in model space (needs offsets applying to get survey CRS or EPSG:3857)
			return super.lookup( point ) * this.range.z + this.zOffset;

		}

	}

	class CommonTerrainMaterial extends MeshLambertMaterial {

		constructor ( ctx, parameters ) {

			super( parameters );

			Object.defineProperty( this, 'opacity', {
				get() { return ctx.materials.terrainOpacity; }
			} );

			this.transparent = true;
			this.stencilWrite = true;
			this.stencilFunc = EqualStencilFunc;

		}

		commonBeforeCompile ( ctx, shader ) {

			Object.assign(
				shader.uniforms,
				ctx.materials.uniforms.location
			);

			this.editFragmentShader(
				shader,
				'#include <location_fragment_pars>',
				'#include <location_fragment>'
			);

		}

		editVertexShader ( shader, vertexPars, vertexMain ) {

			const vertexShader = shader.vertexShader
				.replace( '#include <common>', '$&\n' + vertexPars )
				.replace( 'include <begin_vertex>', '$&\n' + vertexMain );

			shader.vertexShader = vertexShader;
		}

		editFragmentShader ( shader, fragmentPars, fragmentColor ) {

			const fragmentShader = shader.fragmentShader
				.replace( '#include <common>', '$&\n' + fragmentPars )
				.replace( '#include <color_fragment>', '$&\n' + fragmentColor );

			shader.fragmentShader = fragmentShader;

		}

		editShaderInclude ( shader, name ) {

			const start = '#include <' + name;

			this.editVertexShader(
				shader,
				start + '_vertex_pars>',
				start + '_vertex>'
			);

			this.editFragmentShader(
				shader,
				start + '_fragment_pars>',
				start + '_fragment>'
			);

		}

	}

	class TerrainOverlayMaterial extends CommonTerrainMaterial {

		constructor ( ctx ) {

			super( ctx );

			this.onBeforeCompile = function ( shader ) {

				this.commonBeforeCompile( ctx, shader );

				this.editVertexShader( shader,
					'varying vec2 vPosition;',
					'vPosition = vec2( position.x, position.y );'
				);

			};

		}

	}

	class Overlay {

		constructor ( ctx, overlayProvider ) {

			this.provider = overlayProvider;
			this.active = false;
			this.hasCoverage = false;
			this.crsSupported = overlayProvider.crsSupported === undefined ? [ 'EPSG:3857', 'EPSG:4326', 'ORIGINAL' ] : overlayProvider.crsSupported;
			this.ctx = ctx;

			const attribution = overlayProvider.getAttribution();

			if ( attribution ) {

				const c = new Color( ctx.cfg.themeValue( 'background' ) );
				const hsl = { h: 0, s: 0, l: 0 };

				c.getHSL( hsl );

				attribution.classList.add( 'overlay-branding' );
				attribution.style.color = hsl.l < 0.5 ? 'white' : 'black';

				this.attribution = attribution;

			}

			this.materialCache = new Map();
			this.missing = new Set();

			const coverage = overlayProvider.coverage;

			if ( coverage !== undefined ) {

				this.coverage = new Box2(
					new Vector2( coverage.minX, coverage.minY ),
					new Vector2( coverage.maxX, coverage.maxY )
				);

			}

		}

		getMinZoom () {

			return this.provider.minZoom;

		}

		checkCoverage ( limits, displayCRS, surveyCRS ) {

			const coverage = this.coverage;

			if ( this.crsSupported.indexOf( displayCRS ) === -1 ) return false;

			// transform survey limits to wgs84 for comparison with overlay limits

			const transform = proj4( ( displayCRS === 'ORIGINAL' ? surveyCRS : displayCRS ), 'WGS84' );
			const wgs84Limits = new Box2();

			wgs84Limits.expandByPoint( transform.forward( { x: limits.min.x, y: limits.min.y } ) );
			wgs84Limits.expandByPoint( transform.forward( { x: limits.min.x, y: limits.max.y } ) );
			wgs84Limits.expandByPoint( transform.forward( { x: limits.max.x, y: limits.min.y } ) );
			wgs84Limits.expandByPoint( transform.forward( { x: limits.max.x, y: limits.max.y } ) );

			this.provider.crs = displayCRS;
			this.hasCoverage = ( coverage === undefined ) ? true : coverage.intersectsBox( wgs84Limits );

			return this.hasCoverage;

		}

		showAttribution () {

			const attribution = this.attribution;

			if ( attribution !== undefined ) this.ctx.container.appendChild( attribution );

		}

		hideAttribution () {

			const attribution = this.attribution;
			const parent = attribution.parentNode;

			if ( parent !== null ) parent.removeChild( attribution );

		}

		getTile ( tile ) {

			let x = tile.x;
			let y = tile.y;
			let z = tile.zoom;

			const cfg = this.ctx.cfg;
			const materials = this.ctx.materials;

			const material = this.materialCache.get( tile );
			const overlayMaxZoom = this.provider.maxZoom;

			let repeat = 1;
			let xOffset = 0;
			let yOffset = 0;

			if ( material !== undefined ) {

				return Promise.resolve( this.active ? material : null );

			}

			const zoomDelta = z - overlayMaxZoom;

			if ( zoomDelta > 0 ) {

				const scale = Math.pow( 2, zoomDelta );

				repeat = 1 / scale;

				// get image for lower zoom
				const newX = Math.floor( x * repeat );
				const newY = Math.floor( y * repeat );

				xOffset = ( x - newX * scale ) / scale;
				yOffset = 1 - ( y - newY * scale ) / scale;
				yOffset -= repeat;

				x = newX;
				y = newY;
				z = overlayMaxZoom;

			}

			let urlPromise;

			if ( this.provider.getPromise ) {

				urlPromise = this.provider.getPromise( x, y, z );

			} else {

				const url = this.provider.getUrl( x, y, z );

				if ( url === null || this.missing.has( url ) ) {

					return Promise.resolve( materials.getMissingMaterial() );

				}

				urlPromise = Promise.resolve( url );

			}

			return urlPromise.then( url => {

				return new Promise( resolve => {

					new TextureLoader()
						.setCrossOrigin( 'anonymous' )
						.load(
							url,
							// success handler
							texture => {

								if ( ! this.active ) {

									texture.dispose();

									resolve( null );
									return;

								}

								const material = new TerrainOverlayMaterial( this.ctx );

								texture.anisotropy = cfg.value( 'anisotropy', 4 );
								texture.repeat.setScalar( repeat );
								texture.offset.set( xOffset, yOffset );

								material.map = texture;
								material.needsUpdate = true;

								this.materialCache.set( tile, material );

								resolve( material );

							},

							// progress handler
							undefined,
							// error handler
							() => {

								this.missing.add( url );
								resolve( this.active ? materials.getMissingMaterial() : null );

							}
						);
				} );

			} );

		}

		setActive () {

			this.showAttribution();
			this.active = true;

		}

		setInactive () {

			// flush cache
			this.materialCache.forEach( material => {

				material.map.dispose();
				material.dispose();

			} );

			this.materialCache.clear();

			this.hideAttribution();
			this.active = false;

		}

	}

	class CommonTerrain extends Group {

		constructor ( ctx ) {

			super();

			this.hasOverlay = false;
			this.activeOverlay = null;
			this.depthTexture = null;
			this.renderer = null;
			this.renderTarget = null;
			this.heightLookup = null;
			this.datumShift = 0;
			this.activeDatumShift = 0;
			this.terrainBase = null;
			this.terrainRange = null;
			this.isFlat = false;
			this.screenAttribution = null;
			this.terrainShadingModes = {};
			this.commonUniforms = ctx.materials.commonTerrainUniforms;
			this.ctx = ctx;
			this.shadingMode = SHADING_RELIEF;

			this.addEventListener( 'removed', () => this.removed() );

		}

		removed () {}

		getOpacity () {

			return this.ctx.materials.terrainOpacity;

		}

		setOpacity ( opacity ) {

			this.ctx.materials.terrainOpacity = opacity;

		}

		commonRemoved () {

			const activeOverlay = this.activeOverlay;

			if ( activeOverlay !== null ) activeOverlay.setInactive();

			if ( this.renderTarget !== null ) this.renderTarget.dispose();

		}

		checkTerrainShadingModes ( renderer ) {

			const overlays = this.ctx.overlays;
			const terrainShadingModes = {};

			terrainShadingModes[ 'terrain.shading.height' ] = SHADING_RELIEF;

			if ( renderer.capabilities.isWebGL2 || renderer.extensions.get( 'OES_standard_derivatives' ) !== null && ! this.isFlat ) {

				terrainShadingModes[ 'terrain.shading.contours' + ' (' + this.ctx.cfg.themeValue( 'shading.contours.interval' ) + '\u202fm)' ] = SHADING_CONTOURS;

			}

			if ( this.isTiled && overlays) {

				Object.keys( overlays ).sort().forEach( name => {

					const overlay = overlays[ name ];

					if ( overlay.checkCoverage( this.limits, this.displayCRS, this.surveyCRS ) ) {

						overlay.active = ( this.activeOverlay === overlay );
						terrainShadingModes[ name ] = name;

					}

				} );

			} else if ( this.hasOverlay ) {

				terrainShadingModes[ 'terrain.shading.overlay' ] = SHADING_OVERLAY;

			}

			this.terrainShadingModes = terrainShadingModes;

			return terrainShadingModes;

		}

		setup ( renderer, scene, survey ) {

			this.computeBoundingBox();

			survey.addStatic( this );

			const dim = 1024;

			const container = this.ctx.container;
			const renderUtils = this.ctx.renderUtils;
			// set camera frustrum to cover region/survey area
			const rtCamera = renderUtils.makePlanCamera( container, survey );

			rtCamera.layers.set( FEATURE_TERRAIN ); // just render the terrain

			const renderTarget = renderUtils.makeRenderTarget( dim, dim );

			renderTarget.texture.generateMipmaps = false;
			renderTarget.texture.name = 'CV.DepthMapTexture';

			renderer.setSize( dim, dim );
			renderer.setPixelRatio( 1 );

			renderer.clear();

			renderer.setRenderTarget( renderTarget );

			scene.overrideMaterial = new DepthMapMaterial( this );

			renderer.render( scene, rtCamera );

			scene.overrideMaterial = null;

			this.depthTexture = renderTarget.texture;
			this.renderer = renderer;
			this.renderTarget = renderTarget;

			// add lookup using heightMap texture
			this.heightLookup = new HeightLookup( renderer, renderTarget, this.boundingBox, survey.offsets );

			this.checkTerrainShadingModes( renderer );

			// restore renderer to normal render size and target

			renderer.renderLists.dispose();

			// restore renderer to normal render size and target

			this.ctx.viewer.resetRenderer();

			survey.setupTerrain( this );
			this.ctx.materials.setTerrain( this );

		}

		setShadingMode ( mode, renderCallback ) {

			const activeOverlay = this.activeOverlay;
			const materials = this.ctx.materials;
			const overlays = this.ctx.overlays;

			let material;
			let hideAttribution = true;
			let overlay = null;

			switch ( mode ) {

			case SHADING_RELIEF:

				material = materials.getHypsometricMaterial();

				break;

			case SHADING_OVERLAY:

				this.setOverlay( renderCallback );
				hideAttribution = false;

				break;

			case SHADING_CONTOURS:

				material = materials.getContourMaterial();

				break;

			default:

				overlay = overlays[ mode ];

				if ( overlay !== undefined ) {

					if ( this.isTiled && overlay.hasCoverage ) {

						this.setOverlay( overlay, renderCallback );
						hideAttribution = false;

					} else {

						// if initial setting is not valid, default to shaded relief
						material = materials.getHypsometricMaterial();
						mode = SHADING_RELIEF;

					}

				} else {

					console.warn( 'unknown mode', mode );
					return false;

				}

			}

			if ( hideAttribution && activeOverlay !== null ) {

				activeOverlay.setInactive();

				this.activeOverlay = null;

			}

			if ( material !== undefined ) {

				this.setMaterial( material );

			}

			this.shadingMode = mode;

			return true;

		}

		setVisibility ( mode ) {

			this.visible = mode;

			if ( mode ) {

				this.showAttribution();

			} else {

				this.hideAttribution();

			}

		}

		showAttribution () {

			const attribution = this.screenAttribution;

			if ( attribution !== null ) {

				this.ctx.container.appendChild( attribution );

			}

			if ( this.activeOverlay !== null ) this.activeOverlay.showAttribution();

		}

		hideAttribution () {

			const attribution = this.screenAttribution;

			if ( attribution !== null ) {

				const parent = attribution.parentNode;

				if ( parent !== null ) parent.removeChild( attribution );


			}

			if ( this.activeOverlay !== null ) this.activeOverlay.hideAttribution();

		}

		applyDatumShift ( mode ) {

			if ( mode && this.activeDatumShift === 0 ) {

				this.translateZ( this.datumShift );
				this.activeDatumShift = this.datumShift;

			} else if ( ! mode && this.activeDatumShift !== 0 ) {

				this.translateZ( - this.datumShift );
				this.activeDatumShift = 0;

			}

			this.updateMatrix();

			this.dispatchEvent( { type: 'datumShiftChange', value: this.activeDatumShift } );

		}

		computeBoundingBox () {

			const bb = new Box3();

			this.traverse( _getBoundingBox );

			this.boundingBox = bb;

			function _getBoundingBox( obj ) {

				if ( obj.isTile && obj.isMesh ) bb.union( obj.geometry.boundingBox );

			}

			return bb;

		}

		getHeight ( point ) {

			return this.heightLookup.lookup( point );

		}

		_fitSurface ( modelPoints /*, offsets */ ) {

			const points = modelPoints;

			let n = 0, s1 = 0, s2 = 0;

			points.forEach( point => {

				const v = point.z - this.getHeight( point );
				s1 += v;
				s2 += v * v;
				n++;

			} );

			const sd = Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) );

			// simple average
			//this.datumShift = s1 / n;
			this.ctx.viewer.terrainDatumShiftValue = s1 / n;

			console.log( `Adjustmenting terrain height by: ${this.datumShift} sd: ${sd} n: ${n} --` );

		}

	}

	CommonTerrain.addOverlay = function ( ctx, name, overlayProvider ) {

		if ( ctx.overlays === undefined ) ctx.overlays = {};

		ctx.overlays[ name ] = new Overlay( ctx, overlayProvider );

	};

	class ExportGltf {

		constructor ( ctx, survey, selection, options, callback ) {

			const items = [];

			if ( selection.walls ) {

				items.push( getMesh( FACE_WALLS ) );

			}

			if ( selection.scraps ) {

				items.push( getMesh( FACE_SCRAPS ) );

			}

			if ( selection.legs ) {

				const legs = survey.getFeature( LEG_CAVE );

				const geometry = legs.geometry;

				// the underlying array of the interleavedInstanceBuffer is correct for GL_LINES
				const array = geometry.getAttribute( 'instanceStart' ).array;

				items.push( {
					type: 'lines',
					index: geometry.index,
					position: new Float32BufferAttribute( array, 3, false ),
					modelLimits: survey.modelLimits
				} );

			}

			if ( items.length === 0 ) return;

			const worker = new Worker( ctx.cfg.value( 'home', '' ) + 'js/workers/gltfWorker.js' );

			worker.addEventListener( 'message', function ( event ) {

				if ( event.data.status === 'ok' ) {

					let mimeType;

					if ( options.binary ) {

						mimeType = 'application/octet-stream';

					} else {

						mimeType = 'application/gltf+json';

					}

					callback( new Blob( [ event.data.gltf ], { type : mimeType } ), options.binary );

				} else {

					console.warn( event.data.error );

				}

				worker.terminate();

			} );

			worker.postMessage( { items: items, options: options } );

			function getMesh ( tag ) {

				const mesh = survey.getFeature( tag );
				const geometry = mesh.geometry;

				return {
					type: 'walls',
					index: geometry.index,
					position: geometry.getAttribute( 'position' ),
					modelLimits: survey.modelLimits
				};
			}

		}

	}

	const _box$1 = new Box3();
	const _vector = new Vector3();

	class LineSegmentsGeometry extends InstancedBufferGeometry {

		isLineSegmentsGeometry = true;

		constructor () {

			super();

			this.type = 'LineSegmentsGeometry';

			const positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];
			const uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];
			const index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];

			this.setIndex( index );
			this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

		applyMatrix4 ( matrix ) {

			const start = this.attributes.instanceStart;
			const end = this.attributes.instanceEnd;

			if ( start !== undefined ) {

				start.applyMatrix4( matrix );

				end.applyMatrix4( matrix );

				start.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		}

		setPositions ( array ) {

			let lineSegments;

			if ( array instanceof Float32Array ) {

				lineSegments = array;

			} else if ( Array.isArray( array ) ) {

				lineSegments = new Float32Array( array );

			}

			const instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

			this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
			this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

			//

			this.computeBoundingBox();
			this.computeBoundingSphere();

			return this;

		}

		setColors ( array ) {

			let colors;

			if ( array instanceof Float32Array ) {

				colors = array;

			} else if ( Array.isArray( array ) ) {

				colors = new Float32Array( array );

			}

			const instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

			this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
			this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

			return this;

		}

		setHide ( array ) {

			let hiddenVertices;

			if ( array instanceof Float32Array ) {

				hiddenVertices = array;

			} else if ( Array.isArray( array ) ) {

				hiddenVertices = new Float32Array( array );

			}

			this.setAttribute( 'instanceHideVertex', new InstancedBufferAttribute( hiddenVertices, 1, false, 1 ) );

			return this;

		}

		clearHide () {

			this.deleteAttribute( 'instanceHideVertex' );

		}

		computeBoundingBox () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const start = this.attributes.instanceStart;
			const end = this.attributes.instanceEnd;

			if ( start !== undefined && end !== undefined ) {

				this.boundingBox.setFromBufferAttribute( start );

				_box$1.setFromBufferAttribute( end );

				this.boundingBox.union( _box$1 );

			}


		}

		computeBoundingSphere () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			if ( this.boundingBox === null ) {

				this.computeBoundingBox();

			}

			const start = this.attributes.instanceStart;
			const end = this.attributes.instanceEnd;

			if ( start !== undefined && end !== undefined ) {

				const center = this.boundingSphere.center;

				this.boundingBox.getCenter( center );

				let maxRadiusSq = 0;

				for ( let i = 0, il = start.count; i < il; i ++ ) {

					_vector.fromBufferAttribute( start, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

					_vector.fromBufferAttribute( end, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

				}

			}

		}

	}

	const uniforms = mergeUniforms( [
		UniformsLib.common,
		UniformsLib.fog,
		{
			linewidth: { value: 1 },
			resolution: { value: new Vector2( 1, 1 ) },
			dashScale: { value: 1 },
			dashSize: { value: 1 },
			dashOffset: { value: 0 },
			gapSize: { value: 1 },
			opacity: { value: 1 }
		}
	] );

	class Line2Material extends ShaderMaterial {

		isLineMaterial = true;

		constructor ( ctx, params, defines = { CV_BASIC: true }, callerUniforms = {} ) {

			super( {

				type: 'LineMaterial',

				uniforms: Object.assign(
					cloneUniforms( uniforms ),
					ctx.materials.uniforms.common,
					callerUniforms
				),

				vertexShader: Shaders.lineVertexShader,
				fragmentShader: Shaders.lineFragmentShader,

				clipping: true, // required for clipping support
				defines: defines
			} );

			this.dashed = false;
			this.ctx = ctx;

			Object.defineProperties( this, {

				color: {

					enumerable: true,

					get: function () {

						return this.uniforms.diffuse.value;

					},

					set: function ( value ) {

						this.uniforms.diffuse.value = value;

					}

				},

				linewidth: {

					enumerable: true,

					get: function () {

						return this.uniforms.linewidth.value;

					},

					set: function ( value ) {

						this.uniforms.linewidth.value = value;

					}

				},

				dashScale: {

					enumerable: true,

					get: function () {

						return this.uniforms.dashScale.value;

					},

					set: function ( value ) {

						this.uniforms.dashScale.value = value;

					}

				},

				dashSize: {

					enumerable: true,

					get: function () {

						return this.uniforms.dashSize.value;

					},

					set: function ( value ) {

						this.uniforms.dashSize.value = value;

					}

				},

				dashOffset: {

					enumerable: true,

					get: function () {

						return this.uniforms.dashOffset.value;

					},

					set: function ( value ) {

						this.uniforms.dashOffset.value = value;

					}

				},

				gapSize: {

					enumerable: true,

					get: function () {

						return this.uniforms.gapSize.value;

					},

					set: function ( value ) {

						this.uniforms.gapSize.value = value;

					}

				},

				opacity: {

					enumerable: true,

					get: function () {

						return this.uniforms.opacity.value;

					},

					set: function ( value ) {

						this.uniforms.opacity.value = value;

					}

				},

				resolution: {

					enumerable: true,

					get: function () {

						return this.uniforms.resolution.value;

					},

					set: function ( value ) {

						this.uniforms.resolution.value.copy( value );

					}

				},

				scaleLinewidth: {

					enumerable: true,

					get: function () { return this.defined.CV_SCALEWIDTH; },

					set: function ( value ) {

						this.defines.CV_SCALEWIDTH = value;
						this.needsUpdate = true;

					}

				}

			} );

			this.onResize = ( e ) => {

				const lineScale = e.lineScale ? e.lineScale : 1;

				this.resolution = new Vector2( e.width, e.height );
				this.linewidth = Math.max( 1, Math.floor( e.width / 1000 ) * lineScale );

			};

			this.setValues( params );

			this.resolution = new Vector2( ctx.container.clientWidth, ctx.container.clientHeight );

			ctx.viewer.addEventListener( 'resized', this.onResize );

		}

		dispose () {

			this.ctx.viewer.removeEventListener( 'resized', this.onResize );
			super.dispose();

		}

	}

	const _start = new Vector3();
	const _end = new Vector3();
	const _start4 = new Vector4();
	const _end4 = new Vector4();
	const _ssOrigin$2 = new Vector4();
	const _ssOrigin3 = new Vector3();
	const _mvMatrix$1 = new Matrix4();
	const _line = new Line3();
	const _closestPoint = new Vector3();
	const _box = new Box3();
	const _sphere = new Sphere();
	const _clipToWorldVector = new Vector4();

	class LineSegments2 extends Mesh {

		LineSegments2 = true;

		constructor( geometry = new LineSegmentsGeometry(), material = new Line2Material( {
			color: Math.random() * 0xffffff
		} ) ) {

			super( geometry, material );
			this.type = 'LineSegments2';

		}

		// for backwards-compatability, but could be a method of LineSegmentsGeometry...
		computeLineDistances() {

			const geometry = this.geometry;
			const instanceStart = geometry.attributes.instanceStart;
			const instanceEnd = geometry.attributes.instanceEnd;
			const lineDistances = new Float32Array( 2 * instanceStart.count );

			for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {

				_start.fromBufferAttribute( instanceStart, i );

				_end.fromBufferAttribute( instanceEnd, i );

				lineDistances[ j ] = j === 0 ? 0 : lineDistances[ j - 1 ];
				lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );

			}

			const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

			geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0

			geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

			return this;

		}

		raycast( raycaster, intersects ) {

			if ( raycaster.camera === null ) {

				console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.' );

			}

			const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;
			const ray = raycaster.ray;
			const camera = raycaster.camera;
			const projectionMatrix = camera.projectionMatrix;
			const matrixWorld = this.matrixWorld;
			const geometry = this.geometry;
			const material = this.material;
			const resolution = material.resolution;
			const lineWidth = material.linewidth + threshold;
			const instanceStart = geometry.attributes.instanceStart;
			const instanceEnd = geometry.attributes.instanceEnd; // camera forward is negative

			const near = - camera.near; // clip space is [ - 1, 1 ] so multiply by two to get the full
			// width in clip space

			const ssMaxWidth = 2.0 * Math.max( lineWidth / resolution.width, lineWidth / resolution.height ); //
			// check if we intersect the sphere bounds

			if ( geometry.boundingSphere === null ) {

				geometry.computeBoundingSphere();

			}

			_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );

			const distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( ray.origin ) ); // get the w component to scale the world space line width

			_clipToWorldVector.set( 0, 0, - distanceToSphere, 1.0 ).applyMatrix4( camera.projectionMatrix );

			_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );

			_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse ); // increase the sphere bounds by the worst case line screen space width


			const sphereMargin = Math.abs( ssMaxWidth / _clipToWorldVector.w ) * 0.5;
			_sphere.radius += sphereMargin;

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) {

				return;

			} //
			// check if we intersect the box bounds


			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );

			const distanceToBox = Math.max( camera.near, _box.distanceToPoint( ray.origin ) ); // get the w component to scale the world space line width

			_clipToWorldVector.set( 0, 0, - distanceToBox, 1.0 ).applyMatrix4( camera.projectionMatrix );

			_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );

			_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse ); // increase the sphere bounds by the worst case line screen space width


			const boxMargin = Math.abs( ssMaxWidth / _clipToWorldVector.w ) * 0.5;

			_box.expandByScalar( boxMargin );


			if ( raycaster.ray.intersectsBox( _box ) === false ) {

				return;

			} //
			// pick a point 1 unit out along the ray to avoid the ray origin
			// sitting at the camera origin which will cause "w" to be 0 when
			// applying the projection matrix.


			ray.at( 1, _ssOrigin$2 ); // ndc space [ - 1.0, 1.0 ]

			_ssOrigin$2.w = 1;

			_ssOrigin$2.applyMatrix4( camera.matrixWorldInverse );

			_ssOrigin$2.applyMatrix4( projectionMatrix );

			_ssOrigin$2.multiplyScalar( 1 / _ssOrigin$2.w ); // screen space


			_ssOrigin$2.x *= resolution.x / 2;
			_ssOrigin$2.y *= resolution.y / 2;
			_ssOrigin$2.z = 0;

			_ssOrigin3.copy( _ssOrigin$2 );

			_mvMatrix$1.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );

			for ( let i = 0, l = instanceStart.count; i < l; i ++ ) {

				_start4.fromBufferAttribute( instanceStart, i );

				_end4.fromBufferAttribute( instanceEnd, i );

				_start4.w = 1;
				_end4.w = 1; // camera space

				_start4.applyMatrix4( _mvMatrix$1 );

				_end4.applyMatrix4( _mvMatrix$1 ); // skip the segment if it's entirely behind the camera


				const isBehindCameraNear = _start4.z > near && _end4.z > near;

				if ( isBehindCameraNear ) {

					continue;

				} // trim the segment if it extends behind camera near


				if ( _start4.z > near ) {

					const deltaDist = _start4.z - _end4.z;
					const t = ( _start4.z - near ) / deltaDist;

					_start4.lerp( _end4, t );

				} else if ( _end4.z > near ) {

					const deltaDist = _end4.z - _start4.z;
					const t = ( _end4.z - near ) / deltaDist;

					_end4.lerp( _start4, t );

				} // clip space


				_start4.applyMatrix4( projectionMatrix );

				_end4.applyMatrix4( projectionMatrix ); // ndc space [ - 1.0, 1.0 ]


				_start4.multiplyScalar( 1 / _start4.w );

				_end4.multiplyScalar( 1 / _end4.w ); // screen space


				_start4.x *= resolution.x / 2;
				_start4.y *= resolution.y / 2;
				_end4.x *= resolution.x / 2;
				_end4.y *= resolution.y / 2; // create 2d segment

				_line.start.copy( _start4 );

				_line.start.z = 0;

				_line.end.copy( _end4 );

				_line.end.z = 0; // get closest point on ray to segment

				const param = _line.closestPointToPointParameter( _ssOrigin3, true );

				_line.at( param, _closestPoint ); // check if the intersection point is within clip space


				const zPos = lerp( _start4.z, _end4.z, param );
				const isInClipSpace = zPos >= - 1 && zPos <= 1;
				const isInside = _ssOrigin3.distanceTo( _closestPoint ) < lineWidth * 4.5;

				if ( isInClipSpace && isInside ) {

					_line.start.fromBufferAttribute( instanceStart, i );

					_line.end.fromBufferAttribute( instanceEnd, i );

					_line.start.applyMatrix4( matrixWorld );

					_line.end.applyMatrix4( matrixWorld );

					const pointOnLine = new Vector3();
					const point = new Vector3();
					ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );
					intersects.push( {
						point: point,
						pointOnLine: pointOnLine,
						distance: ray.origin.distanceTo( point ),
						object: this,
						face: null,
						faceIndex: i,
						uv: null,
						uv2: null
					} );

				}

			}

		}

	}

	// attributes to construct unit square

	const indexAttribute = new Uint16BufferAttribute( [ 0, 2, 1, 0, 3, 2 ], 1 );

	const positionAttribute = new Float32BufferAttribute( [
		0, 0, 0,
		0, 1, 0,
		1, 1, 0,
		1, 0, 0
	], 3 );

	const CommonAttributes = {
		index: indexAttribute,
		position: positionAttribute
	};

	class GlyphStringGeometryCache {

		constructor ( material ) {

			this.material = material;
			this.cache = {};

		}

		getGeometry ( text, yOffset ) {

			let entry = this.cache[ text ];

			if ( entry === undefined ) {

				entry = new GlyphStringGeometry( text, this.material.getAtlas(), yOffset );
				this.cache[ text ] = entry;
				entry.isCached = true;

			}

			return entry;

		}

	}

	class GlyphStringGeometry extends InstancedBufferGeometry {

		constructor ( text, glyphAtlas, yOffset = 0 ) {

			super();

			this.type = 'GlyphStringGeometry';
			this.width = 0;

			yOffset /= glyphAtlas.cellSize;

			this.setIndex( CommonAttributes.index );
			this.setAttribute( 'position', CommonAttributes.position );
			this.setAttribute( 'offsets', new Float32BufferAttribute( [ yOffset, yOffset, yOffset, yOffset, yOffset, yOffset ], 1 ) );

			this.glyphAtlas = glyphAtlas;

			const buffer = new Float32Array( text.length * 4 );
			const instanceBuffer = new InstancedInterleavedBuffer( buffer, 4, 1 ); // uv, offset, widths

			this.instanceBuffer = instanceBuffer;

			this.setAttribute( 'instanceUvs', new InterleavedBufferAttribute( instanceBuffer, 2, 0 ) );
			this.setAttribute( 'instanceOffsets', new InterleavedBufferAttribute( instanceBuffer, 1, 2 ) );
			this.setAttribute( 'instanceWidths', new InterleavedBufferAttribute( instanceBuffer, 1, 3 ) );

			this.setString( text );

			this.computeBoundingSphere();

		}

		dispose () {

			if ( this.isCached ) return;

			// delete shared attributes to prevent internal render state
			// being lost on dispose() call.

			this.deleteAttribute( 'position' );
			this.setIndex( null );

			super.dispose();

		}

		setString ( text ) {

			const instanceUvs = this.getAttribute( 'instanceUvs' );
			const instanceOffsets = this.getAttribute( 'instanceOffsets' );
			const instanceWidths = this.getAttribute( 'instanceWidths' );

			const l = text.length, glyphAtlas = this.glyphAtlas;

			let offset = 0;

			for ( let i = 0; i < l; i++ ) {

				if ( text.charCodeAt( i ) === 0 ) continue; // skip null characters
				const glyphData = glyphAtlas.getGlyph( text[ i ] );

				instanceUvs.setXY( i, glyphData.column, glyphData.row );
				instanceWidths.setX( i, glyphData.width );
				instanceOffsets.setX( i, offset );

				offset += glyphData.width;

			}

			instanceUvs.needsUpdate = true;
			instanceOffsets.needsUpdate = true;
			instanceWidths.needsUpdate = true;

			this.width = offset;
			this.name = text;

		}

	}

	// temporary objects for raycasting

	const _ssOrigin$1 = new Vector4();
	const _mouse$1 = new Vector3();
	const _labelEnd = new Vector3();
	const _ssLabelOrigin = new Vector3();

	class GlyphStringBase extends Mesh {

		constructor ( text, glyphMaterial, geometry ) {

			super( geometry, glyphMaterial );

			this.name = text;
			this.type = 'CV.GlyphString';

			this.labelOrigin = new Vector3();
			this.labelOffset = new Vector2();
			this.labelBox = new Box2();
			this.lastFrame = 0;

			this.updateLabelOffset();

		}

		getWidth () {

			return this.geometry.width * this.material.scaleFactor;

		}

		getHeight () {

			return this.material.scaleFactor;

		}

		updateLabelOffset () {

			this.labelOffset.set( this.getWidth(), this.getHeight(), 0 );

			this.material.rotateVector( this.labelOffset );
			this.material.rotateVector( this.labelOffset );

		}

		updateLabelBox ( camera ) {

			const glyphMaterial = this.material;
			const scale = glyphMaterial.toScreenSpace;
			const labelOrigin = this.labelOrigin;

			// get box origin in screen space
			this.getWorldPosition( _ssLabelOrigin );

			labelOrigin.copy( _ssLabelOrigin );
			labelOrigin.project( camera );
			labelOrigin.multiply( scale );

			// rotate into alignment with text rotation
			glyphMaterial.rotateVector( labelOrigin );

			// find other corner = origin + offset (maintained in coords aligned with rotation)
			_labelEnd.copy( labelOrigin );
			_labelEnd.add( this.labelOffset );

			this.labelBox.setFromPoints( [ labelOrigin, _labelEnd ] );

		}

		getDepth( cameraManager ) {

			if ( this.lastFrame < cameraManager.getLastFrame() ) {

				this.updateLabelBox( cameraManager.activeCamera );
				this.lastFrame = cameraManager.getLastFrame();

			}

			// label origin in screen space
			return this.labelOrigin.z;

		}

		checkOcclusion ( labels, currentIndex ) {

			if ( ! this.visible ) return;

			const l = labels.length;

			for ( let i = currentIndex  + 1; i < l; i++ ) {

				const nextLabel = labels[ i ];

				if ( ! nextLabel.visible ) continue;

				if ( this.labelBox.intersectsBox( nextLabel.labelBox ) ) {

					this.visible = false;
					return;

				}

			}

		}

		raycast ( raycaster, intersects ) {

			if ( ! this.visible ) return intersects;

			const ray = raycaster.ray;
			const camera = raycaster.camera;
			const glyphMaterial = this.material;
			const scale = glyphMaterial.toScreenSpace;

			ray.at( 1, _ssOrigin$1 );

			// ndc space [ - 1.0, 1.0 ]

			_ssOrigin$1.w = 1;

			_ssOrigin$1.applyMatrix4( camera.matrixWorldInverse );
			_ssOrigin$1.applyMatrix4( camera.projectionMatrix );
			_ssOrigin$1.multiplyScalar( 1 / _ssOrigin$1.w );

			// screen space
			_mouse$1.copy( _ssOrigin$1 );
			_mouse$1.multiply( scale );

			// rotated screen space
			glyphMaterial.rotateVector( _mouse$1 );

			// FIXME - we don't check for objects outside of view
			this.updateLabelBox( camera );

			if ( this.labelBox.containsPoint( _mouse$1 ) ) {

				intersects.push( { object: this, distance: raycaster.ray.origin.distanceTo( _ssLabelOrigin ) } );

			}

			return intersects;

		}

	}

	class GlyphString extends GlyphStringBase {

		constructor ( text, glyphMaterial, ctx, yOffset ) {

			const glyphStringCache = ctx.glyphStringCache;

			let cache = glyphStringCache.get( glyphMaterial );

			if ( cache === undefined ) {

				// create material cache
				cache = new GlyphStringGeometryCache( glyphMaterial );
				glyphStringCache.set( glyphMaterial, cache );

			}

			const geometry = cache.getGeometry( text, yOffset );

			super( text, glyphMaterial, geometry );

			geometry.instanceBuffer.onUpload( Object3D.onUploadDropBuffer );

		}

	}

	class MutableGlyphString extends GlyphStringBase {

		constructor ( text, glyphMaterial ) {

			super( text, glyphMaterial, new GlyphStringGeometry( text, glyphMaterial.getAtlas() ) );

		}

		replaceString ( newstring ) {

			if ( newstring.length !== this.name.length ) {

				console.warn( 'new string has invalid length', newstring, this.name.length, newstring.length );
				return;

			}

			this.geometry.setString( newstring );
			this.updateLabelOffset();

		}

	}

	// preallocated tmp objects
	const __xAxis = new Vector3( 1, 0, 0 );
	const __direction$1 = new Vector3();

	class AHI extends Group {

		constructor ( hudObject ) {

			const stdWidth  = hudObject.stdWidth;
			const stdMargin = hudObject.stdMargin;

			const ctx = hudObject.ctx;
			const cfg = ctx.cfg;
			const materials = ctx.materials;

			const c1 = cfg.themeColor( 'hud.ahi.sky' );
			const c2 = cfg.themeColor( 'hud.ahi.earth' );

			super();

			this.name = 'CV.AHI';
			this.visible = false;

			this.lastPitch = 0;

			// artificial horizon instrument
			const globe = new Group();

			const ring = hudObject.getCommonRing();
			const ahiWidth = stdWidth * 0.75;

			const sphere = new SphereGeometry( ahiWidth, 31, 31 );
			const bar    = new LineSegmentsGeometry();
			const marks  = new LineSegmentsGeometry();

			const sv = sphere.getAttribute( 'position' ).count;

			const sphereColors = new Float32BufferAttribute( new Float32Array( sv * 3 ), 3 );

			for ( let i = 0; i < sv; i++ ) {

				( ( i < sv / 2 ) ? c1 : c2 ).toArray( sphereColors.array, i * 3 );

			}

			sphere.setAttribute( 'color', sphereColors );

			let vertices = [];

			// view orientation line

			vertices.push( 4 - stdWidth, 0, ahiWidth );
			vertices.push( stdWidth - 4, 0, ahiWidth );

			bar.setPositions( vertices );

			const markWidth = stdWidth / 10;

			// pitch interval marks
			const m1 = new Vector3(  markWidth, 0, ahiWidth + 1 );
			const m2 = new Vector3( -markWidth, 0, ahiWidth + 1 );

			vertices = [];

			for ( let i = 0; i < 12; i++ ) {

				const mn1 = m1.clone();
				const mn2 = m2.clone();

				if ( i % 3 === 0 ) {

					mn1.x *= 2;
					mn2.x *= 2;

				}

				mn1.applyAxisAngle( __xAxis, i * Math.PI / 6 );
				mn2.applyAxisAngle( __xAxis, i * Math.PI / 6 );

				vertices.push( mn1.x, mn1.y, mn1.z, mn2.x, mn2.y, mn2.z );

			}

			marks.setPositions( vertices );

			const mRing   = new Mesh( ring, materials.getBezelMaterial() );
			const mSphere = new Mesh( sphere, new MeshPhongMaterial( { vertexColors: true, specular: 0x666666, shininess: 20 } ) );
			const mBar    = new LineSegments2( bar,   new Line2Material( ctx, { color: cfg.themeValue( 'hud.ahi.bar' ) } ) );
			const mMarks  = new LineSegments2( marks, new Line2Material( ctx, { color: cfg.themeValue( 'hud.ahi.marks' ) } ) );

			mSphere.rotateOnAxis( new Vector3( 0, 1, 0 ), Math.PI / 2 );
			mMarks.rotateOnAxis( new Vector3( 1, 0, 0 ), Math.PI / 2 );
			mRing.rotateOnAxis( new Vector3( 0, 0, 1 ), Math.PI / 8 );

			mSphere.dropBuffers();

			globe.addStatic( mSphere );
			globe.addStatic( mMarks );

			this.addStatic( mRing );
			this.addStatic( mBar );

			this.add( globe );

			const offset = stdWidth + stdMargin;

			this.translateX( -3 * offset );
			this.translateY( offset );

			this.globe = globe;

			const material = materials.getLabelMaterial( 'hud' );
			const label = new MutableGlyphString( '-90\u00B0', material );

			label.translateX( - label.getWidth() / 2 );
			label.translateY( stdWidth + 5 );

			this.addStatic( label );

			this.label = label;

			return this;

		}

		set ( vCamera ) {

			vCamera.getWorldDirection( __direction$1 );

			const pitch = Math.PI / 2 - __direction$1.angleTo( Object3D.DefaultUp );

			if ( pitch === this.lastPitch ) return;

			this.globe.rotateOnAxis( __xAxis, pitch - this.lastPitch );
			this.lastPitch = pitch;
			this.label.replaceString( String( Math.round( radToDeg$1( pitch ) ) + '\u00B0' ).padStart( 4, ' ' ) );

		}

	}

	class Control {

		constructor ( container, width, height, onEnter ) {

			this.hitRegion = this.createHitRegion( width, height, onEnter );
			this.container = container;

		}

		createHitRegion ( width, height, onEnter ) {

			const div = document.createElement( 'div' );

			div.style.width = width + 'px';
			div.style.height = height + 'px';
			div.style.position = 'absolute';

			div.setAttribute( 'draggable', 'false' );
			div.addEventListener( 'dragstart', e => e.preventDefault() );

			div.addEventListener( 'pointerenter', onEnter );

			return div;

		}

		positionHitRegion ( right, bottom ) {

			const hr = this.hitRegion;

			hr.style.right = right + 'px';
			hr.style.bottom = bottom + 'px';

			this.container.appendChild( hr );

		}

		commonEnter ( target, handlers ) {

			for ( const event in handlers ) {

				target.addEventListener( event, handlers[ event ] );

			}

			this.rect = this.hitRegion.getBoundingClientRect();
			this.hitRegion.style.cursor = 'pointer';

		}

		commonLeave ( target, handlers ) {

			for ( const event in handlers ) {

				target.removeEventListener( event, handlers[ event ] );

			}

			this.hitRegion.style.cursor = 'default';

		}

		dispose () {

			const hr = this.hitRegion;
			hr.parentNode.removeChild( hr );

		}

	}

	const d30 = Math.PI / 6;

	class AHIControl extends Control {

		constructor ( hudObject, viewer ) {

			const dim = hudObject.stdWidth * 2;

			super( viewer.container, dim, dim, handleEnter );

			const controls = viewer.getControls();

			const ballSize = hudObject.stdWidth - 10;

			let dragging = false;
			let dragged = false;
			let centerY;
			let lastAngle;

			this.positionHitRegion( hudObject.stdMargin * 3 + hudObject.stdWidth * 2, hudObject.stdMargin );

			const handlers = {
				pointerleave: handleLeave,
				pointermove:  handlePointerMove,
				pointerdown:  handlePointerDown,
				pointerup:    handlePointerUp,
			};

			const self = this;

			function handleEnter ( event ) {

				if ( ! viewer.HUD ) return;

				self.commonEnter( event.currentTarget, handlers );

				// update center position (accounts for resizes)
				centerY = self.rect.top +  hudObject.stdWidth;
				dragging = false;

			}

			function handleLeave ( event ) {

				self.commonLeave( event.currentTarget, handlers );

			}

			function handlePointerDown ( event ) {

				event.stopPropagation();

				dragging = true;
				dragged = false;

				lastAngle = Math.atan( ( event.clientY - centerY ) / ballSize );
				self.hitRegion.setPointerCapture( event.pointerId );

			}

			function handlePointerUp ( event ) {

				event.stopPropagation();

				if ( ! dragged ) {

					const dir = Math.sign( event.clientY - centerY );

					// round to nearest 30 degrees and inc/dec by 30 degrees. clamping in orbit control.
					viewer.polarAngle = d30 * ( Math.round( viewer.polarAngle / d30 ) + dir );

				}

				controls.end();
				self.hitRegion.releasePointerCapture( event.pointerId );

				dragging = false;

			}

			function handlePointerMove ( event ) {

				event.stopPropagation();
				event.preventDefault();

				if ( ! dragging ) return;

				const angle = Math.atan( ( event.clientY - centerY ) / ballSize );

				controls.rotateUp( lastAngle - angle );

				lastAngle = angle;
				dragged = true;

			}

		}

	}

	class AngleScale extends Mesh {

		constructor ( hudObject, caption ) {

			const stdWidth  = hudObject.stdWidth;
			const stdMargin = hudObject.stdMargin;
			const materials = hudObject.ctx.materials;

			const pNormal = new Vector3( 1, 0, 0 );

			const geometry = new RingGeometry( 1, 40, 36, 1, Math.PI, Math.PI );

			const hues = materials.colourCache.getColorSet( 'inclination' );
			const colors = [];

			const vertices = geometry.getAttribute( 'position' );
			const vertexCount = vertices.count;
			const ringColors = new Float32BufferAttribute( vertexCount * 3, 3 );

			const v3 = new Vector3();

			for ( let i = 0; i < vertexCount; i++ ) {

				v3.fromBufferAttribute( vertices, i ).normalize();

				const hueIndex = Math.floor( 127 * 2 * Math.asin( Math.abs( v3.dot( pNormal ) ) ) / Math.PI );

				colors.push( hues[ hueIndex ] );

			}

			geometry.setAttribute( 'color', ringColors.copyColorsArray( colors ) );

			super( geometry, new MeshBasicMaterial( { color: 0xffffff, vertexColors: true } ) );

			this.translateY( 3 * ( stdWidth + stdMargin ) + stdMargin + 30 );
			this.translateX( - 40 - 5 );

			this.dropBuffers();

			this.name = 'CV.AngleScale';

			const material = materials.getLabelMaterial( 'hud' );
			const label = new GlyphString( caption, material, hudObject.ctx );

			label.translateX( - label.getWidth() / 2 );
			label.translateY( 5 );

			this.addStatic( label );

			this.visible = false;

		}

	}

	const __direction = new Vector3();
	const __negativeZAxis = new Vector3( 0, 0, -1 );
	const __e = new Euler();

	class Compass extends Group {

		constructor( hudObject ) {

			const stdWidth  = hudObject.stdWidth;
			const stdMargin = hudObject.stdMargin;
			const cfg = hudObject.ctx.cfg;
			const materials = hudObject.ctx.materials;

			super();

			this.name = 'CV.Compass';
			this.visible = false;

			const cg1 = hudObject.getCommonRing();

			const c1 = new Mesh( cg1, materials.getBezelMaterial() );

			const cg2 = new RingGeometry( stdWidth * 0.9, stdWidth, 4, 1, -Math.PI / 32 + Math.PI / 2, Math.PI / 16 );
			cg2.translate( 0, 0, 5 );

			const c2 = new Mesh( cg2, new MeshBasicMaterial( { color: cfg.themeValue( 'hud.compass.top1' ) } ) );

			c1.dropBuffers();
			c2.dropBuffers();

			const rMesh = _makeRose();

			const rotaryGroup = new Group();

			rotaryGroup.addStatic( c1 );
			rotaryGroup.addStatic( c2 );
			rotaryGroup.addStatic( rMesh );

			this.add( rotaryGroup );
			this.rotaryGroup = rotaryGroup;

			const offset = stdWidth + stdMargin;

			this.translateX( -offset );
			this.translateY(  offset );

			this.lastRotation = 0;

			const material = materials.getLabelMaterial( 'hud' );
			const label = new MutableGlyphString( '000\u00B0', material );

			label.translateX( - label.getWidth() / 2 );
			label.translateY( stdWidth + 5 );

			this.addStatic( label );

			this.label = label;

			return;

			function _makeRose() {

				const geometry = new BufferGeometry();
				const material = new MeshLambertMaterial( { vertexColors: true } );

				const mesh = new Mesh( geometry, material );

				const vertices = [];
				const colours = [];

				_makeRose2( cfg.themeColor( 'hud.compass.bottom1' ), cfg.themeColor( 'hud.compass.bottom2' ), Math.PI / 4 );
				_makeRose2( cfg.themeColor( 'hud.compass.top1' ), cfg.themeColor( 'hud.compass.top2' ), 0 );

				const positions = new Float32BufferAttribute( vertices.length, 3 );
				const colors = new Float32BufferAttribute( vertices.length * 3, 3 );

				geometry.setAttribute( 'position', positions.copyArray( vertices ) );
				geometry.setAttribute( 'color', colors.copyColorsArray( colours ) );

				geometry.computeVertexNormals();

				return mesh;

				function _makeRose2( color1, color2, offset ) {

					const radius = stdWidth * 0.9;
					const innerR = radius * 0.2;

					const xlv = Math.PI / 4;
					const xc = Math.PI / 2;

					for ( let i = 0; i < 4; i++ ) {

						const a = i * Math.PI / 2 + offset;

						vertices.push( Math.sin( a ) * radius, Math.cos( a ) * radius, 0 );
						vertices.push( 0, 0, 2 );
						vertices.push( Math.sin( a + xlv ) * innerR, Math.cos( a + xlv ) * innerR, 0 );

						colours.push( color1, color1, color1 );

						vertices.push( Math.sin( a + xlv ) * innerR, Math.cos( a + xlv ) * innerR, 0 );
						vertices.push( 0, 0, 2 );
						vertices.push( Math.sin( a + xc ) * radius, Math.cos( a + xc ) * radius, 0 );

						colours.push( color2, color2, color2 );

					}

				}

			}

		}

		set ( vCamera ) {

			let a;

			vCamera.getWorldDirection( __direction );

			if ( Math.abs( __direction.z ) < 0.999 ) {

				a = Math.atan2( - __direction.x, __direction.y );

			} else {

				__e.setFromQuaternion( vCamera.quaternion );
				a = __e.z;

			}

			if ( a === this.lastRotation ) return;

			if ( a < 0 ) a = Math.PI * 2 + a;

			let degrees = Math.round( radToDeg$1( a ) );

			if ( degrees === 360 ) degrees = 0;

			const res = degrees.toString().padStart( 3, '0' ) + '\u00B0'; // unicode degree symbol

			this.label.replaceString( res );
			this.rotaryGroup.rotateOnAxis( __negativeZAxis, a - this.lastRotation );
			this.lastRotation = a;

		}

	}

	class CompassControl extends Control {

		constructor ( hudObject, viewer ) {

			const dim = hudObject.stdWidth * 2;

			super( viewer.container, dim, dim, handleEnter );

			const controls = viewer.getControls();

			const point = new Vector2();
			const center = new Vector2();

			let dragging = false;
			let dragged = false;

			let startAngle = 0;

			this.positionHitRegion( hudObject.stdMargin, hudObject.stdMargin );

			const handlers = {
				pointerleave: handleLeave,
				pointermove:  handlePointerMove,
				pointerdown:  handlePointerDown,
				pointerup:    handlePointerUp
			};

			const self = this;

			function handleEnter ( event ) {

				if ( ! viewer.HUD ) return;

				self.commonEnter( event.currentTarget, handlers );

				const bc = self.rect;

				center.set( bc.left + hudObject.stdWidth, bc.top + hudObject.stdWidth );
				dragging = false;

			}

			function handleLeave ( event ) {

				if ( dragging ) controls.end();

				self.commonLeave( event.currentTarget, handlers );

			}

			function handlePointerDown ( event ) {

				event.stopPropagation();

				dragging = true;
				dragged = false;

				point.set( event.clientX, event.clientY ).sub( center );
				startAngle = point.angle();

			}

			function handlePointerUp ( event ) {

				event.stopPropagation();

				if ( dragged ) {

					controls.end();

				} else {

					handleClick();

				}

				dragging = false;

			}

			function handleClick () {

				// select cardinal point from quadrant of control clicked on

				if ( point.x > point.y ) {

					if ( point.x < -point.y ) {

						viewer.azimuthAngle = 0;

					} else {

						viewer.azimuthAngle = Math.PI / 2;

					}

				} else {

					if ( point.x > -point.y ) {

						viewer.azimuthAngle = Math.PI;

					} else {

						viewer.azimuthAngle = 3 * Math.PI / 2;

					}

				}

			}

			function handlePointerMove ( event ) {

				event.stopPropagation();
				event.preventDefault();

				if ( ! dragging ) return;

				point.set( event.clientX, event.clientY ).sub( center );

				const angle = point.angle();

				controls.rotateLeft( startAngle - angle );

				startAngle = angle;
				dragged = true;

			}

		}

	}

	class Scale extends Group {

		constructor ( hudObject, container, geometry, material ) {

			const materials = hudObject.ctx.materials;
			const width  = container.clientWidth;
			const height = container.clientHeight;

			const stdWidth  = hudObject.stdWidth;
			const stdMargin = hudObject.stdMargin;

			const barOffset = 3 * ( stdWidth + stdMargin );

			const barHeight = ( height - barOffset ) / 2;
			const barWidth  = stdWidth / 2;

			super();

			this.ctx = hudObject.ctx;
			this.barHeight = barHeight;
			this.barWidth = barWidth;
			this.barOffset = barOffset;

			this.offsetX = -barWidth / 2 - 5;
			this.offsetY = barHeight / 2;

			// position on left side of container
			this.translateX(  width / 2  - barWidth / 2  - stdMargin );
			this.translateY( -height / 2 + barHeight / 2 + barOffset );

			this.scaleBar = new Mesh( geometry, material );
			this.scaleBar.name = 'scale bar';

			this.textMaterial = materials.getLabelMaterial( 'hud' );

			this.add( this.scaleBar );

			this.min = null;
			this.max = null;
			this.caption = null;

		}

		setRange ( min, max, caption ) {

			const offsetX = this.offsetX;
			const offsetY = this.offsetY;

			const material = this.textMaterial;

			if ( min !== this.min || max !== this.max ) {

				for ( let i = this.children.length; i--; ) {

					const obj = this.children[ i ];

					if ( obj.isRange ) this.remove( obj );

				}

				const topLabel = new GlyphString( Math.round( max ) + '\u202fm', material, this.ctx );
				const bottomLabel = new GlyphString( Math.round( min ) + '\u202fm', material, this.ctx );

				topLabel.translateX( offsetX - topLabel.getWidth() );
				bottomLabel.translateX( offsetX - bottomLabel.getWidth() );

				topLabel.translateY( offsetY - topLabel.getHeight() );
				bottomLabel.translateY( -offsetY );

				topLabel.isRange = true;
				bottomLabel.isRange = true;

				this.addStatic( topLabel );
				this.addStatic( bottomLabel );

				this.min = min;
				this.max = max;

			}

			this.setCaption( caption );

			return this;

		}

		setCaption ( text ) {

			let caption = this.caption;

			if ( caption !== null ) {

				// already have correct caption
				if ( caption.name === text ) return this;

				this.remove( caption );

			}

			caption = new GlyphString( text, this.textMaterial, this.ctx );
			caption.translateX( this.barWidth / 2 - caption.getWidth() );
			caption.translateY( this.offsetY + this.barWidth / 2 );

			this.addStatic( caption );
			this.caption = caption;

			return this;

		}

		dispose () {

			this.traverse( obj => { if ( obj.geometry !== undefined ) obj.geometry.dispose(); } );

		}

	}

	class CursorScale extends Scale {

		constructor ( hudObject, container ) {

			const ctx = hudObject.ctx;
			const cfg = ctx.cfg;
			const materials = ctx.materials;
			const geometry = new PlaneGeometry();

			super( hudObject, container, geometry, new MeshBasicMaterial( { color: 0x676767 } ) );

			this.name = 'CV.CursorScale';
			this.visible = false;

			const barWidth = this.barWidth;
			const barHeight = this.barHeight;

			geometry.scale( barWidth, barHeight, 1 );

			// make cursor line

			const cursorGeometry = new LineSegmentsGeometry();

			cursorGeometry.setPositions( [
				barWidth / 2, -barHeight / 2, 10,
				-barWidth / 2, -barHeight / 2, 10
			] );

			const cursor = new LineSegments2( cursorGeometry, new Line2Material( ctx, { color: cfg.themeColor( 'hud.cursor' ) } ) );

			const atlasSpec = {
				color: cfg.themeColorCSS( 'hud.cursor' ),
				background: '#444444',
				font: 'bold helvetica,sans-serif'
			};

			const material = materials.getGlyphMaterial( atlasSpec, 0 );

			const cursorLabel = new MutableGlyphString( '      ', material );

			cursorLabel.translateY( - barHeight / 2 - cursorLabel.getHeight() / 2 );

			this.addStatic( cursor );
			cursor.addStatic( cursorLabel );

			this.cursor = cursor;
			this.cursorLabel = cursorLabel;

		}

		setCursor ( scaledValue, displayValue ) {

			const cursor = this.cursor;
			const cursorLabel = this.cursorLabel;

			cursor.position.setY( this.barHeight * scaledValue );
			cursor.updateMatrix();

			cursorLabel.replaceString( String( displayValue + '\u202fm' ).padStart( 6, ' ') );
			cursorLabel.position.setX( this.offsetX - cursorLabel.getWidth() );

			cursorLabel.updateMatrix();

			return this;

		}

	}

	class CursorControl extends Control {

		constructor ( hudObject, viewer, cursorScale ) {

			super( viewer.container, cursorScale.barWidth, cursorScale.barHeight, handleEnter );

			let dragging = false;
			let barTop;

			this.positionHitRegion( hudObject.stdMargin, cursorScale.barOffset );

			const handlers = {
				pointerleave: handleLeave,
				pointermove:  handlePointerMove,
				pointerdown:  handlePointerDown,
				pointerup:    handlePointerUp
			};

			const self = this;

			function handleEnter ( event ) {

				if ( ! viewer.HUD ) return;
				if ( viewer.shadingMode !== SHADING_CURSOR && viewer.shadingMode !== SHADING_DEPTH_CURSOR ) return;

				self.commonEnter( event.currentTarget, handlers );

				// update center position (accounts for resizes)

				barTop = self.rect.top;
				dragging = false;

			}

			function setCursor( clientY ) {

				const heightFraction = ( cursorScale.barHeight - clientY + barTop ) / cursorScale.barHeight;
				const range = viewer.maxHeight - viewer.minHeight;

				// handle direction of scale and range

				if ( viewer.shadingMode === SHADING_DEPTH_CURSOR ) {

					viewer.cursorHeight = range - range * heightFraction;

				} else {

					viewer.cursorHeight = range * heightFraction - range / 2;

				}

			}

			function handleLeave ( event ) {

				self.commonLeave( event.currentTarget, handlers );

			}

			function handlePointerDown ( event ) {

				event.stopPropagation();

				setCursor( event.clientY );
				dragging = true;

			}

			function handlePointerUp ( event ) {

				event.stopPropagation();

				dragging = false;

			}

			function handlePointerMove ( event ) {

				event.stopPropagation();
				event.preventDefault();

				if ( ! dragging ) return;

				setCursor( event.clientY );

			}

		}

	}

	class LinearScale extends Scale {

		constructor ( hudObject, container ) {

			const materials = hudObject.ctx.materials;
			const geometry = new PlaneGeometry();

			super( hudObject, container, geometry, materials.getScaleMaterial() );

			this.name = 'CV.LinearScale';
			this.visible = false;

			geometry.rotateZ( - Math.PI / 2 ); // rotate to use default UV values
			geometry.scale( this.barWidth, this.barHeight, 1 );

		}

	}

	class ProgressDial extends Mesh {

		constructor ( hudObject, addText, ring, viewer ) {

			const cfg = hudObject.ctx.cfg;
			const materials = hudObject.ctx.materials;
			const stdWidth  = hudObject.stdWidth;
			const stdMargin = hudObject.stdMargin;

			const offset = stdWidth + stdMargin;

			const gap = ring === 0 ? 0 : 1;
			const segments = 50;
			const geometry = new RingGeometry( stdWidth * ( 0.9 - ring * 0.1 ), stdWidth * ( 1 - ring * 0.1 ) - gap, segments );

			const colors = new Float32BufferAttribute( ( segments + 1) * 6, 3 );

			geometry.setAttribute( 'color', colors );

			super( geometry, materials.getPlainMaterial() );

			this.backgroundColor = cfg.themeColor( 'hud.progressBackground' );
			this.setColor = cfg.themeColor( 'hud.progress' );
			this.viewer = viewer;


			this.dropBuffers( false );

			this.name = 'CV.ProgressDial';

			this.translateX( -offset * 5 );
			this.translateY(  offset );

			this.rotateOnAxis( Object3D.DefaultUp, Math.PI / 2 );

			this.visible = false;
			this.isVisible = true;

			this.colorRange( 0 );

			if ( addText ) {

				const glyphMaterial = materials.getLabelMaterial( 'hud' );
				const pcent = new MutableGlyphString( '----', glyphMaterial );

				pcent.translateY( pcent.getWidth() / 2 );
				pcent.translateX( -10 );

				this.add( pcent );
				this.pcent = pcent;

			} else {

				this.pcent = null;

			}

		}

		colorRange ( range ) {

			const colors = this.geometry.getAttribute( 'color' );
			const segmentMax = 50 - Math.round( range / 2 );
			const cc = colors.count;
			const c1 = this.setColor;
			const c2 = this.backgroundColor;

			for ( let i = cc / 2; i >= 0; i-- ) {

				const c =  i > segmentMax ? c1 : c2;

				c.toArray( colors.array, i * 3 );
				c.toArray( colors.array, ( i + 51 ) * 3 );

			}

			colors.needsUpdate = true;

		}

		set ( progress ) {

			if ( progress === this.progress ) return;

			this.progress = progress;

			const l = Math.floor( Math.min( 100, Math.round( progress ) ) / 2 ) * 2;
			const pcent = this.pcent;

			this.colorRange( l );

			if ( pcent !== null ) {

				const pcentValue = Math.round( progress ) + '%';

				pcent.replaceString( pcentValue.padStart( 4, ' ' ) );
				pcent.translateY( pcent.getWidth() / 2 - pcent.position.y );

			}

			this.viewer.renderView();

		}

		start () {

			this.colorRange( 0 );

			this.progress = 0;
			this.visible = true;

			if ( this.pcent !== null ) this.pcent.replaceString( '  0%' );

			this.viewer.renderView();

		}

		end () {

			const self = this;

			setTimeout( function endProgress () { self.visible = false; self.viewer.renderView(); }, 500 );

		}

		setVisibility ( visibility ) {

			this.isVisible = visibility;
			this.visible = ( this.visible && visibility );

		}

		watch ( obj ) {

			obj.addEventListener( 'progress', this.handleProgess.bind( this ) );

		}

		handleProgess ( event ) {

			switch ( event.name ) {

			case 'start':

				this.start();
				break;

			case 'set':

				this.set( event.progress );
				break;

			case 'end':

				this.end();
				break;

			}

		}

	}

	class BarGeometry extends BufferGeometry {

		constructor ( ctx, length, height, divisions ) {

			super();

			const cfg = ctx.cfg;

			const c1 = cfg.themeColor( 'hud.scale.bar1' );
			const c2 = cfg.themeColor( 'hud.scale.bar2' );

			const vertices = [];
			const colors = [];

			_makeBar( divisions * 10, 0 );
			_makeBar( divisions, height + 1 );

			const colorBuffer = new Float32BufferAttribute( colors.length * 3, 3 );

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'color', colorBuffer.copyColorsArray( colors ) );

			function _makeBar( divisions, offset ) {

				const dWidth = length / divisions;

				for ( let i = 0; i < divisions; i++ ) {

					const x1 = i * dWidth;
					const x2 = x1 + dWidth;
					const y1 = offset;
					const y2 = y1 + height;

					vertices.push(
						x1, y1, 0,
						x2, y2, 0,
						x1, y2, 0,
						x2, y2, 0,
						x1, y1, 0,
						x2, y1, 0
					);

					const c = ( i % 2 ) ? c1 : c2;
					colors.push( c, c, c, c, c, c );

				}

			}
		}

	}

	class ScaleBar extends Group {

		constructor ( hudObject, container, hScale, rightMargin ) {

			const leftMargin = 10;
			const materials = hudObject.ctx.materials;

			super();

			this.name = 'CV.ScaleBar';

			this.hScale        = hScale;
			this.scaleBars     = [];
			this.currentLength = 0;
			this.wScale = container.clientHeight / container.clientWidth;
			this.hudObject = hudObject;

			this.position.set( -container.clientWidth / 2 + 45, -container.clientHeight / 2 + leftMargin, 0 );
			this.scaleMax = container.clientWidth - ( 40 + leftMargin + rightMargin );

			const material = materials.getLabelMaterial( 'hud' );
			const label = new MutableGlyphString( '--------', material );

			label.translateX( 0 );
			label.translateY( 10 );

			this.add( label );

			this.label = label;

		}

		setScale ( scale ) {

			const scaleBars = this.scaleBars;
			const self = this;
			const ctx = this.hudObject.ctx;

			const maxVisible = this.scaleMax / ( scale * this.hScale );

			let exponent = Math.ceil( Math.log( maxVisible ) / Math.LN10 ) - 1;

			const rMax   = Math.pow( 10, exponent );
			const maxInc = maxVisible / rMax;

			let legendText;
			let length = 0;

			if ( maxInc < 2 ) {

				length = 10;
				exponent = exponent - 1;

			} else if ( maxInc < 5 ) {

				length = 2;

			} else {

				length = 5;

			}

			if ( exponent >= 3 ) {

				legendText = length * Math.pow( 10, exponent - 3) + '\u202fkm';

			} else {

				legendText = length * Math.pow( 10, exponent ) + '\u202fm';

			}

			scale = scale * Math.pow( 10, exponent );

			if ( this.currentLength !== length ) {

				if ( ! scaleBars[ length ] ) {

					const bar = _makeScaleBar( length );

					scaleBars[ length ] = bar;
					this.add( bar.mesh );

				}

				if ( this.currentLength > 0 ) {

					scaleBars[ this.currentLength ].mesh.visible = false;

				}

				scaleBars[ length ].mesh.visible = this.visible;
				this.currentLength = length;

			}

			scaleBars[ length ].mesh.scale.x = scale;

			const label = this.label;

			label.replaceString( legendText.padStart( 8, ' ' ) );

			const w = label.getWidth();

			label.translateX( scale * scaleBars[ length ].topRight - label.position.x - w );

			return this;

			function _makeScaleBar ( length ) {

				const bar = new BarGeometry( ctx, length * self.hScale, 4, length );

				bar.computeBoundingBox();

				return {
					mesh: new Mesh( bar, ctx.materials.getPlainMaterial() ),
					topRight: bar.boundingBox.max.x
				};

			}

		}

	}

	class HudObject {

		stdMargin = 5;

		constructor ( ctx ) {

			const cfg = ctx.cfg;
			this.stdWidth = cfg.themeValue( 'hud.widgetSize' );
			this.commonRing = null;
			this.ctx = ctx;

		}

		getCommonRing () {

			let commonRing = this.commonRing;

			if ( commonRing === null ) {

				commonRing = new CylinderGeometry( this.stdWidth * 0.90, this.stdWidth, 3, 32, 1, true );
				commonRing.rotateX( Math.PI / 2 );

				this.commonRing = commonRing;
			}

			return commonRing;

		}

	}

	function HUD ( viewer, renderer ) {

		const self = this;
		const cfg = viewer.ctx.cfg;

		const container = viewer.container;

		const hHeight = container.clientHeight / 2;
		const hWidth  = container.clientWidth / 2;

		let hScale = 0;

		let linearScale = null;
		let cursorScale = null;
		let scaleBar    = null;
		let cursorControl = null;

		let ahi;
		let compass;
		let angleScale;

		// viewer state

		let isVisible = true;
		let caveLoaded = false;

		// create GL scene and camera for overlay
		const camera = new OrthographicCamera( -hWidth, hWidth, hHeight, -hHeight, 1, 1000 );
		camera.position.z = 600;

		const scene = new Scene();
		scene.name = 'HUD';

		// group to simplyfy resize handling
		const attitudeGroup = new Group();
		attitudeGroup.position.set( hWidth, -hHeight, 0 );

		scene.addStatic( attitudeGroup );

		let hudObject = new HudObject( viewer.ctx );

		const aLight = new AmbientLight( 0x888888 );
		const dLight = new DirectionalLight( 0xFFFFFF );
		dLight.position.set( -1, 1, 1 );

		scene.addStatic( aLight );
		scene.addStatic( dLight );

		const progressDials = [
			new ProgressDial( hudObject, true, 0, viewer ),
			new ProgressDial( hudObject, false, 1, viewer )
		];

		const progressDial = progressDials [ 0 ];

		newAttitudeGroup();

		attitudeGroup.addStatic( progressDials[ 0 ] );
		attitudeGroup.addStatic( progressDials[ 1 ] );

		viewer.addEventListener( 'newCave', caveChanged );
		viewer.addEventListener( 'change', viewChanged );
		viewer.addEventListener( 'resized', resize );

		cfg.addEventListener( 'change', cfgChanged );
		cfg.addEventListener( 'colors', cfgColorChanged );

		const controls = viewer.getControls();

		const compassControl = new CompassControl( hudObject, viewer );
		const ahiControl = new AHIControl( hudObject, viewer );

		function i18n ( text ) {

			const tr = cfg.i18n( 'hud.' + text );

			return ( tr === undefined ) ? text : tr;

		}

		this.setVisibility = function ( visible ) {

			progressDial.setVisibility( visible );

			if ( ! caveLoaded ) return;

			compass.visible = visible;
			ahi.visible = visible;

			if ( scaleBar ) scaleBar.visible = visible;

			isVisible = visible;

			// reset correct disposition of colour keys etc.
			if ( linearScale ) {

				if ( visible ) {

					viewChanged ( { type: 'change', name: 'shadingMode' } );

				} else {

					linearScale.visible = false;
					cursorScale.visible = false;
					angleScale.visible = false;

				}

			}

			viewer.renderView();

		};

		this.getVisibility = function () {

			return isVisible;

		};

		this.getProgressDial = function ( ring ) {

			return progressDials[ ring ];

		};

		this.setScale = function ( scale ) {

			hScale = scale;

		};

		function resize () {

			const hWidth  = container.clientWidth / 2;
			const hHeight = container.clientHeight / 2;

			// adjust cameras to new aspect ratio etc.
			camera.left   = -hWidth;
			camera.right  =  hWidth;
			camera.top    =  hHeight;
			camera.bottom = -hHeight;

			camera.updateProjectionMatrix();

			attitudeGroup.position.set( hWidth, -hHeight, 0 );
			attitudeGroup.updateMatrix();

			newScales();

		}

		this.renderHUD = function () {

			// update HUD components

			const currentCamera = controls.cameraManager.activeCamera;

			compass.set( currentCamera );
			ahi.set( currentCamera );

			updateScaleBar( currentCamera );

			// render on screen
			renderer.clearDepth();
			renderer.render( scene, camera );

		};

		function cfgColorChanged ( /* event */ ) {

			// refresh common config helper
			hudObject = new HudObject( viewer.ctx );

			newAttitudeGroup();
			caveChanged();
		}

		function cfgChanged ( /* event */ ) {

			// only change controls when a cave has been loaded already
			// prevents flicker when racing with i18n resource loading
			if ( caveLoaded ) caveChanged();

		}

		function caveChanged ( /* event */ ) {

			caveLoaded = true;

			newScales();

			viewChanged ( { type: 'change', name: 'shadingMode' } );

		}

		function newAttitudeGroup() {

			if ( ahi ) attitudeGroup.remove( ahi );
			if ( compass ) attitudeGroup.remove( compass );
			if ( angleScale ) attitudeGroup.remove( angleScale );

			ahi = new AHI( hudObject );
			compass = new Compass( hudObject );
			angleScale = new AngleScale( hudObject, i18n( 'inclination' ) );

			attitudeGroup.addStatic( ahi );
			attitudeGroup.addStatic( compass );
			attitudeGroup.addStatic( angleScale );

		}

		function newScales () {

			const hasLegs = viewer.minHeight !== Infinity && viewer.maxHeight !== -Infinity;

			if ( linearScale ) {

				linearScale.dispose();
				scene.remove( linearScale );

			}

			if ( hasLegs ) {

				linearScale = new LinearScale( hudObject, container );
				scene.addStatic( linearScale );

			}

			if ( cursorScale ) {

				cursorScale.dispose();
				scene.remove( cursorScale );

			}

			if ( hasLegs ) {

				cursorScale = new CursorScale( hudObject, container );

				if ( cursorControl ) cursorControl.dispose();

				cursorControl = new CursorControl( hudObject, viewer, cursorScale );

				scene.addStatic( cursorScale );

			}

			if ( scaleBar ) {

				scene.remove( scaleBar );
				scaleBar = null;

			}

			updateScaleBar( controls.cameraManager.activeCamera );

			self.setVisibility( isVisible );

		}

		function viewChanged ( event ) {

			if ( event.name !== 'shadingMode' || ! isVisible || ! caveLoaded ) return;

			// hide all - and only make required elements visible

			angleScale.visible = false;
			linearScale.visible = false;
			cursorScale.visible = false;

			let stats;

			switch ( viewer.shadingMode ) {

			case SHADING_HEIGHT:

				linearScale.visible = true;

				linearScale.setRange( viewer.minHeight, viewer.maxHeight, i18n( 'height' ) );

				break;

			case SHADING_DEPTH:

				linearScale.visible = true;

				linearScale.setRange( viewer.maxHeight - viewer.minHeight, 0, i18n( 'depth' ) );

				break;

			case SHADING_DISTANCE:

				linearScale.visible = true;

				linearScale.setRange( viewer.maxDistance, 0, i18n( 'distance' ) );

				break;

			case SHADING_CURSOR:

				cursorScale.visible = true;

				cursorScale.setRange( viewer.minHeight, viewer.maxHeight, i18n( 'height' ) );

				cursorChanged( { type: 'change', name: 'cursorHeight' } );

				break;

			case SHADING_DEPTH_CURSOR:

				cursorScale.visible = true;

				cursorScale.setRange( viewer.maxHeight - viewer.minHeight, 0, i18n( 'depth' ) );

				cursorChanged( { type: 'change', name: 'cursorHeight' } );

				break;

			case SHADING_LENGTH:

				linearScale.visible = true;

				stats = viewer.getLegStats( LEG_CAVE );
				linearScale.setRange( stats.minLegLength, stats.maxLegLength, i18n( 'leg_length' ) );

				break;

			case SHADING_INCLINATION:

				angleScale.visible = true;

				break;

			}

			if ( cursorScale.visible ) {

				viewer.addEventListener( 'change', cursorChanged );

			} else {

				viewer.removeEventListener( 'change', cursorChanged );

			}

			viewer.renderView();

		}

		function cursorChanged ( event ) {

			if ( event.name !== 'cursorHeight' ) return;

			const cursorHeight = viewer.cursorHeight;
			const range = viewer.maxHeight - viewer.minHeight;

			let scaledHeight = 0;
			let realHeight = 0;

			if ( viewer.shadingMode === SHADING_CURSOR ) {

				scaledHeight = ( viewer.cursorHeight + range / 2 ) / range;
				realHeight = cursorHeight + range / 2 + viewer.minHeight;

			} else {

				scaledHeight = 1 - cursorHeight / range;
				realHeight = cursorHeight;

			}

			scaledHeight = Math.max( Math.min( scaledHeight, 1 ), 0 );

			cursorScale.setCursor( scaledHeight, Math.round( realHeight ) );

		}

		function updateScaleBar ( camera ) {

			if ( camera.isOrthographicCamera ) {

				if ( scaleBar === null ) {

					scaleBar = new ScaleBar( hudObject, viewer.container, hScale, ( hudObject.stdWidth + hudObject.stdMargin ) * 4 );
					scene.addStatic( scaleBar );

				}

				scaleBar.visible = isVisible;
				scaleBar.setScale( camera.zoom );

			} else {

				if ( scaleBar !== null && scaleBar.visible ) scaleBar.visible = false;

			}

		}

		this.dispose = function () {

			ahiControl.dispose();
			compassControl.dispose();
			cursorControl?.dispose();

		};

	}

	function LightingManager ( ctx, scene ) {

		const cfg = ctx.cfg;
		const xAxis = new Vector3( 1, 0, 0 );
		const up = Object3D.DefaultUp;

		const ambient = [];

		ambient[ LM_SINGLE   ] = 0.3;
		ambient[ LM_MULTIPLE ] = 0.0;
		ambient[ LM_NONE     ] = 1.0;

		const ambientLight = new AmbientLight( 0xffffff, 0.3 );

		const inclination = cfg.themeAngle( 'lighting.inclination' ) * RAD2DEG;
		const azimuth = cfg.themeAngle( 'lighting.azimuth' ) * RAD2DEG;

		const lights = new Group();

		// single direction of illumination
		const directionalLight0 = _createDirectionalLight( 0xffffff, inclination, azimuth );

		//multiple directions of illumination
		const directionalLight1 = _createDirectionalLight( 0xff0000, 55, 315 );
		const directionalLight2 = _createDirectionalLight( 0x00ff00, 55, 15 );
		const directionalLight3 = _createDirectionalLight( 0x0000ff, 55, 75 );

		scene.addStatic( lights );

		scene.addStatic( ambientLight );

		this.mode = LM_SINGLE;

		function _createDirectionalLight ( color, alt, azimuth ) {

			const light = new DirectionalLight( color );
			const position = light.position;

			position.copy( up );
			position.applyAxisAngle( xAxis, alt * DEG2RAD );
			position.applyAxisAngle( up, ( azimuth - 90 ) * DEG2RAD );

			lights.addStatic( light );

			return light;

		}

		this.setRotation = function ( rotation ) {

			lights.setRotationFromAxisAngle( up, rotation.z );
			lights.updateMatrix();

		};

		Object.defineProperty( this, 'lightingMode', {
			get() { return this.mode; },
			set( mode ) {

				this.mode = mode;

				directionalLight0.visible = ( mode == LM_SINGLE );

				directionalLight1.visible = ( mode == LM_MULTIPLE );
				directionalLight2.visible = ( mode == LM_MULTIPLE );
				directionalLight3.visible = ( mode == LM_MULTIPLE );

				ambientLight.intensity = ambient[ mode ];

			}
		} );

	}

	class ClusterMaterial extends PointsMaterial {

		constructor ( count ) {

			const markerSize = 64;
			const fontSize = 40;
			const halfSize = markerSize / 2;

			const canvas = document.createElement( 'canvas' );

			if ( ! canvas ) console.error( 'creating canvas for cluster marker failed' );

			canvas.width  = markerSize;
			canvas.height = markerSize;

			const ctx = canvas.getContext( '2d' );

			if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

			// set transparent background

			ctx.fillStyle = 'rgba( 0, 0, 0, 0 )';
			ctx.fillRect( 0, 0, markerSize, markerSize );

			ctx.textAlign = 'center';
			ctx.font = 'bold ' + fontSize + 'px helvetica,sans-serif';
			ctx.fillStyle = '#ffffff';

			const gradient = ctx.createRadialGradient( halfSize, halfSize, 30, halfSize, halfSize, 0 );

			gradient.addColorStop( 0.0, 'rgba( 255, 128, 0, 64 )' );
			gradient.addColorStop( 0.3, 'rgba( 255, 200, 0, 255 )' );
			gradient.addColorStop( 1.0, 'rgba( 255, 255, 0, 255 )' );

			ctx.fillStyle = gradient;

			ctx.beginPath();
			ctx.arc( halfSize, halfSize, 30, 0, Math.PI * 2 );
			ctx.fill();

			ctx.fillStyle = 'rgba( 0, 0, 0, 255 )';

			ctx.fillText( count, halfSize, halfSize + 15 );

			const texture = new CanvasTexture( canvas );

			super( { map: texture, size: 32, depthTest: false, transparent: true, alphaTest: 0.8, sizeAttenuation: false } );

			texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

			this.name = 'ClusterMaterial';

		}

	}

	const gradientColoursHi = [[167,1,221], [131,4,228], [74,2,231], [47,2,242], [2,27,247], [3,33,251], [4,39,254], [5,51,254], [6,75,254], [7,101,254], [8,127,238], [9,151,213], [10,177,168], [19,202,123], [30,227,78], [41,252,40], [72,254,36], [126,254,33], [167,254,30], [194,253,30], [220,224,29], [253,203,31], [254,176,25], [254,148,21], [254,120,18], [254,90,13], [254,61,9], [254,30,6], [254,2,2], [254,1,1], [254,1,1], [255,0, 0 ] ];
	const gradientColoursLow = [[235,99,111],[235,99,112],[234,99,113],[234,100,114],[233,100,114],[233,100,115],[232,100,116],[232,101,117],[231,101,118],[231,101,119],[230,101,119],[230,101,120],[230,102,121],[229,102,122],[229,102,123],[228,102,124],[228,103,124],[227,103,125],[227,103,126],[226,103,127],[226,103,128],[226,104,129],[225,104,129],[225,104,130],[224,104,131],[224,104,132],[223,105,133],[223,105,134],[222,105,134],[222,105,135],[221,106,136],[221,106,137],[221,106,138],[220,106,139],[220,106,139],[219,107,140],[219,107,141],[218,107,142],[218,107,143],[217,108,144],[217,108,144],[216,108,145],[216,108,146],[216,108,147],[215,109,148],[215,109,149],[214,109,149],[214,109,150],[213,110,151],[213,110,152],[212,110,153],[212,110,154],[211,110,154],[211,111,155],[211,111,156],[210,111,157],[210,111,158],[209,111,159],[209,112,159],[208,112,160],[208,112,161],[207,112,162],[207,113,163],[207,113,164],[206,113,164],[206,113,165],[205,113,166],[205,114,167],[204,114,168],[204,114,169],[203,114,169],[203,115,170],[202,115,171],[202,115,172],[201,115,172],[200,116,173],[199,116,173],[198,116,173],[197,117,174],[196,117,174],[194,118,174],[193,118,175],[192,118,175],[191,119,176],[190,119,176],[189,119,176],[188,120,177],[187,120,177],[186,121,177],[185,121,178],[184,121,178],[183,122,178],[181,122,179],[180,122,179],[179,123,179],[178,123,180],[177,124,180],[176,124,181],[175,124,181],[174,125,181],[173,125,182],[172,125,182],[171,126,182],[170,126,183],[168,126,183],[167,127,183],[166,127,184],[165,128,184],[164,128,184],[163,128,185],[162,129,185],[161,129,186],[160,129,186],[159,130,186],[158,130,187],[157,131,187],[155,131,187],[154,131,188],[153,132,188],[152,132,188],[151,132,189],[150,133,189],[149,133,189],[148,133,190],[147,134,190],[146,134,191],[145,135,191],[144,135,191],[142,135,192],[141,136,192],[140,136,192],[139,136,193],[138,137,193],[137,137,193],[136,138,194],[135,138,194],[134,138,194],[133,139,195],[132,139,195],[131,139,196],[129,140,196],[128,140,196],[127,141,197],[126,141,197],[125,141,197],[124,142,198],[123,142,198],[122,142,198],[120,142,197],[119,143,197],[117,143,197],[116,143,197],[114,143,196],[113,144,196],[111,144,196],[110,144,195],[108,144,195],[107,144,195],[105,145,195],[104,145,194],[102,145,194],[101,145,194],[100,146,193],[98,146,193],[97,146,193],[95,146,193],[94,146,192],[92,147,192],[91,147,192],[89,147,191],[88,147,191],[86,147,191],[85,148,191],[83,148,190],[82,148,190],[80,148,190],[79,149,189],[78,149,189],[76,149,189],[75,149,189],[73,149,188],[72,150,188],[70,150,188],[69,150,187],[67,150,187],[66,151,187],[64,151,186],[63,151,186],[61,151,186],[60,151,186],[59,152,185],[57,152,185],[56,152,185],[54,152,184],[53,153,184],[51,153,184],[50,153,184],[48,153,183],[47,153,183],[45,154,183],[44,154,182],[42,154,182],[41,154,182],[39,154,182],[38,155,181],[37,155,181],[35,155,181],[34,155,180],[32,156,180],[31,156,180],[29,156,180],[28,156,179],[26,156,179],[25,157,179],[23,157,178],[22,157,178],[20,157,178],[19,158,178],[17,158,177],[16,158,177],[16,158,176],[17,158,176],[17,158,175],[18,158,174],[18,158,174],[19,158,173],[19,158,172],[20,158,171],[20,158,171],[21,158,170],[21,158,169],[22,158,169],[22,159,168],[23,159,167],[23,159,167],[23,159,166],[24,159,165],[24,159,164],[25,159,164],[25,159,163],[26,159,162],[26,159,162],[27,159,161],[27,159,160],[28,159,160],[28,159,159],[29,159,158],[29,159,157],[30,159,157],[30,159,156],[30,159,155],[31,159,155],[31,159,154],[32,159,153],[32,159,153],[33,159,152],[33,160,151],[34,160,150],[34,160,150],[35,160,149],[35,160,148],[36,160,148],[36,160,147],[36,160,146],[37,160,146],[37,160,145],[38,160,144],[38,160,143],[39,160,143],[39,160,142],[40,160,141],[40,160,141],[41,160,140],[41,160,139],[42,160,139],[42,160,138],[43,160,137],[43,160,136],[43,160,136],[44,160,135],[44,161,134],[45,161,134],[45,161,133],[46,161,132],[46,161,132],[47,161,131],[47,161,130],[48,161,129],[48,161,129],[49,161,128],[49,161,127],[50,161,127],[50,161,126],[51,161,125],[52,161,125],[53,161,124],[54,161,123],[55,161,123],[56,161,122],[56,160,121],[57,160,121],[58,160,120],[59,160,120],[60,160,119],[61,160,118],[62,160,118],[63,160,117],[64,160,116],[65,160,116],[66,160,115],[67,160,114],[67,159,114],[68,159,113],[69,159,112],[70,159,112],[71,159,111],[72,159,111],[73,159,110],[74,159,109],[75,159,109],[76,159,108],[77,159,107],[78,159,107],[78,158,106],[79,158,105],[80,158,105],[81,158,104],[82,158,103],[83,158,103],[84,158,102],[85,158,102],[86,158,101],[87,158,100],[88,158,100],[89,158,99],[89,157,98],[90,157,98],[91,157,97],[92,157,96],[93,157,96],[94,157,95],[95,157,94],[96,157,94],[97,157,93],[98,157,93],[99,157,92],[100,157,91],[100,156,91],[101,156,90],[102,156,89],[103,156,89],[104,156,88],[105,156,87],[106,156,87],[107,156,86],[108,156,85],[109,156,85],[110,156,84],[111,156,84],[111,155,83],[112,155,82],[113,155,82],[114,155,81],[115,155,80],[116,155,80],[117,155,79],[118,155,79],[118,155,79],[119,154,78],[120,154,78],[121,154,78],[121,154,78],[122,154,78],[123,153,77],[123,153,77],[124,153,77],[125,153,77],[126,153,77],[126,152,77],[127,152,76],[128,152,76],[128,152,76],[129,152,76],[130,151,76],[131,151,75],[131,151,75],[132,151,75],[133,150,75],[133,150,75],[134,150,74],[135,150,74],[136,150,74],[136,149,74],[137,149,74],[138,149,73],[138,149,73],[139,149,73],[140,148,73],[141,148,73],[141,148,72],[142,148,72],[143,148,72],[143,147,72],[144,147,72],[145,147,72],[145,147,71],[146,147,71],[147,146,71],[148,146,71],[148,146,71],[149,146,70],[150,146,70],[150,145,70],[151,145,70],[152,145,70],[153,145,69],[153,145,69],[154,144,69],[155,144,69],[155,144,69],[156,144,68],[157,143,68],[158,143,68],[158,143,68],[159,143,68],[160,143,67],[160,142,67],[161,142,67],[162,142,67],[163,142,67],[163,142,67],[164,141,66],[165,141,66],[165,141,66],[166,141,66],[167,141,66],[168,140,65],[168,140,65],[169,140,65],[169,140,65],[170,140,66],[170,139,66],[171,139,66],[171,139,67],[172,139,67],[172,139,67],[172,138,68],[173,138,68],[173,138,68],[174,138,69],[174,138,69],[175,137,69],[175,137,70],[175,137,70],[176,137,70],[176,137,71],[177,136,71],[177,136,71],[177,136,72],[178,136,72],[178,135,72],[179,135,73],[179,135,73],[180,135,73],[180,135,74],[180,134,74],[181,134,74],[181,134,75],[182,134,75],[182,134,75],[183,133,76],[183,133,76],[183,133,76],[184,133,77],[184,133,77],[185,132,77],[185,132,77],[186,132,78],[186,132,78],[186,132,78],[187,131,79],[187,131,79],[188,131,79],[188,131,80],[189,131,80],[189,130,80],[189,130,81],[190,130,81],[190,130,81],[191,130,82],[191,129,82],[192,129,82],[192,129,83],[192,129,83],[193,128,83],[193,128,84],[194,128,84],[194,128,84],[194,128,85],[195,127,85],[195,127,85],[196,127,86],[196,127,86],[197,127,86],[197,126,87],[197,126,87],[198,126,87],[198,126,88],[199,126,88],[199,125,88],[200,125,89],[200,125,89]];
	const depthColours = [[255,255,204],[255,255,203],[255,255,203],[255,254,202],[255,254,202],[255,254,201],[255,254,200],[255,253,200],[255,253,199],[255,253,199],[255,253,198],[255,252,197],[255,252,197],[255,252,196],[255,252,196],[255,251,195],[255,251,194],[255,251,194],[255,251,193],[255,250,193],[255,250,192],[255,250,191],[255,250,191],[255,249,190],[255,249,190],[255,249,189],[255,249,188],[255,248,188],[255,248,187],[255,248,187],[255,248,186],[255,247,185],[255,247,185],[255,247,184],[255,247,184],[255,246,183],[255,246,182],[255,246,182],[255,246,181],[255,245,180],[255,245,180],[255,245,179],[255,245,179],[255,244,178],[255,244,177],[255,244,177],[255,244,176],[255,243,176],[255,243,175],[255,243,174],[255,243,174],[255,242,173],[255,242,173],[255,242,172],[255,242,171],[255,241,171],[255,241,170],[255,241,170],[255,241,169],[255,240,168],[255,240,168],[255,240,167],[255,240,167],[255,239,166],[255,239,165],[255,239,165],[255,239,164],[255,238,164],[255,238,163],[255,238,162],[255,238,162],[255,237,161],[255,237,161],[255,237,160],[255,237,159],[255,236,159],[255,236,158],[255,236,158],[255,236,157],[255,235,157],[255,235,156],[255,235,155],[255,235,155],[255,234,154],[255,234,154],[255,234,153],[255,233,153],[255,233,152],[255,233,151],[255,233,151],[255,232,150],[255,232,150],[255,232,149],[255,232,148],[255,231,148],[255,231,147],[255,231,147],[255,230,146],[255,230,146],[255,230,145],[255,230,144],[255,229,144],[255,229,143],[255,229,143],[255,229,142],[255,228,142],[255,228,141],[255,228,140],[255,227,140],[255,227,139],[254,227,139],[254,227,138],[254,226,138],[254,226,137],[254,226,136],[254,225,136],[254,225,135],[254,225,135],[254,225,134],[254,224,134],[254,224,133],[254,224,132],[254,224,132],[254,223,131],[254,223,131],[254,223,130],[254,222,130],[254,222,129],[254,222,128],[254,222,128],[254,221,127],[254,221,127],[254,221,126],[254,221,125],[254,220,125],[254,220,124],[254,220,124],[254,219,123],[254,219,123],[254,219,122],[254,219,121],[254,218,121],[254,218,120],[254,218,120],[254,218,119],[254,217,119],[254,217,118],[254,216,117],[254,216,117],[254,215,116],[254,215,116],[254,214,115],[254,214,115],[254,213,114],[254,213,113],[254,212,113],[254,212,112],[254,211,112],[254,211,111],[254,210,111],[254,210,110],[254,209,109],[254,208,109],[254,208,108],[254,207,108],[254,207,107],[254,206,106],[254,206,106],[254,205,105],[254,205,105],[254,204,104],[254,204,104],[254,203,103],[254,203,102],[254,202,102],[254,202,101],[254,201,101],[254,200,100],[254,200,100],[254,199,99],[254,199,98],[254,198,98],[254,198,97],[254,197,97],[254,197,96],[254,196,96],[254,196,95],[254,195,94],[254,195,94],[254,194,93],[254,193,93],[254,193,92],[254,192,92],[254,192,91],[254,191,90],[254,191,90],[254,190,89],[254,190,89],[254,189,88],[254,189,88],[254,188,87],[254,188,86],[254,187,86],[254,187,85],[254,186,85],[254,185,84],[254,185,83],[254,184,83],[254,184,82],[254,183,82],[254,183,81],[254,182,81],[254,182,80],[254,181,79],[254,181,79],[254,180,78],[254,180,78],[254,179,77],[254,179,77],[254,178,76],[254,177,76],[254,177,76],[254,176,75],[254,176,75],[254,175,75],[254,175,75],[254,174,74],[254,174,74],[254,173,74],[254,173,74],[254,172,74],[254,172,73],[254,171,73],[254,171,73],[254,170,73],[254,170,72],[254,169,72],[254,169,72],[254,168,72],[254,168,72],[254,167,71],[254,167,71],[254,166,71],[254,166,71],[254,165,71],[254,165,70],[254,164,70],[254,164,70],[254,163,70],[254,163,69],[254,162,69],[254,162,69],[254,161,69],[254,161,69],[254,160,68],[254,160,68],[253,159,68],[253,159,68],[253,158,67],[253,158,67],[253,157,67],[253,157,67],[253,156,67],[253,156,66],[253,155,66],[253,155,66],[253,154,66],[253,154,65],[253,153,65],[253,153,65],[253,152,65],[253,152,65],[253,151,64],[253,151,64],[253,150,64],[253,150,64],[253,149,64],[253,149,63],[253,148,63],[253,148,63],[253,147,63],[253,147,62],[253,146,62],[253,146,62],[253,145,62],[253,145,62],[253,144,61],[253,144,61],[253,143,61],[253,143,61],[253,142,60],[253,142,60],[253,141,60],[253,140,60],[253,139,60],[253,138,59],[253,138,59],[253,137,59],[253,136,59],[253,135,58],[253,134,58],[253,133,58],[253,132,58],[253,132,57],[253,131,57],[253,130,57],[253,129,57],[253,128,56],[253,127,56],[253,126,56],[253,125,56],[253,125,55],[253,124,55],[253,123,55],[253,122,55],[253,121,54],[253,120,54],[253,119,54],[253,119,54],[253,118,53],[253,117,53],[253,116,53],[253,115,53],[253,114,52],[253,113,52],[253,113,52],[253,112,52],[253,111,51],[253,110,51],[252,109,51],[252,108,51],[252,107,50],[252,106,50],[252,106,50],[252,105,50],[252,104,49],[252,103,49],[252,102,49],[252,101,49],[252,100,48],[252,100,48],[252,99,48],[252,98,48],[252,97,47],[252,96,47],[252,95,47],[252,94,47],[252,94,46],[252,93,46],[252,92,46],[252,91,46],[252,90,45],[252,89,45],[252,88,45],[252,87,45],[252,87,44],[252,86,44],[252,85,44],[252,84,44],[252,83,43],[252,82,43],[252,81,43],[252,81,43],[252,80,42],[252,79,42],[252,78,42],[252,77,42],[251,77,42],[251,76,41],[251,75,41],[250,74,41],[250,74,41],[250,73,41],[249,72,40],[249,72,40],[249,71,40],[248,70,40],[248,69,40],[248,69,40],[247,68,39],[247,67,39],[247,67,39],[246,66,39],[246,65,39],[245,64,38],[245,64,38],[245,63,38],[244,62,38],[244,62,38],[244,61,37],[243,60,37],[243,59,37],[243,59,37],[242,58,37],[242,57,36],[242,57,36],[241,56,36],[241,55,36],[241,54,36],[240,54,35],[240,53,35],[240,52,35],[239,52,35],[239,51,35],[239,50,35],[238,50,34],[238,49,34],[238,48,34],[237,47,34],[237,47,34],[237,46,33],[236,45,33],[236,45,33],[236,44,33],[235,43,33],[235,42,32],[235,42,32],[234,41,32],[234,40,32],[234,40,32],[233,39,31],[233,38,31],[232,37,31],[232,37,31],[232,36,31],[231,35,30],[231,35,30],[231,34,30],[230,33,30],[230,32,30],[230,32,30],[229,31,29],[229,30,29],[229,30,29],[228,29,29],[228,28,29],[228,27,28],[227,27,28],[227,26,28],[226,26,28],[226,25,28],[225,25,28],[224,25,29],[224,24,29],[223,24,29],[222,24,29],[222,23,29],[221,23,29],[220,22,29],[219,22,30],[219,22,30],[218,21,30],[217,21,30],[217,21,30],[216,20,30],[215,20,30],[215,20,30],[214,19,31],[213,19,31],[213,19,31],[212,18,31],[211,18,31],[211,17,31],[210,17,31],[209,17,32],[209,16,32],[208,16,32],[207,16,32],[206,15,32],[206,15,32],[205,15,32],[204,14,33],[204,14,33],[203,14,33],[202,13,33],[202,13,33],[201,12,33],[200,12,33],[200,12,33],[199,11,34],[198,11,34],[198,11,34],[197,10,34],[196,10,34],[195,10,34],[195,9,34],[194,9,35],[193,9,35],[193,8,35],[192,8,35],[191,7,35],[191,7,35],[190,7,35],[189,6,36],[189,6,36],[188,6,36],[187,5,36],[187,5,36],[186,5,36],[185,4,36],[185,4,36],[184,4,37],[183,3,37],[182,3,37],[182,2,37],[181,2,37],[180,2,37],[180,1,37],[179,1,38],[178,1,38],[178,0,38],[177,0,38]];
	const inclinationColours = [[255,255,0],[253,254,2],[251,253,4],[249,252,5],[247,251,7],[245,250,9],[243,249,11],[241,249,13],[239,248,14],[237,247,16],[235,246,18],[233,245,20],[231,244,22],[229,243,23],[227,242,25],[225,241,27],[223,240,29],[221,239,31],[219,238,32],[217,237,34],[215,237,36],[213,236,38],[211,235,40],[209,234,41],[207,233,43],[205,232,45],[203,231,47],[201,230,49],[199,229,50],[197,228,52],[195,227,54],[193,226,56],[191,226,58],[189,225,60],[187,224,61],[185,223,63],[183,222,65],[181,221,67],[179,220,69],[177,219,70],[175,218,72],[173,217,74],[171,216,76],[169,215,78],[167,214,79],[165,214,81],[163,213,83],[161,212,85],[159,211,87],[157,210,88],[155,209,90],[153,208,92],[151,207,94],[149,206,96],[147,205,97],[145,204,99],[143,203,101],[141,202,103],[139,202,105],[137,201,106],[135,200,108],[133,199,110],[131,198,112],[129,197,114],[126,196,115],[124,195,117],[122,194,119],[120,193,121],[118,192,123],[116,191,124],[114,191,126],[112,190,128],[110,189,130],[108,188,132],[106,187,133],[104,186,135],[102,185,137],[100,184,139],[98,183,141],[96,182,142],[94,181,144],[92,180,146],[90,179,148],[88,179,150],[86,178,151],[84,177,153],[82,176,155],[80,175,157],[78,174,159],[76,173,160],[74,172,162],[72,171,164],[70,170,166],[68,169,168],[66,168,169],[64,167,171],[62,167,173],[60,166,175],[58,165,177],[56,164,179],[54,163,180],[52,162,182],[50,161,184],[48,160,186],[46,159,188],[44,158,189],[42,157,191],[40,156,193],[38,156,195],[36,155,197],[34,154,198],[32,153,200],[30,152,202],[28,151,204],[26,150,206],[24,149,207],[22,148,209],[20,147,211],[18,146,213],[16,145,215],[14,144,216],[12,144,218],[10,143,220],[8,142,222],[6,141,224],[4,140,225],[2,139,227],[0,138,229]];
	const surveyColours = [[0xa6,0xce,0xe3],[0x1f,0x78,0xb4],[0xb2,0xdf,0x8a],[0x33,0xa0,0x2c],[0xfb,0x9a,0x99],[0xe3,0x1a,0x1c],[0xfd,0xbf,0x6f],[0xff,0x7f,0x00],[0xca,0xb2,0xd6],[0x6a,0x3d,0x9a],[0xff,0xff,0x99]];
	const hypsometric = [[148,191,139],[148,191,139],[168,198,143],[168,198,143],[189,204,150],[189,204,150],[209,215,171],[209,215,171],[225,228,181],[225,228,181],[239,235,192],[239,235,192],[232,225,182],[232,225,182],[222,214,163],[222,214,163],[211,202,157],[211,202,157],[202,185,130],[202,185,130],[195,167,107],[195,167,107],[192,154,83],[192,154,83],[184,146,71],[184,146,71],[175,140,71],[175,140,71],[168,136,71],[168,136,71],[159,128,72],[159,128,72]];

	const Colours = {
		inclination: inclinationColours,
		gradientLow: gradientColoursLow,
		gradientHi:  gradientColoursHi,
		survey:      surveyColours,
		depth:       depthColours,
		hypsometric: hypsometric
	};

	// define colors to share THREE.color objects across multiple instances

	class ColourCache {

		static setCache = [];
		static cache = [];

		constructor () {}

		getColorSet ( name ) {

			let entry = ColourCache.setCache[ name ];

			if ( entry === undefined ) {

				const scale = Colours[ name ];

				if ( scale === undefined ) console.error( 'unknown colour scale requested ' + name );

				entry = scale.map( c => new Color( c[ 0 ] / 255, c[ 1 ] / 255, c[ 2 ] / 255 ) );
				ColourCache.setCache[ name ] = entry;

			}

			return entry;

		}

		getColour ( name ) {

			let entry = ColourCache.cache[ name ];

			if ( entry === undefined ) {

				entry = new Color( name );
				ColourCache.cache[ name ] = entry;

			}

			return entry;

		}

	}

	class ContourMaterial extends CommonTerrainMaterial {

		constructor ( ctx ) {

			const survey = ctx.survey;
			const cfg = ctx.cfg;
			const materials = ctx.materials;

			super( ctx );

			this.extensions = { derivatives: true };

			this.onBeforeCompile = function ( shader ) {

				this.commonBeforeCompile( ctx, shader );

				Object.assign( shader.uniforms, {
					zOffset:         { value: survey.offsets.z },
					contourInterval: { value: cfg.themeValue( 'shading.contours.interval' ) },
					contourColor:    { value: cfg.themeColor( 'shading.contours.line' ) },
					contourColor10:  { value: cfg.themeColor( 'shading.contours.line10' ) },
					baseColor:       { value: cfg.themeColor( 'shading.contours.base' ) }
				}, materials.uniforms.commonDepth );

				this.editShaderInclude( shader, 'contour' );

			};

		}

	}

	class CursorMaterial extends ShaderMaterial {

		constructor ( ctx, options ) {

			const survey = ctx.survey;
			const limits = survey.modelLimits;
			const uniforms = ctx.materials.uniforms;

			super( {
				vertexShader: Shaders.cursorVertexShader,
				fragmentShader: Shaders.cursorFragmentShader,
				type: 'CV.CursorMaterial',
				uniforms: Object.assign( {
					uLight:      { value: survey.lightDirection }
				}, cloneUniforms( uniforms.cursor ),
				uniforms.common ),
				defines: {
					USE_COLOR: true,
					CV_LOCATION: options.location
				}
			} );

			this.transparent = options.location;
			this.halfRange = ( limits.max.z - limits.min.z ) / 2;
			this.uniforms.cursor.value = 0;

		}

		setCursor ( value ) {

			const newValue = Math.max( Math.min( value, this.halfRange ), -this.halfRange );

			this.uniforms.cursor.value = newValue;

			return newValue; // return value clamped to material range

		}

		getCursor () {

			return this.uniforms.cursor.value;

		}

	}

	class DepthCursorMaterial extends ShaderMaterial {

		constructor( ctx, options ) {

			const survey = ctx.survey;
			const surveyLimits = survey.modelLimits;
			const terrain = survey.terrain;

			const limits = terrain.boundingBox;
			const range = limits.getSize( new Vector3() );

			// max range of depth values
			const max = surveyLimits.max.z - surveyLimits.min.z;
			const uniforms = ctx.materials.uniforms;

			super( {
				vertexShader: Shaders.depthCursorVertexShader,
				fragmentShader: Shaders.depthCursorFragmentShader,
				type: 'CV.DepthCursorMaterial',
				uniforms: Object.assign( {
					uLight:      { value: survey.lightDirection },
					modelMin:    { value: limits.min },
					scaleX:      { value: 1 / range.x },
					scaleY:      { value: 1 / range.y },
					rangeZ:      { value: range.z },
					depthMap:    { value: terrain.depthTexture }
				}, cloneUniforms( uniforms.cursor ),
				uniforms.common, uniforms.commonDepth ),
				defines: {
					USE_COLOR: true,
					CV_LOCATION: options.location
				}
			} );

			this.transparent = options.location;
			this.max = max;
			this.uniforms.cursor.value = max;

		}

		setCursor ( value ) {

			const newValue = Math.max( Math.min( value, this.max ), 0 );

			this.uniforms.cursor.value = newValue;

			return newValue; // return value clamped to material range

		}

		getCursor () {

			return this.uniforms.cursor.value;

		}

	}

	class DepthMaterial extends ShaderMaterial {

		constructor ( ctx, options ) {

			const survey = ctx.survey;
			const surveyLimits = survey.modelLimits;
			const terrain = survey.terrain;
			const limits = terrain.boundingBox;
			const range = limits.getSize( new Vector3() );
			const gradient = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
			const textureCache = ctx.materials.textureCache;
			const uniforms = ctx.materials.uniforms;

			super( {
				vertexShader: Shaders.depthVertexShader,
				fragmentShader: Shaders.depthFragmentShader,
				type: 'CV.DepthMaterial',
				uniforms: Object.assign( {
					// pseudo light source somewhere over viewer's left shoulder.
					uLight:     { value: survey.lightDirection },
					modelMin:   { value: limits.min },
					scaleX:     { value: 1 / range.x },
					scaleY:     { value: 1 / range.y },
					rangeZ:     { value: range.z },
					depthScale: { value: 1 / ( surveyLimits.max.z - surveyLimits.min.z ) },
					cmap:       { value: textureCache.getTexture( gradient ) },
					depthMap:   { value: terrain.depthTexture },
				}, uniforms.common, uniforms.commonDepth ),
				defines: {
					USE_COLOR: true,
					CV_LOCATION: options.location
				}
			} );

			this.transparent = options.location;

		}

	}

	class EntrancePointMaterial extends PointsMaterial {

		constructor ( ctx ) {

			const dotSize = ctx.cfg.themeValue( 'entrance_dot_size' );

			super( {
				map: ctx.materials.textureCache.getTexture( 'disc-outlined' ),
				opacity: 1.0,
				alphaTest: 0.8,
				sizeAttenuation: false,
				transparent: true,
				size: Math.max( dotSize, Math.floor( dotSize * ctx.container.clientWidth / 1000 ) ),
				vertexColors: true
			} );

			this.stencilWrite = true;
			this.stencilZPass = IncrementStencilOp;

			ctx.viewer.addEventListener( 'resized', ( e ) => {

				this.size =  Math.max( dotSize, Math.floor( dotSize * e.width / 1000 ) );

			} );

		}

	}

	class ExtendedPointsMaterial extends PointsMaterial {

		constructor ( ctx ) {

			super();

			const textureCache = ctx.materials.textureCache;

			this.map = textureCache.getTexture( 'disc' );
			this.color = new Color( 0xffffff );
			this.opacity = 1.0;
			this.alphaTest = 0.8;

			this.sizeAttenuation = false;
			this.transparent = true; // to ensure points rendered over lines.
			this.vertexColors = true;

			this.onBeforeCompile = function ( shader ) {

				const vertexShader = shader.vertexShader
					.replace( '#include <common>', '\nattribute float pSize;\n\n$&' )
					.replace( '\tgl_PointSize = size;', '\tgl_PointSize = pSize;' );

				shader.vertexShader = vertexShader;

			};

			return this;

		}

	}

	class GlyphAtlas {

		constructor ( glyphAtlasSpec ) {

			const atlasSize = 512;
			const fontSize = 18;
			const cellSize = 32;

			const divisions = atlasSize / cellSize;
			const canvas = document.createElement( 'canvas' );
			const glyphs = '\u202f\u00B0\u2610 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%,.-_/()[]\'"';
			const map = {};

			let glyphCount = glyphs.length;

			this.cellScale = cellSize / atlasSize;
			this.cellSize = cellSize;

			if ( glyphCount > divisions * divisions ) {

				console.error( 'too many glyphs for atlas' );
				return;

			}

			if ( ! canvas ) console.error( 'creating canvas for glyph atlas failed' );

			canvas.width = atlasSize;
			canvas.height = atlasSize;

			const ctx = canvas.getContext( '2d' );

			if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

			// set background
			ctx.fillStyle = glyphAtlasSpec.background || 'rgba( 0, 0, 0, 0 )';
			ctx.fillRect( 0, 0, atlasSize, atlasSize );

			// set up text settings
			ctx.textAlign = 'left';
			ctx.font = fontSize + 'px ' + glyphAtlasSpec.font;
			ctx.fillStyle = glyphAtlasSpec.color || '#ffffff';

			for ( let i = 0; i < glyphCount; i++ ) {

				addGlyphToCanvas( glyphs.charAt( i ), i );

			}

			const texture = new CanvasTexture( canvas );

			texture.minFilter = LinearFilter;
			this.generateMipmaps = false;

			function addGlyphToCanvas ( glyph, i ) {

				const glyphWidth = ctx.measureText( glyph ).width / cellSize;

				const row = Math.floor( i / divisions ) + 1;
				const column = i % divisions;

				const glyphData = {
					row: ( divisions - row ) / divisions,
					column: column / divisions,
					width: glyphWidth
				};

				map[ glyph ] = glyphData;

				ctx.fillText( glyph, cellSize * column, cellSize * row - 7 );

				return glyphData;

			}

			this.getTexture = function () {

				return texture;

			};

			this.getGlyph = function ( glyph ) {

				let glyphData = map[ glyph ];

				if ( glyphData === undefined ) {

					if ( glyphCount + 1 > divisions * divisions ) {

						console.warn( `too many glyphs for atlas when adding [${glyph}]` );
						return;

					}

					glyphData = addGlyphToCanvas( glyph, glyphCount++ );

					texture.needsUpdate = true;

				}

				return glyphData;

			};

		}

	}

	function GlyphAtlasCache () {

		const atlasCache = [];

		this.getAtlas = function ( glyphAtlasSpec ) {

			const key = JSON.stringify( glyphAtlasSpec );

			let atlas = atlasCache[ key ];

			if ( atlas === undefined ) {

				atlas = new GlyphAtlas( glyphAtlasSpec );
				atlasCache[ key ] = atlas;

			}

			return atlas;

		};

	}

	class GlyphMaterial extends ShaderMaterial {

		constructor ( ctx, glyphAtlas, rotation, viewer ) {

			const uniforms = ctx.materials.uniforms;
			const cellScale = glyphAtlas.cellScale;
			const container = viewer.container;
			const realPixels = glyphAtlas.cellSize * 2;
			const pixelRatio = window.devicePixelRatio || 1;

			const cos = Math.cos( -rotation );
			const sin = Math.sin( -rotation );

			const cosR = Math.cos( rotation );
			const sinR = Math.sin( rotation );

			const viewPort = new Vector2( Math.floor( pixelRatio * container.clientWidth ) / 2, Math.floor( pixelRatio * container.clientHeight ) / 2 );
			const scale = new Vector2( realPixels, realPixels ).divide( viewPort );

			const rotationMatrix = new Float32Array( [ cos, -sin, sin, cos ] );

			super( {
				vertexShader: Shaders.glyphVertexShader,
				fragmentShader: Shaders.glyphFragmentShader,
				type: 'CV.GlyphMaterial',
				uniforms: Object.assign( {
					cellScale: { value: cellScale },
					atlas: { value: glyphAtlas.getTexture() },
					rotate: { value: rotationMatrix },
					scale: { value: scale },
					viewPort: { value: viewPort }
				}, uniforms.common ),
			} );

			this.rotation = rotation;
			this.alphaTest = 0.9;
			this.depthTest = false;
			this.transparent = true;

			this.type = 'CV.GlyphMaterial';
			this.atlas = glyphAtlas;
			this.scaleFactor = glyphAtlas.cellSize / pixelRatio;
			this.toScreenSpace = new Vector3( container.clientWidth/ 2, container.clientHeight / 2, 1 );

			viewer.addEventListener( 'resized', _resize );

			const self = this;

			function _resize () {

				self.uniforms.scale.value.set( realPixels / Math.floor( pixelRatio * container.clientWidth ), realPixels/ Math.floor( pixelRatio * container.clientHeight ) );
				self.toScreenSpace.set( container.clientWidth/ 2, container.clientHeight / 2, 1 );
				this.scaleFactor = glyphAtlas.cellSize / pixelRatio;

			}

			this.rotateVector = function ( v ) {

				const x = v.x;
				const y = v.y;

				v.x = cosR * x - sinR * y;
				v.y = sinR * x + cosR * y;

			};

		}

		getCellSize () {

			return this.atlas.cellSize;

		}

		getAtlas () {

			return this.atlas;

		}

	}

	class HeightMaterial extends ShaderMaterial {

		constructor ( ctx, options ) {

			const survey = ctx.survey;
			const limits = survey.modelLimits;

			const zMin = limits.min.z;
			const zMax = limits.max.z;
			const gradient = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
			const textureCache = ctx.materials.textureCache;
			const uniforms = ctx.materials.uniforms;

			super( {
				vertexShader: Shaders.heightVertexShader,
				fragmentShader: Shaders.heightFragmentShader,
				type: 'CV.HeightMaterial',
				uniforms: Object.assign( {
					uLight: { value: survey.lightDirection },
					minZ:   { value: zMin },
					scaleZ: { value: 1 / ( zMax - zMin ) },
					cmap:   { value: textureCache.getTexture( gradient ) },
				}, uniforms.common ),
				defines: {
					USE_COLOR: true,
					CV_LOCATION: options.location
				}
			} );

			this.transparent = options.location;
			this.midRange = ( zMax + zMin ) / 2;

		}

	}

	class HypsometricMaterial extends CommonTerrainMaterial {

		constructor ( ctx ) {

			const survey = ctx.survey;
			const cfg = ctx.cfg;
			const terrain = survey.terrain;
			const textureCache = ctx.materials.textureCache;

			super( ctx );

			if ( terrain ) {

				if ( terrain.boundingBox === undefined ) terrain.computeBoundingBox();

				const zMin = cfg.themeValue( 'shading.hypsometric.min', terrain.boundingBox.min.z );
				const zMax = cfg.themeValue( 'shading.hypsometric.max', terrain.boundingBox.max.z );

				this.onBeforeCompile = function ( shader ) {

					this.commonBeforeCompile( ctx, shader );

					Object.assign(
						shader.uniforms,
						{
							minZ:   { value: zMin },
							scaleZ: { value: 1 / ( zMax - zMin ) },
							cmap:   { value: textureCache.getTexture( 'hypsometric' ) }
						}
					);

					this.editShaderInclude( shader, 'hypsometric' );

				};

			}

		}

	}

	class WallMaterial extends ShaderMaterial {

		constructor ( ctx, options ) {

			const survey = ctx.survey;
			const uniforms = ctx.materials.uniforms;

			super( {
				vertexShader: Shaders.wallVertexShader,
				fragmentShader: Shaders.wallFragmentShader,
				type: 'CV.WallMaterial',
				uniforms: Object.assign( {
					// pseudo light source somewhere over viewer's left shoulder.
					uLight:     { value: survey.lightDirection },
				}, uniforms.common, uniforms.commonDepth ),
				defines: {
					USE_COLOR: true,
					CV_LOCATION: options.location
				}
			} );

			this.transparent = options.location;
			this.color = ctx.cfg.themeColor( 'shading.single' );

			ctx.cfg.themeColor( 'shading.single' ).toArray( this.defaultAttributeValues.color, 0 );

		}

	}

	class MissingMaterial extends CommonTerrainMaterial {

		constructor ( ctx ) {

			super( ctx, { color: 0xff8888} );

		}

	}

	// subclass Line2Material to provide custom defines and uniforms

	class SurveyLineMaterial extends Line2Material {

		constructor ( ctx, mode = 'height', options = null) {

			const survey = ctx.survey;
			const cfg = ctx.cfg;
			const gradient = cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';
			const textureCache = ctx.materials.textureCache;
			const surveyLimits = survey.modelLimits;
			const uniforms = ctx.materials.uniforms;

			const zMax = surveyLimits.max.z;
			const zMin = surveyLimits.min.z;

			const defines = {};

			let terrain = null;
			let limits = null;
			let range = null;
			let max = null;

			if ( survey.terrain ) {

				terrain = survey.terrain;

				if ( terrain.boundingBox ) {

					limits = terrain.boundingBox;
					range = limits.getSize( new Vector3() );

				}

			}

			let customUniforms = {};

			switch ( mode ) {

			case 'height':

				defines.CV_HEIGHT = true;
				customUniforms = {
					minZ:   { value: zMin },
					scaleZ: { value: 1 / ( zMax - zMin ) },
					cmap:   { value: textureCache.getTexture( gradient ) },
				};
				break;

			case 'cursor':

				defines.CV_CURSOR = true;
				customUniforms = cloneUniforms( uniforms.cursor );
				customUniforms.cursor.value = max;
				break;

			case 'depth':

				defines.CV_DEPTH = true;
				customUniforms = Object.assign(
					{
						modelMin:   { value: limits.min },
						scaleX:     { value: 1 / range.x },
						scaleY:     { value: 1 / range.y },
						rangeZ:     { value: range.z },
						depthScale: { value: 1 / ( surveyLimits.max.z - surveyLimits.min.z ) },
						cmap:       { value: textureCache.getTexture( gradient ) },
						depthMap:   { value: terrain.depthTexture },
					},
					uniforms.commonDepth
				);
				break;

			case 'depth-cursor':

				max = surveyLimits.max.z - surveyLimits.min.z;

				defines.CV_DEPTH_CURSOR = true;
				customUniforms = Object.assign(
					{
						modelMin:    { value: limits.min },
						scaleX:      { value: 1 / range.x },
						scaleY:      { value: 1 / range.y },
						rangeZ:      { value: range.z },
						depthMap:    { value: terrain.depthTexture }
					},
					cloneUniforms( uniforms.cursor ),
					uniforms.commonDepth
				);
				customUniforms.cursor.value = max / 2;
				break;

			case 'z':

				defines.CV_Z = true;
				break;

			default:

				defines.CV_BASIC = true;

			}

			const params = {
				color: 0xffffff,
				vertexColors: true,
				dashSize: 2,
				gapSize: 2
			};

			super( ctx, params, defines, customUniforms );

			if ( options !== null ) {

				if ( options.dashed ) defines.USE_DASH = true;

				if ( options.location ) {

					defines.CV_LOCATION = true;
					this.transparent = true;

				}

			}

			// for cursor material variant
			this.halfRange = ( surveyLimits.max.z - surveyLimits.min.z ) / 2;
			this.max = max;

		}

		setCursor ( value ) {

			let newValue;

			if ( this.max !== null ) {

				newValue = Math.max( Math.min( value, this.max ), 0 ); // depthCursor

			} else {

				newValue = Math.max( Math.min( value, this.halfRange ), -this.halfRange );

			}

			this.uniforms.cursor.value = newValue;

			return newValue; // return value clamped to material range

		}

		getCursor () {

			return this.uniforms.cursor.value;

		}

	}

	// define colors to share THREE.color objects

	class TextureCache {

		constructor () {

			const cache = [];

			function createTexture ( scale ) {

				const n = [];

				// add alpha values
				scale.forEach( colour => { n.push( ...colour, 255 ); } );

				const data = Uint8Array.from( n );
				const texture = new DataTexture( data, scale.length, 1, RGBAFormat, UnsignedByteType );

				texture.minFilter = LinearFilter;
				texture.magFilter = LinearFilter;

				texture.needsUpdate = true;

				return texture;

			}

			this.getTexture = function ( name ) {

				let entry = cache[ name ];

				if ( entry === undefined ) {

					if ( name === 'disc' ) {

						entry = new TextureLoader().load( "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='0'/%3E%3C/svg%3E%0A" );

					} else if ( name === 'disc-outlined' ) {

						entry = new TextureLoader().load( "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg id='a' width='32mm' height='32mm' version='1.1' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' %3E%3Ccircle id='d' cx='16' cy='16' r='14' color='%23000000' fill='%23fff' fill-rule='evenodd' stroke-width='1' stroke='%23000'/%3E%3C/svg%3E%0A" );

					} else {

						const scale = Colours[ name ];

						if ( scale === undefined ) console.error( 'unknown colour scale requested ' + name );

						entry = createTexture( scale );

					}

					cache[ name ] = entry;

				}

				return entry;

			};

		}

	}

	function Materials ( viewer ) {

		const cache = new Map();
		const ctx = viewer.ctx;
		const cfg = ctx.cfg;

		const glyphAtlasCache = new GlyphAtlasCache();
		const cursorMaterials = new Set();
		const lineMaterials = new Set();
		const surveyLineMaterials = new Set();
		const wallMaterials = new Set();

		let perSurveyMaterials = {};

		let cursorHeight = 0;
		let linewidth = 1;
		let scaleLinewidth = false;
		let locationMode = false;

		const colourCache = new ColourCache();
		const textureCache = new TextureCache();

		this.colourCache = colourCache;
		this.textureCache = textureCache;

		const gradientType = cfg.value( 'saturatedGradient', false ) || cfg.themeValue( 'saturatedGradient' );
		const gradient = gradientType ? 'gradientHi' : 'gradientLow';

		this.uniforms = {
			common: {
				fogColor: { value: cfg.themeColor( 'background' ) },
				fogDensity: { value: 0.0025 },
				distanceFadeMin: { value: 0.0 },
				distanceFadeMax: { value: 0.0 },
				cameraLocation: { value: new Vector3() }
			},

			commonDepth: {
				datumShift: { value: 0.0 }
			},

			cursor: {
				cursor:      { value: 0 },
				cursorWidth: { value: 5.0 },
				baseColor:   { value: cfg.themeColor( 'shading.cursorBase' ) },
				cursorColor: { value: cfg.themeColor( 'shading.cursor' ) },
			},

			location: {
				accuracy: { value: -1.0 },
				target: { value: new Vector2() },
				ringColor: { value: new Color( 0xff0000 ) },
			}

		};

		this.terrainOpacity = 0.5;

		Object.defineProperties( this, {

			'cursorHeight': {
				get() { return cursorHeight; },
				set( newHeight ) {
					cursorMaterials.forEach(
						material => cursorHeight = material.setCursor( newHeight )
					);
				}
			},

			'linewidth': {
				get() { return linewidth; },
				set( width ) {
					lineMaterials.forEach( material => material.linewidth = width );
					linewidth = width;
				}
			},

			'scaleLinewidth': {
				get() { return scaleLinewidth; },
				set( mode ) {
					surveyLineMaterials.forEach( material => material.scaleLinewidth = mode );
					scaleLinewidth = mode;
				}
			}

		} );

		function cacheMaterial ( name, material, stencil ) {

			cache.set( name, material );

			if ( stencil ) {

				material.stencilWrite = true;
				material.stencilZPass = IncrementStencilOp;

			}

			return material;

		}

		function getCacheMaterial ( name, materialFunc, stencil ) {

			let material = cache.get( name );

			if ( material === undefined && materialFunc ) {

				material = cacheMaterial( name, materialFunc(), stencil );

			}

			return material;

		}

		function getSurveyCacheMaterial ( name, materialFunc, stencil ) {

			const material = getCacheMaterial( name, materialFunc, stencil );
			perSurveyMaterials[ name ] = material;

			return material;

		}

		function getWallMaterial ( name, materialClass, stencil ) {

			const material = getSurveyCacheMaterial( name, () => new materialClass( ctx, { location: locationMode } ), stencil );

			wallMaterials.add( material );

			return material;

		}

		this.setLocation = function ( location = null, accuracy = 0, minDistance = 0, maxDistance = 0 ) {

			const updateMaterial = ( material ) => {

				material.defines.CV_LOCATION = locationMode;
				material.transparent = locationMode;
				material.needsUpdate = true;

			};

			const locationUniforms = this.uniforms.location;

			if ( location === null ) {

				if ( locationMode ) {

					console.log( 'disable loc' );
					locationMode = false;

					locationUniforms.accuracy.value = -1.0;

					surveyLineMaterials.forEach( updateMaterial );
					wallMaterials.forEach( updateMaterial );

				}

			} else {

				if ( ! locationMode ) {

					locationMode = true;

					locationUniforms.accuracy.value = accuracy;
					locationUniforms.target.value.set( location.x, location.y );

					surveyLineMaterials.forEach( updateMaterial );
					wallMaterials.forEach( updateMaterial );

				}

				const commonUniforms = this.uniforms.common;

				commonUniforms.distanceFadeMin.value = minDistance;
				commonUniforms.distanceFadeMax.value = maxDistance;
				commonUniforms.cameraLocation.value.copy( location );

				locationUniforms.target.value.set( location.x, location.y );

			}

		};

		this.getLine2Material = function ( params = { color: 'green' } ) {

			const func = () => new Line2Material( ctx, params );
			const material = getCacheMaterial( 'line2' + JSON.stringify( params ), func, true );

			return material;

		};

		this.getSurveyLineMaterial = function ( mode = '', dashed = false ) {

			const options = { dashed: dashed, location: locationMode };

			const func = () => new SurveyLineMaterial( ctx, mode, options );
			const material = getSurveyCacheMaterial( 'survey-line-' + mode + ( dashed ? '-dashed' : '' ), func, true );

			if ( mode === 'cursor' || mode === 'depth-cursor' ) {

				// set active cursor material for updating
				cursorMaterials.add( material );

			}

			lineMaterials.add( material );
			surveyLineMaterials.add( material );
			material.linewidth = linewidth;

			return material;

		};

		this.getHeightMaterial = function () {

			return getWallMaterial( 'height', HeightMaterial, true );

		};

		this.getSingleWallMaterial = function  () {

			return getWallMaterial( 'single', WallMaterial, true );

		};

		this.getDepthMaterial = function () {

			return getWallMaterial( 'depth', DepthMaterial, true );

		};

		this.getCursorMaterial = function () {

			const material = getWallMaterial( 'cursor', CursorMaterial, true );
			cursorMaterials.add( material );

			return material;

		};

		this.getDepthCursorMaterial = function () {

			const material = getWallMaterial( 'depthCursor', DepthCursorMaterial, true );
			cursorMaterials.add( material );

			return material;

		};

		this.getUnselectedWallMaterial = function () {

			const func = () => new MeshLambertMaterial( { color: 0x444444, vertexColors: true } );
			return getCacheMaterial( 'unselectedWall', func );

		};

		this.getHypsometricMaterial = function () {

			const func = () => new HypsometricMaterial( ctx );
			return getSurveyCacheMaterial( 'hypsometric', func );

		};

		this.getBezelMaterial = function  () {

			let func;

			if ( cfg.themeValue( 'hud.bezelType' ) === 'flat' ) {

				func = () => new MeshBasicMaterial( { color: cfg.themeValue( 'hud.bezel' ) } );

			} else {

				func = () => new MeshPhongMaterial( { color: cfg.themeValue( 'hud.bezel' ), specular: 0x888888 } );

			}

			return getCacheMaterial( 'bezel', func, true );

		};

		this.getPlainMaterial = function  () {

			const func = () => new MeshBasicMaterial( { color: 0xffffff, vertexColors: true } );
			return getCacheMaterial( 'plain', func, true );

		};


		this.getSurfaceMaterial = function  () {

			const func = () => new MeshLambertMaterial( { color: cfg.themeValue( 'shading.single' ), vertexColors: false } );
			return getCacheMaterial( 'surface', func, true );

		};

		this.getEntrancePointMaterial = function  () {

			const func = () => new EntrancePointMaterial( ctx );
			return getCacheMaterial( 'entrance', func, true );

		};

		this.getExtendedPointsMaterial = function () {

			const func = () => new ExtendedPointsMaterial( ctx );
			return getCacheMaterial( 'extendedPoints', func, true );

		};

		this.getMissingMaterial = function () {

			const func = () => new MissingMaterial( ctx );
			return getCacheMaterial( 'missing', func );

		};

		this.getUnselectedMaterial = function () {

			const func = () => new LineBasicMaterial( { color: 0x444444, vertexColors: true } );
			return getCacheMaterial( 'unselected', func );

		};

		this.getScaleMaterial = function () {

			const func = () => new MeshBasicMaterial( { color: 0xffffff, map: textureCache.getTexture( gradient ) } );
			return getCacheMaterial( 'scale', func );

		};

		this.getContourMaterial = function () {

			const func = () => new ContourMaterial( ctx );
			return getSurveyCacheMaterial( 'contour', func );

		};

		this.getGlyphMaterial = function ( glyphAtlasSpec, rotation ) {

			const atlas = glyphAtlasCache.getAtlas( glyphAtlasSpec );
			const name = JSON.stringify( glyphAtlasSpec ) + ':' + rotation.toString();

			const func = () => new GlyphMaterial( ctx, atlas, rotation, viewer );

			return getCacheMaterial( name, func );

		};

		this.getLabelMaterial = function ( type ) {

			let material = getCacheMaterial( `label-${type}` );

			if ( material === undefined ) {

				const atlasSpec = {
					color: cfg.themeColorCSS( `${type}.text` ),
					background: cfg.themeValue( `${type}.background` ),
					font: cfg.themeValue( `${type}.font` )
				};

				material = this.getGlyphMaterial( atlasSpec, 0 );

			}

			return material;

		};

		this.getClusterMaterial = function ( count ) {

			const func = () => new ClusterMaterial( count );
			return getCacheMaterial( 'cluster' + count, func, true );

		};

		this.setTerrain = function ( terrain ) {

			const updateDatumShifts = event => {

				this.uniforms.commonDepth.datumShift.value = event.value;

			};

			terrain.addEventListener( 'datumShiftChange', updateDatumShifts );

		};

		this.flushCache = function () {

			cursorMaterials.clear();
			lineMaterials.clear();
			surveyLineMaterials.clear();
			wallMaterials.clear();

			for ( const name in perSurveyMaterials ) {

				const material = perSurveyMaterials[ name ];

				material.dispose();
				cache.delete( name );

			}

			perSurveyMaterials = {};
			ctx.glyphStringCache = new Map();
			cursorHeight = 0;

		};

		this.setFog = function ( enable ) {

			for ( const name in perSurveyMaterials ) {

				const material = perSurveyMaterials[ name ];

				material.fog = enable;
				material.needsUpdate = true;

			}

		};

	}

	class ModelSource {

		static lastId = 0;

		name = null;
		files = [];
		local = true;

		constructor ( files, local ) {

			this.files = files;
			this.local = local;
			this.id = ModelSource.lastId++;

		}

		addFile ( file ) {

			this.files.push( file );

		}

		static makeModelSourceFiles( files ) {

			const source = new ModelSource( [], false );

			files.forEach( file => source.addFile( { name: file } ) );

			return source;

		}

	}

	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

	const MODE_LOCK_UNLOCKED = 0;
	const MODE_LOCK_ROTATE = 1;
	const MODE_LOCK_ZOOM = 2;
	const SVX_DELTA = Math.PI / 60;

	const __v$1 = new Vector3();

	class OrbitControls extends EventDispatcher {

		constructor ( cameraManager, domElement, viewer ) {

			super();

			this.cameraManager = cameraManager;

			const element = domElement;

			// Set to false to disable this control
			this.enabled = true;

			// "target" sets the location of focus, where the object orbits around
			this.target = new Vector3();

			// How far you can orbit vertically, upper and lower limits.
			// Range is 0 to Math.PI radians.
			this.minPolarAngle = 0; // radians
			this.maxPolarAngle = Math.PI; // radians

			// How far you can orbit horizontally, upper and lower limits.
			// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
			this.minAzimuthAngle = - Infinity; // radians
			this.maxAzimuthAngle = Infinity; // radians

			this.zoomSpeed = 1.0;
			this.zoomToCursor = false;

			// Set to false to disable panning
			this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

			// Set to true to automatically rotate around the target
			// If auto-rotate is enabled, you must call controls.update() in your animation loop
			this.autoRotate = false;
			this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

			// Set to false to disable use of the keys
			this.enableKeys = true;

			// The four arrow keys
			this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

			// mouse wheel mode
			this.wheelTilt = false;

			// for reset

			const camera = cameraManager.activeCamera;

			this.target0 = this.target.clone();
			this.position0 = camera.position.clone();
			this.zoom0 = camera.zoom;


			//
			// public methods
			//

			this.clearLimits = function () {

				// How far you can dolly in and out ( PerspectiveCamera only )
				this.minDistance = 0;
				this.maxDistance = Infinity;

				// How far you can zoom in and out ( OrthographicCamera only )
				this.minZoom = 0;
				this.maxZoom = Infinity;

			};

			this.clearLimits();

			this.setLimits = function ( range ) {

				const camera = cameraManager.activeCamera;

				const currentDistance = this.target.distanceTo( camera.position );

				const mSize = Math.max( range.x, range.y );

				let scale = 2;

				if ( range.z > mSize ) scale *= range.z / mSize;

				this.maxDistance = currentDistance * scale;
				this.minDistance = currentDistance / mSize;

				// for orthographic camera
				this.minZoom = 1 / scale;
				this.maxZoom = Math.max( range.x, range.y );

			};

			this.getPolarAngle = function () {

				return spherical.phi;

			};

			this.getAzimuthalAngle = function () {

				return spherical.theta;

			};

			this.rotateUp = function ( angle ) {

				rotateUp( angle );
				this.update();

			};

			this.rotateLeft = function ( angle ) {

				rotateLeft( angle );
				this.update();

			};

			this.scaleDolly = function ( scaleFactor ) {

				scale *= scaleFactor;
				this.update();

			};

			this.saveState = function () {

				const camera = cameraManager.activeCamera;

				this.target0.copy( scope.target );
				this.position0.copy( camera.position );
				this.zoom0 = camera.zoom;

			};

			this.reset = function () {

				const camera = cameraManager.activeCamera;

				this.clearLimits();

				this.target.copy( scope.target0 );
				camera.position.copy( scope.position0 );
				camera.zoom = scope.zoom0;

				camera.updateProjectionMatrix();
				this.dispatchEvent( changeEvent );

				this.update();

				state = STATE.NONE;

			};

			// this method is exposed, but perhaps it would be better if we can make it private...
			this.update = function () {

				const offset = new Vector3();
				const up = cameraManager.activeCamera.up;

				// so camera.up is the orbit axis
				const quat = new Quaternion().setFromUnitVectors( up, new Vector3( 0, 1, 0 ) );
				const quatInverse = quat.clone().invert();

				const lastPosition = new Vector3();
				const lastQuaternion = new Quaternion();

				return function update() {

					const camera = cameraManager.activeCamera;
					const target = scope.target;
					const position = camera.position;

					offset.copy( position ).sub( target );

					// rotate offset to "y-axis-is-up" space
					offset.applyQuaternion( quat );

					// angle from z-axis around y-axis
					spherical.setFromVector3( offset );

					if ( scope.autoRotate && state === STATE.NONE ) {

						rotateLeft( getAutoRotationAngle() );

					}

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

					// restrict theta to be between desired limits
					spherical.theta = clamp( spherical.theta, scope.minAzimuthAngle, scope.maxAzimuthAngle );

					// restrict phi to be between desired limits
					spherical.phi = clamp( spherical.phi, scope.minPolarAngle, scope.maxPolarAngle );

					spherical.makeSafe();

					const prevRadius = Math.max( spherical.radius, EPS );
					spherical.radius *= scale;

					// restrict radius to be between desired limits
					spherical.radius = clamp( spherical.radius, scope.minDistance, scope.maxDistance );

					// move target to panned location
					target.add( panOffset );

					// suport zoomToCursor (mouse only)

					if ( scope.zoomToCursor ) {

						if ( camera.isPerspectiveCamera ) {

							target.lerp( mouse3D, 1 - spherical.radius / prevRadius );

						} else if ( camera.isOrthographicCamera ) {

							target.lerp( mouse3D, 1 - zoomFactor );

						}

					}

					offset.setFromSpherical( spherical );

					// rotate offset back to "camera-up-vector-is-up" space
					offset.applyQuaternion( quatInverse );

					position.copy( target ).add( offset );

					camera.lookAt( target );

					sphericalDelta.set( 0, 0, 0 );
					panOffset.set( 0, 0, 0 );

					scale = 1;

					// update condition is:
					// min(camera displacement, camera rotation in radians)^2 > EPS
					// using small-angle approximation cos(x/2) = 1 - x^2 / 8

					if ( zoomChanged ||
						lastPosition.distanceToSquared( position ) > EPS ||
						8 * ( 1 - lastQuaternion.dot( camera.quaternion ) ) > EPS ) {

						scope.dispatchEvent( changeEvent );

						lastPosition.copy( position );
						lastQuaternion.copy( camera.quaternion );
						zoomChanged = false;
						zoomFactor = 1;

						return true;

					}

					return false;

				};

			}();

			this.dispose = function () {

				element.removeEventListener( 'contextmenu', onContextMenu, false );
				element.removeEventListener( 'mousedown', onMouseDown, false );
				element.removeEventListener( 'wheel', onMouseWheel, false );

				element.removeEventListener( 'touchstart', onTouchStart, false );
				element.removeEventListener( 'touchend', onTouchEnd, false );
				element.removeEventListener( 'touchmove', onTouchMove, false );

				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );

				element.removeEventListener( 'keydown', onKeyDown, false );

			};

			this.end = function () {

				this.dispatchEvent( endEvent );

			};

			Object.defineProperty( this, 'svxControlMode', {
				set: setControlMode,
				get() { return svxControlMode; }

			} );

			//
			// internals
			//

			const scope = this;

			const changeEvent = { type: 'change' };
			const startEvent = { type: 'start' };
			const endEvent = { type: 'end' };

			const LEFT_BUTTON = 1;
			const RIGHT_BUTTON = 2;
			const MIDDLE_BUTTON = 4;
			const EMULATED_MIDDLE_BUTTON = 3;

			let buttons = 0;
			let lastButtonDownTime = 0;

			const STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

			let state = STATE.NONE;

			const EPS = 0.000001;

			// current position in spherical coordinates
			const spherical = new Spherical();
			const sphericalDelta = new Spherical();

			let scale = 1;
			const panOffset = new Vector3();
			let zoomChanged = false;
			let zoomFactor = 1;

			const rotateStart = new Vector2();
			const rotateEnd = new Vector2();
			const rotateDelta = new Vector2();

			const panStart = new Vector2();
			const panEnd = new Vector2();
			const panDelta = new Vector2();

			const dollyStart = new Vector2();
			const dollyEnd = new Vector2();
			const dollyDelta = new Vector2();

			const mouse3D = new Vector3();
			const mouseStart = new Vector3();

			let firstWheelMove = true;

			const svxStart = new Vector2();
			const svxEnd = new Vector2();
			const svxDelta = new Vector2();

			let modeLock = MODE_LOCK_UNLOCKED;
			let lastMoveTime = 0;
			let svxReverseSense = -1;

			let svxControlMode  = false;

			// mode specific handlers

			let handleMouseDownLeft;
			let handleMouseDownMiddle;
			let handleMouseMoveLeft;
			let handleMouseMoveMiddle;


			function setControlMode ( svxMode ) {

				if ( svxMode ) {

					handleMouseDownLeft = handleMouseDownSvx;
					handleMouseDownMiddle = handleMouseDownRotate;
					handleMouseMoveLeft = handleMouseMoveSvxLeft;
					handleMouseMoveMiddle = handleMouseMoveSvxMiddle;

				} else {

					handleMouseDownLeft = handleMouseDownRotate;
					handleMouseDownMiddle = handleMouseDownDolly;
					handleMouseMoveLeft = handleMouseMoveRotate;
					handleMouseMoveMiddle = handleMouseMoveDolly;

				}

				svxControlMode = svxMode;

			}

			function getAutoRotationAngle() {

				return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

			}

			function getZoomScale() {

				return Math.pow( 0.95, scope.zoomSpeed );

			}

			function rotateLeft( angle ) {

				sphericalDelta.theta -= angle;

			}

			function rotateUp( angle ) {

				sphericalDelta.phi -= angle;

			}

			const panLeft = function ( distance, objectMatrix ) {

				distance *= svxReverseSense;

				__v$1.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				__v$1.multiplyScalar( distance );

				panOffset.add( __v$1 );

			};


			const panUp = function ( distance, objectMatrix ) {

				distance *= svxReverseSense;

				__v$1.setFromMatrixColumn( objectMatrix, 1 );
				__v$1.multiplyScalar( - distance );

				panOffset.add( __v$1 );

			};

			// deltaX and deltaY are in pixels; right and down are positive
			const pan = function ( deltaX, deltaY ) {

				const camera = cameraManager.activeCamera;

				if ( camera.isPerspectiveCamera ) {

					// perspective
					__v$1.copy( camera.position ).sub( scope.target );

					let targetDistance = __v$1.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( camera.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, camera.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, camera.matrix );

				} else if ( camera.isOrthographicCamera ) {
					// orthographic
					panLeft( deltaX * ( camera.right - camera.left ) / ( camera.zoom * element.clientWidth ), camera.matrix );
					panUp( deltaY * ( camera.top - camera.bottom ) / ( camera.zoom * element.clientHeight ), camera.matrix );

				}

			};

			function dollyIn( dollyScale ) {

				const camera = cameraManager.activeCamera;

				if ( camera.isPerspectiveCamera ) {

					scale /= dollyScale;

				} else if ( camera.isOrthographicCamera ) {

					zoomFactor = camera.zoom;
					camera.zoom = clamp( camera.zoom * dollyScale, scope.minZoom, scope.maxZoom );
					zoomFactor /= camera.zoom;
					camera.updateProjectionMatrix();
					zoomChanged = true;

				}

			}

			function dollyOut( dollyScale ) {

				const camera = cameraManager.activeCamera;

				if ( camera.isPerspectiveCamera ) {

					scale *= dollyScale;

				} else if ( camera.isOrthographicCamera ) {

					zoomFactor = camera.zoom;
					camera.zoom = clamp( camera.zoom / dollyScale, scope.minZoom, scope.maxZoom );
					zoomFactor /= camera.zoom;
					camera.updateProjectionMatrix();
					zoomChanged = true;

				}

			}

			//
			// event callbacks - update the object state
			//

			function handleMouseDownSvx( event ) {

				svxStart.set( event.clientX, event.clientY );

				modeLock = MODE_LOCK_UNLOCKED;

			}

			function handleMouseDownRotate( event ) {

				rotateStart.set( event.clientX, event.clientY );

			}


			function handleMouseDownDolly( event ) {

				dollyStart.set( event.clientX, event.clientY );

			}

			function handleMouseDownPan( event ) {

				panStart.set( event.clientX, event.clientY );

			}

			function rotateSvx() {

				rotateStart.copy( svxStart );
				rotateLeft( 2 * Math.PI * svxDelta.x * svxReverseSense / element.clientWidth );
				rotateStart.copy( svxEnd );

				scope.update();

			}

			function zoomSvx( event ) {

				dollyStart.copy( svxStart );
				handleMouseMoveDolly( event, svxReverseSense );

			}

			function handleMouseMoveSvxLeft( event ) {

				svxEnd.set( event.clientX, event.clientY );

				svxDelta.subVectors( svxEnd, svxStart );

				const now = performance.now();

				if ( now > lastMoveTime + 1000 ) modeLock = MODE_LOCK_UNLOCKED;

				lastMoveTime = now;

				const deltaX2 = svxDelta.x * svxDelta.x;
				const deltaY2 = svxDelta.y * svxDelta.y;

				switch ( modeLock ) {

				case MODE_LOCK_UNLOCKED:

					if ( Math.abs( svxDelta.x ) > Math.abs( svxDelta.y ) ) {

						modeLock = MODE_LOCK_ROTATE;

					} else {

						modeLock = MODE_LOCK_ZOOM;

					}

					break;

				case MODE_LOCK_ROTATE:

					if ( deltaY2 > 8 * deltaX2 ) modeLock = MODE_LOCK_ZOOM;

					break;

				case MODE_LOCK_ZOOM:

					if ( deltaX2 > 8 * deltaY2 ) modeLock = MODE_LOCK_ROTATE;

					break;

				}

				if ( modeLock === MODE_LOCK_ROTATE ) {

					rotateSvx();

				} else {

					zoomSvx( event );

				}

				svxStart.copy( svxEnd );

			}

			function handleMouseMoveSvxMiddle( event ) {

				rotateEnd.set( event.clientX, event.clientY );

				rotateDelta.subVectors( rotateEnd, rotateStart );

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y * svxReverseSense / element.clientHeight );

				rotateStart.copy( rotateEnd );

				scope.update();

			}

			function handleMouseMoveRotate( event ) {

				rotateEnd.set( event.clientX, event.clientY );

				rotateDelta.subVectors( rotateEnd, rotateStart );

				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

				rotateStart.copy( rotateEnd );

				scope.update();

			}

			function handleMouseMoveDolly( event, sense ) {

				dollyEnd.set( event.clientX, event.clientY );

				dollyDelta.subVectors( dollyEnd, dollyStart );

				dollyDelta.y *= sense;

				updateMouse3D( event.clientX, event.clientY );

				if ( dollyDelta.y > 0 ) {

					dollyIn( getZoomScale() );

				} else if ( dollyDelta.y < 0 ) {

					dollyOut( getZoomScale() );

				}

				dollyStart.copy( dollyEnd );

				scope.update();

			}

			function handleMouseMovePan( event ) {

				panEnd.set( event.clientX, event.clientY );

				panDelta.subVectors( panEnd, panStart );

				pan( panDelta.x, panDelta.y );

				panStart.copy( panEnd );

				scope.update();

			}

			const updateMouse3D = function () {

				const _station = new Vector3();
				const v = new Vector3();
				const v1 = new Vector3();
				const up = new Vector3();

				return function updateMouse3D( x, y ) {

					const camera = cameraManager.activeCamera;
					camera.getWorldDirection( up );

					let distance;

					// get mouse in ndc
					const mouse = viewer.getMouse( x, y );

					if ( firstWheelMove || mouseStart.x !== mouse.x || mouseStart.y !== mouse.y ) {

						const station = viewer.getStationUnderMouse( mouse, _station );

						if ( station !== null ) station.project( camera );

						mouseStart.set( mouse.x, mouse.y, station === null ? 0.5 : station.z );
						firstWheelMove = false;

					}

					if ( camera.isPerspectiveCamera ) {

						v.set( mouse.x, mouse.y, mouseStart.z ).unproject( camera );
						v.sub( camera.position ).normalize();

						v1.copy( scope.target ).sub( camera.position );

						distance = v1.dot( up ) / v.dot( up );

						mouse3D.copy( camera.position ).add( v.multiplyScalar( distance ) );

					} else if ( camera.isOrthographicCamera ) {

						v.set( mouse.x, mouse.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) );

						v.unproject( camera );

						v1.set( 0, 0, - 1 ).applyQuaternion( camera.quaternion );

						distance = - v.dot( up ) / v1.dot( up );

						mouse3D.copy( v ).add( v1.multiplyScalar( distance ) );

					}

				};

			}();

			function handleMouseWheel( event ) {

				const deltaY = event.deltaY;

				if ( scope.wheelTilt ) {

					// rotating up and down along whole screen attempts to go 360, but limited to 180
					rotateUp( 2 * Math.PI * deltaY / 12500 );

				} else {

					updateMouse3D( event.clientX, event.clientY );

					if ( deltaY < 0 ) {

						dollyOut( getZoomScale() );

					} else if ( deltaY > 0 ) {

						dollyIn( getZoomScale() );

					}

				}

				scope.update();

			}

			function handleKeyDown( event ) {

				switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case 67: // 'C'

					if ( ! svxControlMode ) break;

					rotateLeft( - SVX_DELTA );
					scope.update();
					break;

				case 82: // 'R'

					if ( ! svxControlMode || ! event.ctrlKey ) break;
					event.preventDefault();
					svxReverseSense *= -1;
					break;

				case 86: // 'V'

					if ( ! svxControlMode ) break;
					rotateLeft( SVX_DELTA );
					scope.update();
					break;

				case 191: // '/

					if ( ! svxControlMode ) break;
					rotateUp( -SVX_DELTA );
					scope.update();
					break;

				case 192: // '''

					if ( ! svxControlMode ) break;
					rotateUp( SVX_DELTA );
					scope.update();
					break;

				case 219: // '['

					if ( ! svxControlMode ) break;
					dollyOut( getZoomScale() );
					scope.update();
					break;

				case 221: // ']'

					if ( ! svxControlMode ) break;
					dollyIn( getZoomScale() );
					scope.update();
					break;

				}

			}

			function handleTouchStartRotate( event ) {

				rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			}

			function handleTouchStartDollyPan( event ) {

				const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

				const distance = Math.sqrt( dx * dx + dy * dy );

				dollyStart.set( 0, distance );

				const x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				const y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				updateMouse3D( x, y );

				panStart.set( x, y );

			}

			function handleTouchMoveRotate( event ) {

				rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

				rotateDelta.subVectors( rotateEnd, rotateStart );

				// rotating across whole screen goes 360 degrees around
				rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth );

				// rotating up and down along whole screen attempts to go 360, but limited to 180
				rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

				rotateStart.copy( rotateEnd );

				scope.update();

			}

			function handleTouchMoveDollyPan( event ) {

				const dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				const dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

				const distance = Math.sqrt( dx * dx + dy * dy );

				dollyEnd.set( 0, distance );

				dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

				dollyIn( dollyDelta.y );

				dollyStart.copy( dollyEnd );

				const x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				const y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				updateMouse3D( x, y );

				panEnd.set( x, y );

				panDelta.subVectors( panEnd, panStart );

				pan( panDelta.x, panDelta.y );

				panStart.copy( panEnd );

				scope.update();

			}

			function setButtons( button ) {

				// add to current buttons depressed set
				// allows emulation of 3rd button in absence of event.buttons

				let newButtons = 0;

				switch ( button ) {

				case MOUSE.LEFT:

					newButtons = LEFT_BUTTON;
					break;

				case MOUSE.MIDDLE:

					newButtons = MIDDLE_BUTTON;
					break;

				case MOUSE.RIGHT:

					newButtons = RIGHT_BUTTON;
					break;

				}

				const now = performance.now();

				if ( now - lastButtonDownTime < 100 ) {

					buttons |= newButtons;

				} else {

					buttons = newButtons;

				}

				lastButtonDownTime = now;

			}

			//
			// event handlers - FSM: listen for events and reset state
			//

			function onMouseDown( event ) {

				if ( scope.enabled === false ) return;
				event.preventDefault();

				setButtons( event.button );

				switch ( buttons ) {

				case LEFT_BUTTON:

					handleMouseDownLeft( event );

					state = STATE.ROTATE;

					break;

				case MIDDLE_BUTTON:
				case EMULATED_MIDDLE_BUTTON:

					handleMouseDownMiddle( event );

					state = STATE.DOLLY;

					break;

				case RIGHT_BUTTON:

					handleMouseDownPan( event );

					element.style.cursor = 'all-scroll';

					state = STATE.PAN;

					break;

				}

				if ( state !== STATE.NONE ) {

					document.addEventListener( 'mousemove', onMouseMove, false );
					document.addEventListener( 'mouseup', onMouseUp, false );

					scope.dispatchEvent( startEvent );

				}

				firstWheelMove = true;

			}

			function onMouseMove( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();

				switch ( state ) {

				case STATE.ROTATE:

					handleMouseMoveLeft( event );

					break;

				case STATE.DOLLY:

					handleMouseMoveMiddle( event, 1 );

					break;

				case STATE.PAN:

					handleMouseMovePan( event );

					break;

				}

				firstWheelMove = true;

			}

			function onMouseUp( /* event */ ) {

				if ( scope.enabled === false ) return;

				element.style.cursor = 'default';

				document.removeEventListener( 'mousemove', onMouseMove, false );
				document.removeEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( endEvent );

				state = STATE.NONE;
				buttons = 0;

			}

			function onMouseWheel( event ) {

				if ( scope.enabled === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

				event.preventDefault();
				event.stopPropagation();

				scope.dispatchEvent( startEvent );

				handleMouseWheel( event );

				scope.dispatchEvent( endEvent );

			}

			function onKeyDown( event ) {

				event.preventDefault();

				if ( scope.enabled === false || scope.enableKeys === false ) return;
				if ( ! viewer.mouseOver ) return;

				handleKeyDown( event );

			}

			function onTouchStart( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();

				switch ( event.touches.length ) {

				case 1:	// one-fingered touch: rotate

					handleTouchStartRotate( event );

					state = STATE.TOUCH_ROTATE;

					break;

				case 2:	// two-fingered touch: dolly-pan

					handleTouchStartDollyPan( event );

					state = STATE.TOUCH_DOLLY_PAN;

					break;

				default:

					state = STATE.NONE;

				}

				if ( state !== STATE.NONE ) {

					scope.dispatchEvent( startEvent );

				}

			}

			function onTouchMove( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();
				event.stopPropagation();

				switch ( event.touches.length ) {

				case 1: // one-fingered touch: rotate

					if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?

					handleTouchMoveRotate( event );

					break;

				case 2: // two-fingered touch: dolly-pan

					if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?

					handleTouchMoveDollyPan( event );

					break;

				default:

					state = STATE.NONE;

				}

			}

			function onTouchEnd( /* event */ ) {

				if ( scope.enabled === false ) return;

				scope.dispatchEvent( endEvent );

				state = STATE.NONE;

			}

			function onContextMenu( event ) {

				if ( scope.enabled === false ) return;

				event.preventDefault();

			}

			//

			element.addEventListener( 'contextmenu', onContextMenu, false );

			element.addEventListener( 'mousedown', onMouseDown, false );
			element.addEventListener( 'wheel', onMouseWheel, false );

			element.addEventListener( 'touchstart', onTouchStart, false );
			element.addEventListener( 'touchend', onTouchEnd, false );
			element.addEventListener( 'touchmove', onTouchMove, false );

			element.addEventListener( 'keydown', onKeyDown, false );

			const cfg = viewer.ctx.cfg;

			setControlMode( cfg.value( 'avenControls', true ) );

			// force an update at start

			this.update();

		}

	}

	class PopupGeometry extends BufferGeometry {

		type = 'PopupGeometery';

		constructor () {

			super();

			this.setIndex( CommonAttributes.index );
			this.setAttribute( 'position', CommonAttributes.position );

		}

	}

	class Popup extends Mesh {

		static commonGeometry = null;

		type = 'Popup';

		constructor ( ctx, renderOrder = Infinity ) {

			if ( Popup.commonGeometry === null ) Popup.commonGeometry = new PopupGeometry();

			super( Popup.commonGeometry );

			this.layers.set( LEG_CAVE );
			this.renderOrder = renderOrder;
			this.ctx = ctx;

		}

		close () {

			this.removeFromParent();

			const material = this.materal;

			if ( ! material ) return;

			material.dispose();

			if ( material.texture ) material.texture.dispose();


		}

	}

	class PopupMaterial extends ShaderMaterial {

		constructor ( container, popupImage, rotation, colour ) {

			const cos = Math.cos( rotation );
			const sin = Math.sin( rotation );
			const pixelRatio = window.devicePixelRatio || 1;
			const canvas = popupImage.image;
			const rotationMatrix = new Float32Array( [ cos, sin, -sin, cos ] );

			const viewPort = new Vector2( Math.floor( pixelRatio * container.clientWidth ) / 2, Math.floor( pixelRatio * container.clientHeight ) / 2 );
			const scale = new Vector2( canvas.width, canvas.height ).divide( viewPort );

			colour = colour || [ 1, 1, 1 ];

			super( {
				vertexShader: Shaders.popupVertexShader,
				fragmentShader: Shaders.popupFragmentShader,
				type: 'CV.PopupMaterial',
				uniforms: {
					rotate: { value: rotationMatrix },
					popupImage: { value: popupImage },
					scale: { value: scale },
					viewPort: { value: viewPort }
				},
				defines: {
					USE_COLOR: true
				}
			} );

			this.opacity = 1.0;
			this.alphaTest = 0.8;
			this.depthTest = false;
			this.transparent = true;

			this.texture = popupImage;

			this.defaultAttributeValues.color = colour;

		}

	}

	class CanvasPopup extends Popup {

		constructor ( ctx, renderOrder = 10000 ) {

			super( ctx, renderOrder );

			this.lines = [];
			this.type = 'CanvasPopup';

			return this;

		}

		i18n ( text ) {

			const tr = this.ctx.cfg.i18n( 'popup.' + text );

			return ( tr === undefined ) ? text : tr;

		}

		formatName ( name ) {

			let long = false;

			// reduce name length if too long

			while ( name.length > 20 ) {

				const tmp = name.split( '.' );
				tmp.shift();

				name = tmp.join( '.' );
				long = true;

			}

			if ( long ) name = '...' + name;

			return name;

		}

		addLine ( line ) {

			this.lines.push( line );

			return this;

		}

		addValue ( text, value ) {

			const n = isNaN( value ) ? value : `${Math.round(value)}\u202fm`;
			this.addLine( this.i18n( text ) + ': ' + n );

		}

		finish ( position ) {

			const cfg = this.ctx.cfg;
			const container = this.ctx.container;
			const cellSize = 32;
			const fontSize = 20;

			const lines = this.lines;
			const lineCount = lines.length;

			const popupWidth = 256;
			const popupHeight = cellSize * lineCount;

			const canvas = document.createElement( 'canvas' );

			if ( ! canvas ) console.error( 'creating canvas for CanvasPopup failed' );

			canvas.width  = popupWidth;
			canvas.height = popupHeight;

			const ctx = canvas.getContext( '2d' );

			if ( ! ctx ) console.error( 'cannot obtain 2D canvas' );

			// set background

			ctx.fillStyle = cfg.themeColorCSS( 'popup.background' );
			ctx.fillRect( 0, 0, popupWidth, popupHeight );

			ctx.strokeStyle = cfg.themeColorCSS( 'popup.border' );
			ctx.lineWidth = 2.0;
			ctx.strokeRect( 0, 0, popupWidth, popupHeight );

			// write text contents

			ctx.textAlign = 'left';
			ctx.font = fontSize + 'px normal helvetica,sans-serif';
			ctx.fillStyle = cfg.themeColorCSS( 'popup.text' );

			for ( let i = 0; i < lineCount; i++ ) {

				ctx.fillText( lines[ i ], 10, cellSize * ( i + 1 ) - 6 );

			}

			const texture = new CanvasTexture( canvas );

			texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

			this.material = new PopupMaterial( container, texture, 0 );
			this.material.needsUpdate = true;

			this.position.copy( position );

			return this;

		}

	}

	class StationPopup extends CanvasPopup {

		constructor ( ctx, pStation, survey, formatter, showDistance, warnings ) {

			super( ctx );

			const position = pStation.coordinates();
			const depth = pStation.depth();

			let lines = null;

			this.addLine( this.formatName( pStation.name() ) );

			if ( pStation.isLinked() ) {

				pStation.linkedStations().forEach( station => {

					this.addLine( ` (${this.formatName( station.name() )})` );

				} );

			}

			let distance;

			if ( showDistance ) {

				distance = pStation.shortestPathDistance();
				distance = distance !== Infinity ? Math.round( distance ) : 'unconnected';

			} else {

				distance = null;

			}

			if ( warnings ) {

				const message = pStation.message();

				if ( message !== undefined ) this.addLine( message );

			} else {

				if ( formatter !== undefined ) {

					lines = formatter( survey.CRS, position, depth, distance );

				}

				if ( lines !== null ) {

					for ( let i = 0; i < lines.length; i++ ) {

						this.addLine( lines[ i ] );

					}

				} else {

					this.addLine( 'x: ' + Math.round( position.x ) + '\u202fm, y: ' + Math.round( position.y ) + '\u202fm' ).addValue( 'z', position.z );

					if ( depth !== null ) {

						this.addValue( 'depth_from_surface', + depth );

						if ( survey.terrain.datumShift !== 0 ) {

							this.addValue( 'adjusted_depth', depth - survey.terrain.datumShift );

						}

					}

					if ( showDistance ) {

						this.addValue( 'distance', distance );

					}

				}

			}

			this.finish( pStation.station );

		}

	}

	const __v1$1 = new Vector3();
	const __v2$1 = new Vector3();

	class StationDistancePopup extends CanvasPopup {

		constructor ( ctx, survey, startStation, endStation ) {

			super( ctx, 20000 );

			this.addLine( this.formatName( startStation.getPath() ) );
			this.addLine( this.formatName( endStation.getPath() ) );

			const p1 = survey.getGeographicalPosition( startStation, __v1$1 );
			const p2 = survey.getGeographicalPosition( endStation, __v2$1 );

			p1.sub( p2 );

			this.addValue( ' dx', Math.abs( p1.x ) );
			this.addValue( ' dy', Math.abs( p1.y ) );
			this.addValue( ' dz', Math.abs( p1.z ) );

			this.addValue( 'distance', p1.length() );

			this.finish( endStation );

			const geometry = new LineSegmentsGeometry();

			geometry.setPositions( [
				startStation.x, startStation.y, startStation.z,
				endStation.x, endStation.y, endStation.z
			] );

			this.line = new LineSegments2( geometry, ctx.materials.getLine2Material( { color: 'white' } ) );
			this.station = startStation;

			survey.addStatic( this.line );

		}

		close () {

			super.close();
			this.line.removeFromParent();

		}

	}

	const __v0$1 = new Vector3();

	class SegmentPopup extends CanvasPopup {

		constructor ( ctx, leg ) {

			super( ctx );

			const segment = leg.segment();

			this.addValue( 'leg_length', leg.length() );
			this.addValue( 'segment_length', segment.length() );
			this.addValue( 'direct_length', segment.directDistance() );

			// midpoint of line segment
			this.finish( __v0$1.copy( leg.startStation.station ).add( leg.endStation.station ).divideScalar( 2 ) );

		}

	}

	class ImagePopup extends Popup {

		constructor ( ctx, station, imageUrl, callback ) {

			super( ctx );

			this.type = 'ImagePopup';

			const texture = new TextureLoader().load( imageUrl, ( texture ) => {

				this.material = new PopupMaterial( ctx.container, texture, 0 );
				this.material.needsUpdate = true;

				callback();

			} );

			texture.onUpdate = function _dropCanvas ( texture ) { texture.image = null; };

			this.position.copy( station );

		}

	}

	class StationNameLabel extends GlyphString {

		constructor ( ctx, station ) {

			const material = ctx.materials.getLabelMaterial( 'stations.default' );

			super( station.getPath(), material, ctx );

			this.station = station;
			this.layers.enable( FEATURE_SURVEY );
			this.position.copy( station );

		}

		close () {

			this.removeFromParent();

		}

	}

	class PointerControls extends EventDispatcher {

		constructor ( ctx, domElement ) {

			super();

			const viewer = ctx.viewer;
			const controls = viewer.getControls();
			const container = ctx.container;
			const cameraMove = viewer.cameraMove; // FIXME temp

			const raycaster = new Raycaster();

			raycaster.layers.enableAll();

			const formatters = {};

			let publicFactory = null;

			const mouseUpEvent = { type: 'select', node: null };

			let lastMouseMode = MOUSE_MODE_NORMAL;
			let mouseMode = MOUSE_MODE_NORMAL;
			let mouseTargets = [];
			let clickCount = 0;

			let survey = null;
			let popup = null;

			const self = this;

			let mouseUpFunction = null;

			let hoverLabel = null;
			let showStationNameLabel = false;
			let lastStationNameLabel = false;

			let showStationDistances = false;
			let startStation = null;
			let lastPointerOver = 0;
			let activePointerId = null;

			// event handler

			viewer.addEventListener( 'newSurvey', e => {

				survey = e.survey;
				publicFactory = e.publicFactory;

				mouseTargets = survey.pointTargets;

				container.addEventListener( 'pointerdown', onPointerDown, false );

			} );

			viewer.addEventListener( 'clear', () => {

				survey = null;
				mouseTargets = [];
				mouseMode = MOUSE_MODE_NORMAL;

				container.removeEventListener( 'pointerdown', onPointerDown );

			} );

			viewer.addEventListener( 'dispose', () => {

				document.rmeoveEventListener( 'keyup', endDistanceMode );

				container.removeEventListener( 'pointerup', pointerUp );
				container.removeEventListener( 'pointerdown', onPointerDown );
				container.removeEventListener( 'pointermove', onPointerMove );

			} );

			viewer.addEventListener( 'change', e => {

				if ( e.name !== 'shadingMode' ) return;

				const shadingMode = e.value;

				if ( shadingMode === SHADING_DISTANCE ) {

					if ( mouseMode !== MOUSE_MODE_DISTANCE ) {

						lastMouseMode = mouseMode;
						mouseMode = MOUSE_MODE_DISTANCE;
						mouseTargets = survey.pointTargets;

					}

				} else {

					mouseMode = lastMouseMode;

				}

			} );

			this.setEditMode = function ( x ) {

				mouseMode = Number( x  );
				lastMouseMode = mouseMode;

				clickCount = 0;
				survey.markers.clear();
				survey.selectSection( survey.surveyTree );

				viewer.renderView();

				raycaster.params.Points.threshold = 3;

				switch ( mouseMode ) {

				case MOUSE_MODE_TRACE_EDIT:

					mouseTargets = survey.pointTargets.concat( [ survey.dyeTraces ] );

					break;

				case MOUSE_MODE_NORMAL:

					mouseTargets = survey.pointTargets;

					break;

				case MOUSE_MODE_ROUTE_EDIT:

					mouseTargets = survey.legTargets;

					break;

				case MOUSE_MODE_ENTRANCES:

					mouseTargets = survey.entranceTargets;
					raycaster.params.Points.threshold = 15;

					break;

				default:

					console.warn( 'invalid mouse mode', x );

				}

			};

			this.getEditMode = function () {

				return mouseMode;

			};

			function showStationImagePopup ( station, imageUrl ) {

				if ( popup !== null ) return;

				popup = new ImagePopup( ctx, station, imageUrl, () => viewer.renderView() );
				survey.addStatic( popup );

				viewer.renderView();

			}

			function showStationPopup ( pStation ) {

				if ( popup !== null ) return;

				popup = new StationPopup( ctx, pStation, survey, formatters.station, ( survey.caveShading === SHADING_DISTANCE ), self.warnings );
				survey.addStatic( popup );

				viewer.renderView();

			}

			function showSegmentPopup ( leg, point ) {

				if ( popup !== null ) return;

				popup = new SegmentPopup( ctx, leg, point );
				survey.addStatic( popup );

				viewer.renderView();

			}

			this.setPopup = function ( station ) {

				closePopup();

				if ( station.isStation() ) showStationPopup( publicFactory.getStation( station ) );

			};

			function closePopup () {

				if ( popup === null ) return;

				popup.close();
				popup = null;

			}

			function endDistanceMode ( event ) {

				if ( event.key != 'Shift' ) return;

				// cancel showStation mode

				showStationDistances = false;

				closePopup();
				self.setStationNameLabelMode( lastStationNameLabel );
				controls.enabled = true;

				document.removeEventListener( 'keyup', endDistanceMode );

			}

			function showStationPopupX ( station, event ) {

				if ( event.shiftKey && ! showStationDistances ) {

					lastStationNameLabel = showStationNameLabel;
					showStationDistances = true;
					startStation = station.station;

					self.setStationNameLabelMode( true );
					controls.enabled = false;

					document.addEventListener( 'keyup', endDistanceMode );

				} else {

					showStationPopup( station );

				}

				mouseUpFunction = closePopup;

				cameraMove.preparePoint( survey.getWorldPosition( station.station.clone() ) );

			}

			function pointerUp ( event ) {

				container.removeEventListener( 'pointerup', pointerUp );

				// trap for event that shouldn't happen
				if ( event.pointerId !== activePointerId ) console.warn( 'wrong pointer up' );

				activePointerId = null;

				if ( mouseUpFunction ) mouseUpFunction();

				viewer.renderView();

				viewer.dispatchEvent( mouseUpEvent );

			}

			function filterConnectedLegs ( event ) {

				if ( event.filterConnected ) {

					survey.setShadingMode( survey.caveShading, true );
					viewer.renderView();

				}

			}

			this.getStationNameLabelMode = function () {

				return showStationNameLabel;

			};

			this.setStationNameLabelMode = function ( mode ) {

				if ( mode ) {

					container.addEventListener( 'pointermove', onPointerMove );


				} else {

					if ( hoverLabel !== null ) {

						hoverLabel.close();
						hoverLabel = null;
						viewer.renderView();

					}

					container.removeEventListener( 'pointermove', onPointerMove );

				}

				showStationNameLabel = mode;

			};

			function checkLegIntersects ( event ) {

				const legs = survey.features.get( LEG_CAVE );
				const legIntersect = raycaster.intersectObject( legs, false )[ 0 ];

				let legIndex = null;
				let segment = null;

				if  ( legIntersect ) {

					legIndex = legIntersect.faceIndex;

					const legInfo = legs.getLegInfo( legIndex );
					const leg = publicFactory.getLeg( legInfo );

					segment = legInfo.segment;

					const e = {
						type: 'leg',
						leg: leg,
						handled: false,
						highlight: false,
						mouseEvent: event
					};

					viewer.dispatchEvent( e );

					if ( e.highlight ) {

						mouseUpFunction = _setLegHighlight;

						_setLegHighlight();
						viewer.renderView();

					}

					if ( ! e.handled ) {

						mouseUpFunction = _setSegmentHighlight;

						_setSegmentHighlight();
						showSegmentPopup( leg );
						viewer.renderView();

					}

					legIndex = null;
					segment = null;

				}

				function _setLegHighlight () {

					legs.setHighlightLeg( legIndex );
					viewer.shadingMode = survey.caveShading;

				}

				function _setSegmentHighlight () {

					legs.setHighlightSegment( segment );
					viewer.shadingMode = survey.caveShading;
					if ( segment === null ) closePopup();

				}

			}

			function selectStation ( station, event ) {

				survey.selectStation( station );

				const pStation = publicFactory.getStation( station );

				const selectEvent = {
					type: 'station',
					node: pStation,
					handled: false,
					mouseEvent: event,
					filterConnected: false
				};

				viewer.dispatchEvent( selectEvent );

				filterConnectedLegs( selectEvent );

				if ( selectEvent.handled ) return;

				if ( event.button === MOUSE.LEFT ) {

					showStationPopupX( pStation, event );

					if ( viewer.shadingMode === SHADING_CURSOR ) viewer.cursorHeight = station.z;

				} else if ( event.button === MOUSE.RIGHT ) {

					if ( ! survey.selection.contains( station.id ) ) {

						survey.selectSection( survey.surveyTree );

					}

					viewer.selectSection( station );

					cameraMove.start( true );
					event.stopPropagation();

					mouseUpFunction = null;

				}

			}

			function onPointerMove( event ) {

				if ( event.target !== domElement ) return;

				viewer.setRaycaster( raycaster, viewer.getMouse( event.clientX, event.clientY ) );

				const hit = raycaster.intersectObjects( mouseTargets, false )[ 0 ];

				if ( hit === undefined ) {

					setTimeout( () => {

						if ( hoverLabel !== null && performance.now() - lastPointerOver > 250 ) {

							hoverLabel.close();
							hoverLabel = null;

							viewer.renderView();

						}

						return;

					}, 500 );

					return;

				}

				const station = hit.station;

				if ( hoverLabel !== null && hoverLabel.station !== station ) {

					hoverLabel.close();
					hoverLabel = null;

				}

				if ( hoverLabel === null ) {

					if ( showStationDistances ) {

						hoverLabel = new StationDistancePopup( ctx, survey, startStation, station );

					} else {

						hoverLabel = new StationNameLabel( ctx, station );

					}

					survey.addStatic( hoverLabel );

				}

				lastPointerOver = performance.now();

				viewer.renderView();

			}

			function onPointerDown ( event ) {

				if ( activePointerId !== null || event.target !== domElement ) return;

				viewer.setRaycaster( raycaster, viewer.getMouse( event.clientX, event.clientY ) );

				container.addEventListener( 'pointerup', pointerUp );

				activePointerId = event.pointerId;

				if ( event.altKey ) {

					checkLegIntersects( event );
					return;

				}

				if ( self.entrances ) {

					const entrance = raycaster.intersectObjects( survey.entrances.labels, false )[ 0 ];

					if ( entrance !== undefined ) {

						const station = survey.surveyTree.findById( entrance.object.stationID );

						const e = {
							type: 'entrance',
							displayName: entrance.name,
							station: publicFactory.getStation( station ),
							filterConnected: false,
							handled: false,
							mouseEvent: event
						};

						viewer.dispatchEvent( e );

						filterConnectedLegs( e );

						if ( ! e.handled ) {

							selectStation( station, event );

						}

						return;

					}

				}

				const hit = raycaster.intersectObjects( mouseTargets, false )[ 0 ];

				switch ( mouseMode ) {

				case MOUSE_MODE_NORMAL:

					if ( hit === undefined ) break;
					selectStation( hit.station, event );

					break;

				case MOUSE_MODE_ROUTE_EDIT:

					if ( hit === undefined ) break;
					selectSegment( hit );

					break;

				case MOUSE_MODE_DISTANCE:

					selectDistance( hit, event );

					break;

				case MOUSE_MODE_TRACE_EDIT:

					if ( event.button === MOUSE.LEFT && hit ) {

						if ( hit.station ) {

							selectTraceStation( hit.station );

						} else {

							selectTrace( hit );

						}

					}

					break;

				}

			}

			function selectDistance ( hit, event ) {

				if ( ! hit ) {

					if ( event.button === MOUSE.RIGHT ) {

						// default distance shading
						survey.maxDistance = 0;
						viewer.shadingMode = SHADING_DISTANCE;

					}

					return;

				}

				const station = hit.station;

				if ( event.button === MOUSE.LEFT ) {

					survey.showShortestPath( station );

					showStationPopupX( publicFactory.getStation( station ), event );

				} else if ( event.button === MOUSE.RIGHT ) {

					survey.setShortestPaths( station );

					viewer.dispatchEvent( { type: 'change', name: 'shadingMode' } );
					viewer.renderView();

				}

			}

			function selectSegment ( picked ) {

				survey.getRoutes().toggleSegment( picked.index );

				viewer.setShadingMode( SHADING_PATH );

				viewer.renderView();

			}

			function selectTrace ( hit ) {

				const dyeTraces = survey.dyeTraces;
				const traceIndex = hit.faceIndex;

				survey.markers.clear();

				dyeTraces.outlineTrace( traceIndex );

				viewer.dispatchEvent( {
					type: 'selectedTrace',
					trace: dyeTraces.getTraceStations( traceIndex ),
					delete: function _deleteTrace () {
						dyeTraces.deleteTrace( traceIndex );
						viewer.renderView();
					}
				} );

				viewer.renderView();

			}

			function selectTraceStation ( station ) {

				const dyeTraces = survey.dyeTraces;
				const markers = survey.markers;

				dyeTraces.outlineTrace( null );

				if ( ++clickCount === 3 ) {

					markers.clear();
					clickCount = 1;

				}

				markers.mark( station );

				const list = markers.getStations();

				let start, end;

				if ( list[ 0 ] !== undefined ) start = list[ 0 ].getPath();
				if ( list[ 1 ] !== undefined ) end = list[ 1 ].getPath();

				viewer.dispatchEvent( {
					type: 'selectedTrace',
					start: start,
					end: end,
					add: function () {
						if ( list.length !== 2 ) return;

						dyeTraces.addTrace( list[ 0 ], list[ 1 ] );

						markers.clear();
						viewer.renderView();

					}
				} );

				viewer.renderView();

			}

			this.selectTraceStation = selectTraceStation;

			this.showImagePopup = function ( event, imageUrl ) {

				showStationImagePopup( event.node, imageUrl );
				mouseUpFunction = closePopup;

			};

		}

	}

	class Station {

		constructor ( factory, station ) {

			const survey = factory.survey;
			this.survey = survey;
			this.station = station;
			this.legs = survey.getFeature( LEG_CAVE );
			this.factory = factory;
		}

		id () {

			return this.station.id;

		}

		name () {

			return this.station.getPath();

		}

		coordinates () {

			return this.survey.getGeographicalPosition( this.station );

		}

		depth () {

			const terrain = this.survey.terrain;
			return ( terrain ) ? this.station.z - terrain.getHeight( this.station ) : null;

		}

		connectionCount () {

			return this.station.connections;

		}

		isEntrance () {

			return  ( this.station.type & STATION_ENTRANCE  ) === STATION_ENTRANCE;

		}

		adjacentStationIds () {

			return this.legs.getAdjacentStations( this.station ).slice();

		}

		shortestPathDistance () {

			return this.station.shortestPath;

		}

		message () {

			return this.station.messageText;

		}

		isLinked () {

			return ( this.station.next !== null );

		}

		linkedStations () {

			const linked = [];
			const station = this.station;
			let next = station.next;

			while ( next && next !== station ) {

				linked.push( this.factory.getStation( next ) );
				next = next.next;

			}

			return linked;

		}

		forEachConnectedLeg ( callback ) {

			const survey = this.survey;
			const legs = this.legs;
			const factory = this.factory;

			survey.stations.resetPaths();

			legs.setShortestPaths( this.station, ( legInfo ) =>
				callback( factory.getLeg( legInfo ) )
			);

		}

	}

	class Leg {

		constructor ( factory, legInfo, s1, s2 ) {

			const s1Start = ( s1.shortestPathDistance() < s2.shortestPathDistance() );
			const survey = factory.survey;

			this.factory = factory;
			this.legLength = legInfo.length;
			this.index = legInfo.index;
			this.segmentId = legInfo.segment;
			this.startStation = s1Start ? s1 : s2;
			this.endStation = s1Start ? s2 : s1;
			this.legs = survey.getFeature( LEG_CAVE );

		}

		start () {

			return this.startStation;

		}

		end () {

			return this.endStation;
		}

		length () {

			return this.legLength;

		}

		color ( color = false ) {

			this.legs.setLegColor( this.index * 2, color );

		}

		segment () {

			return this.factory.getSegment( this.segmentId );

		}

	}

	class Segment {

		constructor ( segmentInfo, start, end ) {

			this.segmentLength = segmentInfo.length;
			this.startStation = start;
			this.endStation = end;
			this.direct = null;

		}

		length () {

			return this.segmentLength;

		}

		directDistance () {

			if ( this.direct === null ) {

				this.direct =  this.startStation.coordinates().distanceTo( this.endStation.coordinates() );

			}

			return this.direct;

		}

	}

	class PublicFactory {

		survey = null;
		stationCache = new WeakMap();
		segmentCache = [];
		legCache = new WeakMap();

		constructor ( survey ) {

			this.survey = survey;

		}

		getStation ( station ) {

			let s = this.stationCache.get( station );

			if ( s == undefined ) {

				s = new Station( this, station );
				this.stationCache.set( station, s );

			}

			return s;

		}

		getLeg ( legInfo ) {

			let leg = this.legCache.get( legInfo );

			if ( leg === undefined ) {

				leg = new Leg( this, legInfo, this.getStation( legInfo.start ), this.getStation( legInfo.end ) );
				this.legCache.set( legInfo, leg );

			}

			return leg;

		}

		getSegment ( segmentIndex ) {

			const survey = this.survey;

			let segment = this.segmentCache[ segmentIndex ];

			if ( segment === undefined ) {

				const segmentInfo = survey.segments.getSegmentInfo( segmentIndex );

				segment = new Segment( segmentInfo, this.getStation( segmentInfo.startStation ), this.getStation( segmentInfo.endStation ) );
				this.segmentCache[ segmentIndex ] = segment;

			}

			return segment;

		}

	}

	class RenderUtils {

		constructor () {}

		renderTargetToCanvas ( renderer, renderTarget ) {

			const width = Math.floor( renderTarget.width );
			const height = Math.floor( renderTarget.height );

			const bSize = width * height * 4;
			const buffer = new Uint8ClampedArray( bSize );

			renderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, buffer );

			// invert image
			const line = width * 4;
			const invertedBuffer = new Uint8ClampedArray( bSize );

			let dst = bSize;
			let end = 0;

			for ( let i = 0; i < bSize; i += line ) {

				dst -= line;
				end += line;

				invertedBuffer.set( buffer.subarray( i, end ), dst );

			}

			const id = new ImageData( invertedBuffer, width, height );

			const canvas = document.createElement( 'canvas' );
			const canvasCtx = canvas.getContext( '2d' );

			canvas.width = width;
			canvas.height = height;

			canvasCtx.putImageData( id, 0, 0 );

			return canvas;

		}

		makePlanCamera ( container, survey ) {

			let width  = container.clientWidth;
			let height = container.clientHeight;

			const range = survey.combinedLimits.getSize( new Vector3() );

			const scaleX = width / range.x;
			const scaleY = height / range.y;

			if ( scaleX < scaleY ) {

				height = height * scaleX / scaleY;

			} else {

				width = width * scaleY / scaleX;

			}

			return new OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, -10000, 10000 );

		}

		makeRenderTarget ( width, height ) {

			const renderTarget = new WebGLRenderTarget( width, height, { depthBuffer: false, stencilBuffer: false, minFilter: NearestFilter, magFilter: NearestFilter } );

			renderTarget.texture.generateMipmaps = false;
			return renderTarget;

		}

		makeTextureLookup ( renderer, renderTarget, boundingBox ) {

			return new TextureLookup( renderer, renderTarget, boundingBox );

		}

	}

	class Snapshot {

		constructor ( ctx, renderer ) {

			this.getSnapshot = function ( exportSize, lineScale ) {

				const container = ctx.container;
				const viewer = ctx.viewer;

				const newWidth = exportSize;
				const newHeight = Math.round( container.clientHeight * newWidth / container.clientWidth );

				const renderTarget = new WebGLRenderTarget( newWidth, newHeight, { minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat, stencilBuffer: true } );

				renderTarget.texture.generateMipmaps = false;
				renderTarget.texture.name = 'CV.snapshot';

				renderer.setSize( newWidth, newHeight );
				renderer.setPixelRatio( 1 );
				renderer.setRenderTarget( renderTarget );
				renderer.setClearAlpha( 1.0 );

				// reset camera and materials using renderer size/resolution
				viewer.dispatchEvent( { type: 'resized', name: 'rts', 'width': newWidth, 'height': newHeight, lineScale: lineScale } );

				viewer.renderView();

				const canvas = ctx.renderUtils.renderTargetToCanvas( renderer, renderTarget );

				renderTarget.dispose();

				// restore renderer to normal render size and target
				viewer.resetRenderer();

				return canvas.toDataURL();

			};

		}

	}

	class Walls extends Mesh {

		ready = true;
		flat = false;
		flatGeometry = null;
		indexedGeometry = null;

		constructor ( ctx ) {

			const geometry = new BufferGeometry();

			super( geometry, ctx.materials.getUnselectedWallMaterial() );

			this.ctx = ctx;
			this.type = 'Walls';

		}

		addWalls ( vertices, indices, indexRuns ) {

			const geometry = this.geometry;
			const positions = new Float32BufferAttribute( vertices.length * 3, 3 );

			geometry.setAttribute( 'position', positions.copyVector3sArray( vertices ) );

			geometry.setIndex( indices );

			geometry.computeVertexNormals();
			geometry.computeBoundingBox();

			this.indexRuns = indexRuns;

			return this;

		}

		setShading ( idSet, selectedMaterial ) {

			const geometry = this.geometry;
			const indexRuns = this.indexRuns;
			const materials = this.ctx.materials;

			geometry.clearGroups();

			this.visible = this.ready;

			if ( idSet.length > 0 && indexRuns ) {

				this.material = [ selectedMaterial, materials.getUnselectedWallMaterial() ];

				let indexRun = indexRuns[ 0 ];

				let start = indexRun.start;
				let count = indexRun.count;

				let currentMaterial;
				let lastMaterial = idSet.has( indexRun.survey ) ? 0 : 1;

				// merge adjacent runs with shared material.

				for ( let run = 1, l = indexRuns.length; run < l; run++ ) {

					indexRun = indexRuns[ run ];

					currentMaterial = idSet.has( indexRun.survey ) ? 0 : 1;

					if ( currentMaterial === lastMaterial && indexRun.start === start + count ) {

						count += indexRun.count;

					} else {

						geometry.addGroup( start, count, lastMaterial );

						start = indexRun.start;
						count = indexRun.count;

						lastMaterial = currentMaterial;

					}

				}

				geometry.addGroup( start, count, lastMaterial );

			} else {

				this.material = selectedMaterial;

			}

		}

		cutRuns ( survey, selection ) {

			const wasFlat = this.flat;

			this.setFlat( false );

			if ( this.flatGeometry ) {

				this.flatGeometry.dispose();
				this.flatGeometry = null;

			}

			const geometry = this.geometry;

			const vertices = geometry.getAttribute( 'position' );
			const indices = geometry.index;

			const idSet = selection.getIds();
			const indexRuns = this.indexRuns;

			const newIndices = [];
			const newVertices = [];

			const newIndexRuns = [];

			// map old vertex index values to new index values
			const vMap = new Map();

			const l = indexRuns.length;

			let run, newVertexIndex = 0, fp = 0;

			for ( run = 0; run < l; run++ ) {

				const indexRun = indexRuns[ run ];

				if ( idSet.has( indexRun.survey ) ) {

					const start = indexRun.start;
					const count = indexRun.count;

					const end = start + count;

					const itemSize = vertices.itemSize;
					const oldVertices = vertices.array;

					for ( let i = start; i < end; i++ ) {

						const index = indices.getX( i );

						let newIndex = vMap.get( index );

						if ( newIndex === undefined ) {

							const offset = index * itemSize;

							newIndex = newVertexIndex++;

							vMap.set( index, newIndex );

							newVertices.push( oldVertices[ offset ], oldVertices[ offset + 1 ], oldVertices[ offset + 2 ] );

						}

						newIndices.push( newIndex );

					}

					indexRun.start = fp;

					fp += count;

					newIndexRuns.push( indexRun );

				}

			}

			if ( newIndices.length === 0 ) return false;

			// replace position and index attributes - dispose of old attributes
			geometry.index = new indices.constructor( newIndices );
			geometry.setAttribute( 'position', new Float32BufferAttribute( newVertices, 3 ) );

			geometry.computeVertexNormals();
			geometry.computeBoundingBox();

			this.indexRuns = newIndexRuns;

			this.setFlat( wasFlat );

			return true;

		}

		setFlat ( flat ) {

			if ( flat === this.flat ) return;

			const geometry = this.geometry;
			let flatGeometry = this.flatGeometry;

			if ( flat ) {

				if ( flatGeometry === null ) {

					flatGeometry = geometry.toNonIndexed();

					flatGeometry.computeVertexNormals();
					flatGeometry.computeBoundingBox();

				}

				this.indexedGeometry = geometry;
				this.geometry = flatGeometry;

				this.dropBuffers();

			} else {

				this.flatGeometry = geometry;
				this.geometry = this.indexedGeometry;

			}

			this.flat = flat;

		}

	}

	function buildScraps ( cave, survey ) {

		const scrapList = cave.scraps;
		const l = scrapList.length;

		if ( l === 0 ) return null;

		const mesh = survey.addFeature( new Walls( survey.ctx ), FACE_SCRAPS, 'Scraps' );

		const indices = [];
		const vertices = [];

		const indexRuns = [];

		let vertexOffset = 0;
		let lastEnd = 0;

		for ( let i = 0; i < l; i++ ) {

			_loadScrap( scrapList[ i ] );

		}

		mesh.addWalls( vertices, indices, indexRuns );

		survey.addFeature( mesh, FACE_SCRAPS, 'CV.Survey:faces:scraps' );

		return;

		function _loadScrap ( scrap ) {

			let i, l;

			for ( i = 0, l = scrap.vertices.length; i < l; i++ ) {

				vertices.push( scrap.vertices[ i ] );

			}

			for ( i = 0, l = scrap.faces.length; i < l; i++ ) {

				const face = scrap.faces[ i ];

				indices.push( face[ 0 ] + vertexOffset, face[ 2 ] + vertexOffset, face[ 1 ] + vertexOffset );

			}

			const end = indices.length;

			indexRuns.push( { start: lastEnd, count: end - lastEnd, survey: scrap.survey } );
			lastEnd = end;

			vertexOffset += scrap.vertices.length;

		}

	}

	function buildCrossSections ( cave, survey ) {

		const crossSectionGroups = cave.crossSections;
		const legs = survey.getLegs();
		const ctx = survey.ctx;

		const vSectMap = new Map();
		const fixupXsects = ctx.cfg.value( 'fixup_xsects', true );

		// map stations to XSECT
		crossSectionGroups.forEach( group => {
			group.forEach( section => {
				vSectMap.set( section.end, section );
			} );
		} );

		// handle no LRUD sections
		if ( crossSectionGroups.length === 0 ) return;

		const warnings = [];
		const mesh = survey.addFeature( new Walls( ctx ), FACE_WALLS, 'Walls' );

		const indices = [];
		const vertices = [];

		const l = crossSectionGroups.length;

		// survey to face index mapping
		const indexRuns = [];
		const upAxis = Object3D.DefaultUp;

		let currentSurvey;

		let v = 0;

		let lastEnd = 0;
		let l1, r1, u1, d1, l2, r2, u2, d2;
		let ul1, ur1, dl1, dr1, ul2, ur2, dl2, dr2;

		const cross = new Vector3();
		const lastCross = new Vector3();
		const nextCross = new Vector3();

		let run = null;

		let vertexCount; // number of vertices per section

		for ( let i = 0; i < l; i++ ) {

			const crossSectionGroup = crossSectionGroups[ i ];

			if ( crossSectionGroup.length < 2 ) continue;

			if ( crossSectionGroup[ 0 ].start === null ) {

				// no approach vector
				_fixupGroupStart( crossSectionGroup );

			}

			if ( fixupXsects ) _fixupGroupEnd( crossSectionGroup );

			// enter first station vertices
			const m = crossSectionGroup.length;

			vertexCount = _getLRUD( crossSectionGroup[ 0 ], crossSectionGroup[ 1 ] );

			for ( let j = 1; j < m; j++ ) {

				const xSect = crossSectionGroup[ j ];
				const survey = xSect.survey;

				vertexCount = _getLRUD( xSect, crossSectionGroup[ j + 1 ] );

				if ( survey !== currentSurvey ) {

					currentSurvey = survey;

					if ( run !== null ) {

						_endCap();

						lastEnd = indices.length;

						run.count = lastEnd - run.start;

						indexRuns.push( run );

						run = null;

					}

				}

				// next station vertices

				// triangles to form passage box
				l1 = v++;
				r1 = v++;
				u1 = v++;
				d1 = v++;

				if ( vertexCount === 8 ) {

					ul1 = v++;
					dr1 = v++;
					ur1 = v++;
					dl1 = v++;

				} else {

					ul1 = l1;
					dr1 = r1;
					ur1 = r1;
					dl1 = l1;

				}

				l2 = v++;
				r2 = v++;
				u2 = v++;
				d2 = v++;

				if ( vertexCount === 8 ) {

					ul2 = v++;
					dr2 = v++;
					ur2 = v++;
					dl2 = v++;

				} else {

					ul2 = l1;
					dr2 = r1;
					ur2 = r1;
					dl2 = l1;

				}

				// all face vertices specified in CCW winding order to define front side.

				if ( vertexCount === 4 ) {

					// top faces
					indices.push( u1, r1, r2 );
					indices.push( u1, r2, u2 );
					indices.push( u1, u2, l2 );
					indices.push( u1, l2, l1 );

					// bottom faces
					indices.push( d1, r2, r1 );
					indices.push( d1, d2, r2 );
					indices.push( d1, l2, d2 );
					indices.push( d1, l1, l2 );

				} else {

					// top faces - top half
					indices.push( u1, ur1, ur2 );
					indices.push( u1, ur2, u2 );
					indices.push( u1, u2,  ul2 );
					indices.push( u1, ul2, ul1 );

					// top faces - bottom half
					indices.push( ur1, r1, r2 );
					indices.push( ur1, r2, ur2 );
					indices.push( ul1, ul2, l2 );
					indices.push( ul1, l2, l1 );

					// bottom faces - top half
					indices.push( dr1, r2,  r1 );
					indices.push( dr1, dr2, r2 );
					indices.push( dl1, l2, dl2 );
					indices.push( dl1, l1, l2 );

					// bottom faces - bottom half
					indices.push( d1, dr2, dr1 );
					indices.push( d1, d2,  dr2 );
					indices.push( d1, dl2, d2 );
					indices.push( d1, dl1, dl2 );

				}

				v = v - vertexCount; // rewind to allow current vertices to be start of next box section.

				if ( run === null ) {

					// handle first section of run

					run = { start: lastEnd, survey: survey };

					// start tube with two triangles to form cap
					indices.push( u1, d1, r1 );
					indices.push( u1, l1, d1 );

					if ( vertexCount === 8 ) {

						indices.push( u1, ul1, l1 );
						indices.push( u1, r1, ur1 );
						indices.push( d1, l1, dl1 );
						indices.push( d1, dr1, r1 );

					}

				}

			}

			currentSurvey = null;
			v = v + vertexCount; // advance because we are starting a new set of independant x-sections.

		}

		if ( run !== null ) {

			_endCap();

			run.count = indices.length - run.start;

			indexRuns.push( run );

		}

		if ( indices.length === 0 ) return;

		mesh.addWalls( vertices, indices, indexRuns );

		survey.addFeature( mesh, FACE_WALLS, 'CV.Survey:faces:walls' );
		survey.loadWarnings( warnings );

		return;

		function _endCap() {

			// close tube with two triangles
			indices.push( u2, r2, d2 );
			indices.push( u2, d2, l2 );

			if ( vertexCount === 8 ) {

				indices.push( u2, l2, ul2 );
				indices.push( u2, ur2, r2 );
				indices.push( d2, dl2, l2 );
				indices.push( d2, r2, dr2 );

			}

		}

		function _getLRUD ( crossSection, nextSection ) {

			const ovalFactor = 0.293;
			const station = crossSection.end;
			const lrud    = crossSection.lrud;

			let vertexCount;

			// cross product of leg + next leg vector and up AXIS to give direction of LR vector
			cross.subVectors( crossSection.start, crossSection.end ).normalize();

			const vertical = ( Math.abs( cross.dot( upAxis ) ) > 0.97 );

			if ( nextSection ) {

				nextCross.subVectors( nextSection.start, nextSection.end ).normalize();
				cross.add( nextCross );

			}

			cross.cross( upAxis );

			let U, D, UL, UR, DL, DR;

			if ( vertical && ( lrud.u + lrud.d < 5 ) ) {

				cross.copy( lastCross );
				const t = cross.clone().cross( upAxis );

				U = t.clone().setLength( -lrud.u ).add( station );
				D = t.clone().setLength( lrud.d ).add( station );

			} else {

				U = new Vector3( station.x, station.y, station.z + lrud.u );
				D = new Vector3( station.x, station.y, station.z - lrud.d );

			}

			const L = cross.clone().setLength(  lrud.l ).add( station );
			const R = cross.clone().setLength( -lrud.r ).add( station );

			lastCross.copy( cross );

			switch ( crossSection.type ) {

			case WALL_DIAMOND:

				vertices.push( L, R, U, D );

				vertexCount = 4; // number of vertices for this profile
				break;

			case WALL_SQUARE:

				UL = L.clone().setZ( U.z );
				UR = R.clone().setZ( U.z );
				DL = L.clone().setZ( D.z );
				DR = R.clone().setZ( D.z );

				vertices.push( UL, DR, UR, DL );

				vertexCount = 4; // number of vertices for this profile
				break;

			case WALL_OVAL:

				vertices.push( L, R, U, D );

				UL = L.clone().setZ( U.z ).lerp( station, ovalFactor );
				UR = R.clone().setZ( U.z ).lerp( station, ovalFactor );
				DL = L.clone().setZ( D.z ).lerp( station, ovalFactor );
				DR = R.clone().setZ( D.z ).lerp( station, ovalFactor );

				vertices.push( UL, DR, UR, DL );

				vertexCount = 8; // number of vertices for this profile
				break;

			default:

				console.error( 'unsupported lrud shape', crossSection.type );

			}

			return vertexCount;

		}

		function _fixupGroupStart( group ) {

			let crossSection = group[ 0 ];
			let nextSection = group[ 1 ];

			if ( fixupXsects ) {

				// fixup start of group - connect other passages if possible
				// no approach vector

				// do we have more than one connected station?
				const connectedPoint = _getConnectedPoint ( crossSection.end, nextSection.end );

				if ( connectedPoint ) {

					crossSection.start = connectedPoint;

					const newXsect = vSectMap.get( connectedPoint );

					if ( newXsect ) {

						// we can add a new xsect to the start
						nextSection = crossSection;

						crossSection = {
							start: null,
							end: connectedPoint,
							lrud: newXsect.lrud,
							type: WALL_SQUARE
						};

						group.unshift( crossSection );

						warnings.push( {
							station: nextSection.start,
							text: 'xSects start extended'
						} );

					}

				}

			}

			// drop through here if no new xsect added or no connected points found
			// reverse next leg for approach vector

			crossSection.start = new Vector3()
				.copy( nextSection.start )
				.multiplyScalar( 2 ).sub( nextSection.end );

		}

		function _fixupGroupEnd( group ) {

			const endSection = group[ group.length - 1 ];
			const connectedPoint = _getConnectedPoint( endSection.end, endSection.start );

			if ( ! connectedPoint ) return;

			const newXsect = vSectMap.get( connectedPoint );

			if ( newXsect === undefined ) return;

			group.push( {
				start: endSection.end,
				end: connectedPoint,
				lrud: newXsect.lrud,
				survey: newXsect.survey,
				type: newXsect.type
			} );

			warnings.push( {
				station: endSection.end,
				text: 'xSects end extended'
			} );

		}

		function _getConnectedPoint ( vertex, excludeVertex ) {

			const nodeLegs = vertex.legs;

			if ( nodeLegs.length === 0 ) return false;

			const connectedPoints = [];

			nodeLegs.forEach( li => {

				// leg index points to first vertex of leg
				const p = ( legs[ li ] !== vertex ) ? legs[ li ] : legs[ li + 1 ];
				if ( p !== excludeVertex ) connectedPoints.push( p );

			} );

			return connectedPoints[ 0 ];

		}

	}

	function buildWallsSync ( cave, survey ) {

		buildScraps( cave, survey );
		buildCrossSections( cave, survey );

	}

	function beforeRender ( renderer, scene, camera, geometry, material ) {

		material.dashOffset += 0.1;

	}

	class DyeTraces extends LineSegments2 {

		constructor ( ctx ) {

			const geometry = new LineSegmentsGeometry();
			const survey = ctx.survey;

			super( geometry, new SurveyLineMaterial( ctx, '', true ) );

			this.metadata = survey.metadata;
			this.vertices = [];
			this.selected = [];
			this.stations = [];


			this.onBeforeRender = beforeRender;
			this.visible = false;

			const traces = survey.metadata.traces;
			const surveyTree = survey.surveyTree;

			traces.forEach( trace => {

				const startStation = surveyTree.getByPath( trace.start );
				const endStation   = surveyTree.getByPath( trace.end );

				if ( endStation === undefined || startStation === undefined ) return;

				this._addTrace( startStation, endStation );

			} );

			this.finish();

		}

		finish () {

			const geometry = this.geometry;

			if ( this.vertices.length === 0 ) return;

			geometry.setPositions( this.vertices );
			geometry.setHide( this.selected );

			this.visible = true;

			// save to browser local storage
			this.metadata.traces = this.serialise();
			this.metadata.saveLocal();

			return this;

		}

		getTraceStations ( hit ) {

			const stations = this.stations;

			return {
				start: stations[ hit * 2 ].getPath(),
				end: stations [ hit * 2 + 1 ].getPath()
			};

		}

		deleteTrace ( hit ) {

			// remove from arrays
			const offset = hit * 2;

			this.stations.splice( offset, 2 );

			this.vertices.splice( offset, 2 );
			this.selected.splice( offset, 2 );

			// rebuild geometry without deleted trace

			this.finish();

		}

		_addTrace ( startStation, endStation ) {

			this.vertices.push(
				startStation.x, startStation.y, startStation.z,
				endStation.x, endStation.y, endStation.z
			);

			this.stations.push( startStation, endStation );
			this.selected.push( 1, 1 );

		}

		addTrace ( startStation, endStation ) {

			this._addTrace( startStation, endStation );
			this.finish();

		}

		outlineTrace ( hit ) {

			if ( ! this.visible ) return;

			const selected = this.selected;

			selected.fill( 0 );

			if ( hit !== null ) {

				let offset = hit * 2;

				selected[ offset++ ] = 1;
				selected[ offset ] = 1;

			}

			this.geometry.setHide( selected );

			return;

		}

		serialise () {

			const stations = this.stations;
			const traces = [];

			for ( let i = 0, l = stations.length; i < l; i += 2 ) {

				traces.push( {
					start: stations[ i ].getPath(),
					end: stations[ i + 1 ].getPath()
				} );

			}

			return traces;

		}

	}

	class Point extends Points {

		type = 'Point';

		constructor ( material, ctx ) {

			const materials = ctx.materials;

			if ( materials.pointGeometry === undefined ) {

				materials.pointGeometry = new BufferGeometry().setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0 ], 3 ) );

			}

			super( materials.pointGeometry, material );

		}

	}

	class Marker extends Point {

		isMarker = true;

		constructor ( ctx, count ) {

			const materials = ctx.materials;

			super( materials.getClusterMaterial( count ), ctx );
			this.renderOrder = 1;

		}

		adjustHeight ( func ) {

			this.position.setZ( func( this.position ) + 10 );

		}

	}

	// preallocated objects for projected area calculation and cluster visibility checks

	const __a$1 = new Vector3();
	const __b$1 = new Vector3();
	const __c$1 = new Vector3();
	const __d$1 = new Vector3();

	const __t1$1 = new Triangle( __a$1, __b$1, __c$1 );
	const __t2$1 = new Triangle( __a$1, __c$1, __d$1 );

	const __plane = new Plane();

	const __v = new Vector3();

	class QuadTree {

		constructor ( ctx, xMin, xMax, yMin, yMax ) {

			this.nodes = new Array( 4 );
			this.count = 0;
			this.markers = [];
			this.quadMarker = null;
			this.centroid = new Vector3();
			this.ctx = ctx;

			this.xMin = xMin;
			this.xMax = xMax;

			this.yMin = yMin;
			this.yMax = yMax;

		}

		addNode ( marker, depth ) {

			// add marker into this quad and recurse to inner quads

			if ( depth-- === 0 ) return;

			const position = marker.position;
			const ctx = this.ctx;

			const xMid = ( this.xMin + this.xMax ) / 2;
			const yMid = ( this.yMin + this.yMax ) / 2;

			this.markers.push( marker );
			this.centroid.add( position );

			this.count++;

			let index = 0;

			if ( position.x > xMid ) index += 1;
			if ( position.y > yMid ) index += 2;

			let subQuad = this.nodes[ index ];

			if ( subQuad === undefined ) {

				switch ( index ) {

				case 0:

					subQuad = new QuadTree( ctx, this.xMin, xMid, this.yMin, yMid );
					break;

				case 1:

					subQuad = new QuadTree( ctx, xMid, this.xMax, this.yMin, yMid );
					break;

				case 2:

					subQuad = new QuadTree( ctx, this.xMin, xMid, yMid, this.yMax );
					break;

				case 3:

					subQuad = new QuadTree( ctx, xMid, this.xMax, yMid, this.yMax );
					break;

				}

				this.nodes[ index ] = subQuad;

			}

			subQuad.addNode( marker, depth );

		}

		check ( cluster, target, angleFactor, selection ) {

			for ( let i = 0; i < 4; i++ ) {

				const subQuad = this.nodes[ i ];

				if ( subQuad !== undefined ) {

					// prune quads that will never be clustered. will not be checked after first pass

					if ( subQuad.count < 2 ) {

						this.nodes[ i ] = undefined;

						continue;

					}

					// test for projected area for quad containing multiple markers

					const area = subQuad.projectedArea( cluster );

					// adjust for inclination to horizontal and distance from camera vs distance between camera and target

					__a$1.subVectors( cluster.camera.position, target );

					const d2Target = __a$1.length() * 2;

					__a$1.normalize();

					__plane.setFromNormalAndCoplanarPoint( __a$1, cluster.camera.position );

					if ( this.quadMarker === null ) {

						__b$1.copy( this.centroid ).divideScalar( this.count ).applyMatrix4( cluster.matrixWorld );

					} else {

						__b$1.copy( this.quadMarker.position ).applyMatrix4( cluster.matrixWorld );

					}

					const dCluster = Math.abs( __plane.distanceToPoint( __b$1 ) );

					const depthRatio = ( d2Target - dCluster ) / d2Target;

					//console.log( area, 'dr', Math.round( depthRatio * 100 )/100, 'af', Math.round( angleFactor * 100 ) / 100, '++', Math.round( depthRatio * angleFactor * 100 * 20 ) / 100);

					// cluster markers compensated for angle to the horizontal and distance from camera plane

					if ( area < 10 * depthRatio * angleFactor ) { // FIXME calibrate by screen size ???

						subQuad.clusterMarkers( cluster );

					} else {

						subQuad.showMarkers( selection );
						subQuad.check( cluster, target, angleFactor, selection );

					}

				}

			}

		}

		showMarkers ( selection ) {

			// show the indiviual markers in this quad

			this.markers.forEach( marker => marker.visible = selection.contains( marker.parentId ) );

			if ( this.quadMarker !== null ) this.quadMarker.visible = false;

		}

		hideMarkers () {

			// hide the indiviual markers in this quad

			this.markers.forEach( marker => marker.visible = false );

			if ( this.quadMarker !== null ) this.quadMarker.visible = false;

		}

		clusterMarkers ( cluster ) {

			// hide the indiviual markers in this quad

			this.hideMarkers();

			// hide quadMarkers for contained quads

			for ( let i = 0; i < 4; i++ ) {

				this.nodes[ i ]?.hideQuadMarkers();

			}

			if ( this.quadMarker === null ) {

				const quadMarker = new Marker( this.ctx, this.count );

				// set to center of distribution of markers in this quad.
				quadMarker.position.copy( this.centroid ).divideScalar( this.count );
				quadMarker.layers.set( CLUSTER_MARKERS );

				if ( cluster.heightProvider !== null ) {

					quadMarker.adjustHeight( cluster.heightProvider );

				}

				cluster.addStatic( quadMarker );

				this.quadMarker = quadMarker;

			}

			this.quadMarker.visible = true;

		}

		hideQuadMarkers () {

			if ( this.quadMarker ) this.quadMarker.visible = false;

			for ( let i = 0; i < 4; i++ ) {

				this.nodes[ i ]?.hideQuadMarkers();

			}

		}

		projectedArea ( cluster ) {

			const camera = cluster.camera;
			const matrixWorld = cluster.matrixWorld;
			const zAverage = this.centroid.z / this.count;

			__a$1.set( this.xMin, this.yMin, zAverage ).applyMatrix4( matrixWorld ).project( camera );
			__b$1.set( this.xMin, this.yMax, zAverage ).applyMatrix4( matrixWorld ).project( camera );
			__c$1.set( this.xMax, this.yMax, zAverage ).applyMatrix4( matrixWorld ).project( camera );
			__d$1.set( this.xMax, this.yMin, zAverage ).applyMatrix4( matrixWorld ).project( camera );

			return __t1$1.getArea() + __t2$1.getArea();

		}

	}

	class ClusterMarkers extends Object3D {

		constructor ( ctx, limits, maxDepth ) {

			super();

			const min = limits.min;
			const max = limits.max;

			this.maxDepth = maxDepth;

			this.type = 'CV.ClusterMarker';

			this.quadTree = new QuadTree( ctx, min.x, max.x, min.y, max.y );
			this.heightProvider = null;
			this.labels = [];
			this.ctx = ctx;

			const cfg = ctx.cfg;

			const atlasSpec = {
				background: cfg.themeColorCSS( 'stations.entrances.background' ),
				color: cfg.themeColorCSS( 'stations.entrances.text' ),
				font: 'normal helvetica,sans-serif'
			};

			const material = ctx.materials.getGlyphMaterial( atlasSpec, cfg.themeAngle( 'stations.entrances.angle' ) );

			material.depthTest = true;
			material.transparent = false;
			material.alphaTest = 0;

			this.labelMaterial = material;

			this.addEventListener( 'removed', this.onRemoved );

		}

		addHeightProvider( func ) {

			this.heightProvider = func;

			this.traverse( obj => { if ( obj.isMarker ) obj.adjustHeight( func ); } );

		}

		onRemoved () {

			this.traverse( obj => { if ( obj.type === 'GlyphString' ) obj.geometry.dispose(); } );

		}

		addMarker ( node, label ) {

			const marker = new GlyphString( label, this.labelMaterial, this.ctx );

			marker.layers.set( FEATURE_ENTRANCES );
			marker.position.copy( node );
			marker.parentId = node.parent.id;

			this.labels.push( marker );
			this.quadTree.addNode( marker, this.maxDepth );

			this.addStatic( marker );

			return marker;

		}

		cluster ( cameraManager, target, selectedStationSet ) {

			// determine which labels are too close together to be usefully displayed as separate objects.

			// immediate exit if only a single label or none.
			if ( this.children.length < 2 ) return;

			this.camera = cameraManager.activeCamera;

			const angle = this.camera.getWorldDirection( __v ).dot( Object3D.DefaultUp );

			this.quadTree.check( this, target, Math.max( 0.05, 1 - Math.cos( angle ) ), selectedStationSet );

			// sort by depth and update label boxes
			this.labels.sort( ( a, b ) => b.getDepth( cameraManager ) - a.getDepth( cameraManager ) );

			// traverse from back to front and use label boxes to detect overlapping labels and
			// set visible = false on the rear most
			this.labels.forEach( ( l, i, labels ) => l.checkOcclusion( labels, i ) );

			return;

		}

	}

	class Entrances extends ClusterMarkers {

		constructor ( ctx, survey ) {

			super( ctx, survey.modelLimits, 4 );

			const self = this;
			const surveyTree = survey.surveyTree;
			const entrances = survey.metadata.entrances;
			const vertices = [];

			const geometry = new BufferGeometry();

			const material = ctx.materials.getEntrancePointMaterial();

			this.entranceColor = ctx.cfg.themeColor( 'stations.entrances.marker' );

			const markers = new Points( geometry, material );

			markers.layers.set( FEATURE_ENTRANCE_DOTS );

			// remove common elements from station names if no alternatives available

			let endNode = surveyTree;

			while ( endNode.children.length === 1 ) endNode = endNode.children [ 0 ];

			// find entrances and add Markers

			surveyTree.traverse( _addEntrance );

			const l = vertices.length * 3;

			if ( l > 0 ) {

				const positions = new Float32BufferAttribute( l, 3 );
				const colors = new Float32BufferAttribute( l, 3 );

				positions.copyVector3sArray( vertices );

				geometry.setAttribute( 'position', positions );
				geometry.setAttribute( 'color', colors );
				geometry.computeBoundingBox();

			} else {

				this.visible = false;

			}

			this.markers = markers;
			this.vertices = vertices;
			this.metadata = survey.metadata;

			// set default colors - needs to be after markers property is set
			this.setSelection( null );

			this.addStatic( markers );

			return this;

			function _addEntrance ( node ) {

				if ( ! ( ( node.ownType ?? node.type ) & STATION_ENTRANCE ) ) return;

				if ( node.next ) {

					let next = node.next;

					// skip labels for all expect lowest id station
					while ( next !== node ) {

						if ( ( next.ownType & STATION_ENTRANCE ) !== 0 && Math.abs( node.id ) > Math.abs( next.id ) ) return;
						next = next.next;

					}

				}

				vertices.push( node );

				let name;

				const entranceInfo = entrances[ node.getPath() ];

				if ( entranceInfo?.name !== undefined ) {

					name = entranceInfo.name;
					if ( name === '-skip' ) return;

				} else if ( node.comment !== undefined ) {

					name = node.comment;

				} else {

					name = node.getPath( endNode );

				}

				self.addMarker( node, ` ${name} ` );

			}

		}

		getStation ( index ) {

			const station = this.vertices[ index ];
			const stationName = station.getPath();

			return {
				station: station,
				name: stationName,
				info: this.metadata.entrances[ stationName ]
			};

		}

		setStation ( station, info ) {

			const metadata = this.metadata;

			metadata.entrances[ station.getPath() ] = info;

			metadata.saveLocal();

		}

		setSelection ( selection ) {

			if ( ! this.visible ) return; // no entrances in survey

			const colors = this.markers.geometry.getAttribute( 'color' );
			const color = this.entranceColor;
			const array = colors.array;

			if ( selection === null || selection.isEmpty() ) {

				const l = array.length;

				for ( let i = 0; i < l; i += 3 ) {

					color.toArray( array, i );

				}

			} else {

				const idSet = selection.getIds();

				this.vertices.forEach( function ( node, i ) {

					if ( idSet.has( node.parent.id ) ) {

						color.toArray( array, i * 3 );

					} else {

						colors.setXYZ( i, 0.5, 0.5, 0.5 );

					}

				} );

			}

			colors.needsUpdate = true;

		}

		forEachEntrance ( callback ) {

			this.vertices.forEach( e => {

				callback( e );

				let next = e.next;

				while ( next !== null && next !== e ) {

					callback( next );
					next = next.next;

				}

			} );

		}

	}

	class Grid extends LineSegments2 {

		constructor ( ctx ) {

			const geometry = new LineSegmentsGeometry();
			const survey = ctx.survey;
			const baseColor = ctx.cfg.themeColor( 'grid.base' );

			super( geometry, ctx.materials.getLine2Material( { color: baseColor } ) );

			this.scale.set( 1, 1, 1 );
			this.type = 'CV.Grid';

			const box = ctx.survey.combinedLimits;

			const a = box.min.clone(); a.y = box.max.y;
			const b = box.max.clone();
			const c = box.min.clone(); c.x = box.max.x;
			const d = box.min.clone();

			/*
				Convert to original model CRS

				A-B
				| |
				D-C

			*/

			const A = survey.getGeographicalPosition( a );
			const B = survey.getGeographicalPosition( b );
			const C = survey.getGeographicalPosition( c );
			const D = survey.getGeographicalPosition( d );

			// approximate tranform as rotation and scale for small areas.

			const xRange = Math.min( C.x - D.x, B.x - A.x );
			const yRange = Math.min( A.y - D.y, B.y - C.y );

			const r = Math.log10( Math.max( xRange, yRange ) );
			const interval = Math.pow( 10, Math.round( r ) - 1 );

			const xScale = ( C.x - D.x ) / ( c.x - d.x );
			const yScale = ( A.y - D.y ) / ( a.y - d.y );

			const theta = Math.atan2( C.y - D.y, C.x - D.x );
			const cos = Math.cos( theta );

			const xOffset = ( interval - ( D.x % interval ) ) * cos / xScale;
			const yOffset = ( interval - ( D.y % interval ) ) * cos / yScale;

			const deltaX = interval * cos / xScale;
			const deltaY = interval * cos / yScale;

			// assume linear relationship between grids for simplicity
			const hGrad = ( c.x - d.x) * ( C.y - D.y ) / ( C.x - D.x );
			const vGrad = ( a.y - d.y) * ( A.x - D.x ) / ( A.y - D.y );

			const z = box.min.z;
			let i;

			const vertices = [];

			for ( i = d.x + xOffset; i < c.x; i += deltaX ) {

				vertices.push( i, d.y, z, i - vGrad, a.y, z );

			}

			for ( i = d.y + yOffset; i < a.y; i += deltaY ) {

				vertices.push( d.x,  i, z, c.x, i - hGrad, z );

			}

			geometry.setPositions( vertices );

		}

	}

	class Segments {

		constructor () {

			const segmentMap = new Map(); // maps segments of survey between ends of passages and junctions.
			const segmentToInfo = [];

			this.addSegment = function ( segmentInfo ) {

				segmentMap.set( segmentInfo.startStation.id + ':' + segmentInfo.endStation.id, segmentInfo );
				segmentToInfo[ segmentInfo.segment ] = segmentInfo;

			};

			this.getSegmentInfo = function ( index ) {

				return segmentToInfo[ index ];

			};

			this.getMap = function () {

				return segmentMap;

			};

		}

	}

	class Legs extends LineSegments2 {

		constructor ( ctx ) {

			const geometry = new LineSegmentsGeometry();

			super( geometry, ctx.materials.getSurveyLineMaterial( 'basic' ) );

			this.ctx = ctx;
			this.colourCache = ctx.materials.colourCache;
			this.legLengths = [];
			this.legVertices = [];
			this.legToSegment = []; // maps vertex index to segment membership
			this.colors = [];
			this.type = 'Legs';
			this.highlightLeg = null;
			this.highlightSegment = null;
			this.scale.set( 1, 1, 1 );
			this.pathsSet = false;

		}

		addLegs ( survey, vertices, legRuns ) {

			this.legVertices = vertices;
			this.legRuns = legRuns;

			const positions = new Float32BufferAttribute( vertices.length * 3, 3 );
			const colors = new Float32BufferAttribute( vertices.length * 3, 3 );

			positions.copyVector3sArray( vertices );
			colors.array.fill( 1.0 );

			const geometry = this.geometry;

			geometry.setPositions( positions.array );
			geometry.setColors( colors.array );

			this.computeLineDistances();
			this.computeStats( survey );

			this.colors = colors;

			return this;

		}

		computeStats ( survey ) {

			const vertices = this.legVertices;
			const l = vertices.length;

			const n = l / 2;
			const legLengths = new Array( n );

			let s1 = 0, s2 = 0;
			let min = Infinity;
			let max = -Infinity;

			for ( let i = 0; i < l; i += 2 ) {

				const v1 = vertices[ i ];
				const v2 = vertices[ i + 1 ];

				const legLength = survey.getGeographicalDistance( v1, v2 );

				legLengths[ i / 2 ] = legLength; // cache lengths to avoid recalc

				s1 += legLength;
				s2 += legLength * legLength;

				max = Math.max( max, legLength );
				min = Math.min( min, legLength );

			}

			const stats = {
				minLegLength: min,
				maxLegLength: max,
				legLength: s1,
				legLengthSD: Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) ),
				legLengthRange: max - min,
				legCount: n
			};

			this.legLengths = legLengths;
			this.stats = stats;

			return this;

		}

		cutRuns ( survey, selection ) {

			const idSet = selection.getIds();
			const legRuns = this.legRuns;

			if ( ! legRuns ) return;

			const vertices = this.legVertices;

			const newVertices = [];
			const newLegRuns = [];

			const l = legRuns.length;

			for ( let run = 0; run < l; run++ ) {

				const legRun = legRuns[ run ];

				const survey = legRun.survey;
				const start  = legRun.start;
				const end    = legRun.end;

				if ( idSet.has( survey ) ) {

					let vp = newVertices.length;

					for ( let v = start; v < end; v++ ) {

						const station = vertices[ v ];

						newVertices.push( station );

						//  clear topology info
						station.legs = [];
						station.linkedSegments = [];


					}

					// adjust vertex run for new vertices and color arrays

					legRun.start = vp;

					vp += end - start;

					legRun.end = vp;

					newLegRuns.push( legRun );

				}

			}

			if ( newVertices.length === 0 ) return false;

			this.geometry.dispose();

			this.addLegs( survey, newVertices, newLegRuns );

			return true;

		}

		setHighlightLeg ( l ) {

			this.highlightLeg = l;

		}

		setHighlightSegment ( l ) {

			this.highlightSegment = l;

		}

		setShading ( idSet, colourSegment, mode, dashed, filterConnected ) {

			this.material = this.ctx.materials.getSurveyLineMaterial( mode, dashed );
			this.material.needsUpdate = true;

			const legRuns = this.legRuns;
			const unselectedColor = this.ctx.cfg.themeColor( 'shading.unselected' );

			const vertices = this.legVertices;
			const colors = this.colors.array;
			const highlightLeg = this.highlightLeg === null ? null : this.highlightLeg * 2;
			const highlightSegment = this.highlightSegment;

			if ( idSet.size > 0 && legRuns ) {

				for ( let run = 0, l = legRuns.length; run < l; run++ ) {

					const legRun = legRuns[ run ];

					const survey = legRun.survey;
					const start  = legRun.start;
					const end    = legRun.end;

					if ( idSet.has( survey ) ) {

						for ( let v = start; v < end; v += 2 ) {

							colourSegment( vertices, colors, v, v + 1, survey );

						}

					} else {

						for ( let v = start; v < end; v++ ) {

							unselectedColor.toArray( colors, v * 3 );

						}

					}

				}

			} else {

				const segments = this.legToSegment;

				for ( let v1 = 0, l = vertices.length; v1 < l; v1 += 2 ) {

					const v2 = v1 + 1;

					if (
						( highlightLeg !== null && v1 !== highlightLeg ) ||
						( highlightSegment !== null && segments[ v1 / 2 ] !== highlightSegment ) ||
						( filterConnected && ( vertices[ v1 ].shortestPath === Infinity || vertices[ v2 ].shortestPath === Infinity ) )
					) {

						unselectedColor.toArray( colors, v1 * 3 );
						unselectedColor.toArray( colors, v2 * 3 );

					} else {

						colourSegment( vertices, colors, v1, v2, null );

					}

				}

			}

			this.geometry.getAttribute( 'instanceColorStart' ).needsUpdate = true;
			this.geometry.getAttribute( 'instanceColorEnd' ).needsUpdate = true;

		}

		hide ( mode ) {

			if ( mode ) {

				const vertices = this.legVertices;
				const legCount = vertices.length / 2;

				const hide = new Float32Array( legCount );

				for ( let i = 0; i < legCount; i++ ) {

					const sType1 = vertices[ i * 2 ].type;
					const sType2 = vertices[ i * 2 + 1 ].type;

					hide[ i ] = sType1 & STATION_XSECT && sType2 & STATION_XSECT ? 1 : 0;

				}

				this.geometry.setHide( hide );

			} else {

				this.geometry.clearHide();

			}

		}

		vertexSegment ( index ) {

			return this.legToSegment[ index / 2 ];

		}

		getLegInfo ( legIndex ) {

			const vertices = this.legVertices;
			const vertexIndex = legIndex * 2;

			return {
				index: legIndex,
				start: vertices[ vertexIndex ],
				end: vertices[ vertexIndex + 1 ],
				segment: this.legToSegment[ legIndex ],
				length: this.legLengths[ legIndex ]
			};

		}

		setLegColor ( leg, color1, color2 = null ) {

			const c1 = this.colourCache.getColour( color1 );
			const c2 = ( ! color2 ) ? c1 : this.colourCache.getColour( color2 );

			const colours = this.colors.array;

			leg *= 3;
			c1.toArray( colours, leg );
			c2.toArray( colours, leg + 3 );

			this.geometry.getAttribute( 'instanceColorStart' ).needsUpdate = true;
			this.geometry.getAttribute( 'instanceColorEnd' ).needsUpdate = true;

		}

		findTopology () {

			// determine segments between junctions and entrances/passage ends and create mapping array.

			const legs = this.legVertices;
			const legLengths = this.legLengths;
			const segments = new Segments();

			const l = legs.length;

			this.legToSegment = new Array( l / 2 );

			const legToSegment = this.legToSegment;

			let station;
			let newSegment = true;
			let segment = 0;
			let segmentInfo;

			for ( let i = 0; i < l; i = i + 2 ) {

				const v1 = legs[ i ];
				const v2 = legs[ i + 1 ];

				legToSegment[ i / 2 ] = segment;

				station = v1;

				if ( station !== undefined ) {

					station.legs.push( i );
					station.linkedSegments.push( segment );

				}

				if ( newSegment ) {

					if ( station === undefined ) continue; // possible use of separator in station name.

					segmentInfo = {
						segment: segment,
						startStation: station,
						endStation: null,
						length: 0
					};

					newSegment = false;

				}

				segmentInfo.length += legLengths[ i / 2 ];

				station = v2;

				if ( station !== undefined ) station.legs.push( i );

				if ( station && ( station.connections > 2 || ( i + 2 < l && ! station.equals( legs[ i + 2 ] ) ) ) ) {

					// we have found a junction or a passage end

					_addSegment();

					segment++;
					newSegment = true;

				}

			}

			if ( ! newSegment ) {

				_addSegment();

			}

			return segments;

			function _addSegment() {

				segmentInfo.endStation = station;

				segments.addSegment( segmentInfo );

				station.linkedSegments.push( segment );

			}

		}

		getAdjacentStations ( station ) {

			const legs = this.legVertices;
			const adjacentLegs = station.legs;
			const thisVertex = station;
			const ids = [];

			if ( ! adjacentLegs ) return ids;

			adjacentLegs.forEach( l => {

				const v1 = legs[ l ];
				const nextVertex = ( v1 === thisVertex ) ? legs[ l + 1 ] : v1;

				ids.push( nextVertex.id );

			} );

			return ids;

		}

		setShortestPaths ( station, legCallback = null ) {

			// queue of stations searched.
			const queue = [ station ];

			const legs = this.legVertices;
			const legLengths = this.legLengths;
			const legsSeen = [];

			let maxDistance = 0;

			station.shortestPath = 0;

			while ( queue.length > 0 ) {

				const station = queue.shift();
				const stationLegs = station.legs;

				const currentDistance = station.shortestPath;

				maxDistance = Math.max( maxDistance, currentDistance );

				// find stations connected to this station
				for ( let i = 0; i < stationLegs.length; i++ ) {

					const leg = stationLegs[ i ];

					const v1 = legs[ leg ];

					const legIndex = leg / 2;
					const nextStation = ( v1 === station ) ? legs[ leg + 1 ] : v1;
					const nextLength = legLengths[ legIndex];

					if ( legCallback !== null && ! legsSeen[ leg ] ) {

						legCallback( this.getLegInfo( legIndex ) );
						legsSeen[ leg ] = true;

					}

					// label stations with distance of shortest path
					// add to search list

					if ( nextStation.shortestPath > currentDistance + nextLength ) {

						nextStation.shortestPath = currentDistance + nextLength;
						queue.push( nextStation );

					}

				}

			}

			this.pathsSet = true;

			return maxDistance;

		}

		getShortestPath ( startStation ) {

			const path = new Set();

			let shortestPath = startStation.shortestPath;

			if (
				! this.pathsSet ||
				shortestPath === Infinity ||
				shortestPath === 0
			) return path;

			const legs = this.legVertices;

			_shortestPathSearch( null, startStation );

			return path;

			function _shortestPathSearch ( lastStation, station ) {

				const stationLegs = station.legs;
				const l = stationLegs.length;

				for ( let i = 0; i < l; i++ ) {

					const leg = stationLegs[ i ];
					const v1 = legs[ leg ];

					const nextStation = ( v1 === station ) ? legs[ leg + 1 ] : v1;

					// prevent loops with zero length legs
					if ( nextStation === lastStation ) continue;

					// '<=' to search via zero length legs
					if ( nextStation.shortestPath <= shortestPath ) {

						shortestPath = nextStation.shortestPath;

						path.add( leg );

						if ( nextStation.shortestPath === 0 ) {

							return;

						} else {

							_shortestPathSearch( station, nextStation );

						}


					}

				}

			}

		}

		forEachLeg ( callback ) {

			const l = this.legLengths.length;

			for ( let i = 0; i < l; i++ ) {
				callback ( this.getLegInfo( i ) );
			}

		}

	}

	/**
	 * @author Angus Sawyer
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
	 */

	class LoxTerrainGeometry extends BufferGeometry {

		constructor ( dtm, offsets ) {

			super();

			this.type = 'LoxTerrainGeometry';

			const heightData = dtm.data;

			const lines = dtm.lines;
			const samples = dtm.samples;
			const calib = dtm.calib;

			// buffers

			const indices = [];
			const vertices = [];

			// 2 x 2 scale & rotate callibration matrix

			const xx = calib.xx;
			const xy = calib.xy;
			const yx = calib.yx;
			const yy = calib.yy;

			// offsets from dtm -> survey -> model

			const xOffset = calib.xOrigin - offsets.x;
			const yOffset = calib.yOrigin - offsets.y;
			const zOffset = - offsets.z;

			const lx = samples - 1;
			const ly = lines - 1;

			let minZ = Infinity;
			let maxZ = -Infinity;

			// setup vertices from height data (corrected by rotation matrix)
			// y coordinates inverted in .lox datm data

			for ( let iy = 0; iy < lines; iy++ ) {

				const dstOffset = ( lines - 1 - iy ) * samples;

				for ( let ix = 0; ix < samples; ix++ ) {

					const x = ix * xx + ( ly - iy ) * xy + xOffset;
					const y = ix * yx + ( ly - iy ) * yy + yOffset;

					const z = heightData[ dstOffset + ix ] + zOffset;

					vertices.push( x, y, z );

					if ( z < minZ ) minZ = z;
					if ( z > maxZ ) maxZ = z;

				}

			}

			const maxX = lx * xx + ly * xy + xOffset;
			const maxY = lx * yx + ly * yy + yOffset;

			this.boundingBox = new Box3( new Vector3( xOffset, yOffset, minZ ), new Vector3( maxX, maxY, maxZ ) );

			// indices

			for ( let iy = 0; iy < ly; iy ++ ) {

				for ( let ix = 0; ix < lx; ix ++ ) {

					const a = ix + samples * iy;
					const b = ix + samples * ( iy + 1 );
					const c = ( ix + 1 ) + samples * ( iy + 1 );
					const d = ( ix + 1 ) + samples * iy;

					// faces - render each quad such that the shared diagonal edge has the minimum length - gives a smother terrain surface
					// diagonals b - d, a - c

					const d1 = Math.abs( vertices[ a * 3 + 2 ] - vertices[ d * 3 + 2 ] ); // diff in Z values between diagonal vertices
					const d2 = Math.abs( vertices[ b * 3 + 2 ] - vertices[ c * 3 + 2 ] ); // diff in Z values between diagonal vertices

					if ( d1 < d2 ) {

						indices.push( a, b, d );
						indices.push( b, c, d );

					} else {

						indices.push( a, b, c );
						indices.push( c, d, a );

					}

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

			// calibration data from terrain and local survey -> model - offsets

			this.computeVertexNormals();

		}

		setupUVs ( bitmap, image, offsets ) {

			const calib = bitmap.calib;
			const det = calib.xx * calib.yy - calib.xy * calib.yx;

			if ( det === 0 ) return false;

			// rotation matrix of bitmap over CRS
			const xx =   calib.yy / det;
			const xy = - calib.xy / det;
			const yx = - calib.yx / det;
			const yy =   calib.xx / det;

			const vertices = this.getAttribute( 'position' ).array;

			const width  = image.naturalWidth;
			const height = image.naturalHeight;

			const xOffset = - ( xx * calib.xOrigin + xy * calib.yOrigin );
			const yOffset = - ( yx * calib.xOrigin + yy * calib.yOrigin );

			const uvs = [];

			for ( let i = 0; i < vertices.length; i += 3 ) {

				const x = vertices[ i ]     + offsets.x;
				const y = vertices[ i + 1 ] + offsets.y;

				const u = ( x * xx + y * xy + xOffset ) / width;
				const v = ( x * yx + y * yy + yOffset ) / height;

				uvs.push( u, v );

			}

			const uvAttribute = this.getAttribute( 'uv' );

			if ( uvAttribute !== undefined ) {

				console.alert( 'replacing attribute uv' );

			}

			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class LoxTile extends Mesh {

		isTile = true;

		constructor ( ctx, terrain, offsets ) {

			super( new LoxTerrainGeometry( terrain.dtm, offsets ), ctx.materials.getSurfaceMaterial() );

			this.type = 'CV.LoxTile';
			this.layers.set( FEATURE_TERRAIN );
			this.overlayMaterial = null;
			this.ctx = ctx;

			if ( terrain.bitmap === undefined ) {

				this.bitmap = null;

			} else {

				this.bitmap = terrain.bitmap;
				this.offsets = offsets;

			}

		}

		loadOverlay ( ctx, overlayLoadedCallback ) {

			if ( this.bitmap === null ) return;

			const texture = new TextureLoader().load( this.bitmap.image, _overlayLoaded );
			const self = this;

			texture.anisotropy = this.ctx.cfg.value( 'anisotropy', 4 );

			return;

			function _overlayLoaded () {

				const bitmap = self.bitmap;

				self.geometry.setupUVs( bitmap, texture.image, self.offsets );

				texture.onUpdate = function ( texture ) {

					// release info

					URL.revokeObjectURL( texture.image.src );
					texture.image = null;

				};

				self.overlayMaterial = new TerrainOverlayMaterial( ctx );

				self.overlayMaterial.map = texture;

				bitmap.data = null;
				bitmap.image = null;

				self.material = self.overlayMaterial;

				overlayLoadedCallback();

			}

		}

		removed () {

			const material = this.overlayMaterial;

			if ( material !== null ) {

				material.map.dispose();
				material.dispose();

			}

			this.geometry.dispose();

		}

	}

	class LoxTerrain extends CommonTerrain {

		isTiled = false;
		isLoaded = true;

		constructor ( ctx, terrains, offsets ) {

			super( ctx );

			this.type = 'CV.Terrain';
			this.overlayMaterial = null;
			this.attributions = [];

			let bitmapCount = 0;

			terrains.forEach( terrain => {

				const tile = new LoxTile( ctx, terrain, offsets );

				if ( tile.bitmap !== null ) bitmapCount++;

				this.add( tile );

			} );

			this.overlayLoaded = false;
			this.hasOverlay = ( bitmapCount > 0 ) ? true : false;

		}

		setOverlay ( overlayLoadedCallback ) {

			if ( ! this.hasOverlay ) return;

			if ( this.overlayLoaded ) {

				this.children.forEach( tile => {

					if ( tile.overlayMaterial !== null ) {

						tile.material = tile.overlayMaterial;

					}

				} );

				overlayLoadedCallback();

				return;

			}

			this.children.forEach( tile => tile.loadOverlay( this.ctx, overlayLoadedCallback ) );

			this.overlayLoaded = true;

		}

		removed () {

			this.children.forEach( tile => tile.removed() );

			this.commonRemoved();

		}

		setMaterial ( material ) {

			this.children.forEach( tile => tile.material = material );

		}

		fitSurface ( modelPoints, offsets ) {

			super._fitSurface( modelPoints, offsets );

		}

	}

	class Routes extends EventDispatcher {

		constructor ( survey ) {

			super();

			// determine segments between junctions and entrances/passage ends and create mapping array.

			this.metadata = survey.metadata;
			this.segments = survey.segments;
			this.legs = survey.features.get( LEG_CAVE );
			this.surveyTree = survey.surveyTree;

			this.routes = new Map();
			this.routeNames = [];

			this.currentRoute = new Set();
			this.currentRouteName = null;
			this.adjacentSegments = new Set();

			Object.defineProperty( this, 'setRoute', {
				set( x ) { this.loadRoute( x ); },
				get() { return this.currentRouteName; }
			} );

			const routes = this.metadata.getRoutes();
			const routeNames = this.routeNames;

			let routeName;

			for ( routeName in routes ) {

				const route = routes[ routeName ];

				routeNames.push( routeName );
				this.routes.set( routeName, route.segments );

			}

			routeNames.sort();

			this.dispatchEvent( { type: 'changed', name: 'download' } );

		}

		addRoute ( routeName ) {

			if ( routeName === this.currentRouteName || routeName === undefined ) return;

			if ( this.routeNames.indexOf( routeName ) < 0 ) {

				// create entry for empty route if a new name

				this.routeNames.push( routeName );
				this.routes.set( routeName, [] );

			}

			this.loadRoute( routeName );

		}

		loadRoute ( routeName ) {

			const self = this;

			const surveyTree = this.surveyTree;
			const currentRoute = this.currentRoute;
			const segmentMap = this.segments.getMap();
			const routeSegments = this.routes.get( routeName );

			if ( ! routeSegments ) {

				alert( 'route ' + routeName + ' does not exist' );
				return false;

			}

			currentRoute.clear();

			for ( let i = 0; i < routeSegments.length; i++ ) {

				const segment = routeSegments[ i ];

				const map = segmentMap.get( surveyTree.getIdByPath( segment.start ) + ':' + surveyTree.getIdByPath( segment.end ) );

				if ( map !== undefined ) currentRoute.add( map.segment );

			}

			this.currentRouteName = routeName;

			self.dispatchEvent( { type: 'changed', name: '' } );

			return true;

		}

		getCurrentRoute () {

			return this.currentRoute;

		}

		saveCurrent () {

			const routeName = this.currentRouteName;
			const segmentMap = this.segments.getMap();
			const route = this.currentRoute;

			if ( ! routeName ) return;

			const routeSegments = [];

			segmentMap.forEach( _addRoute );

			// update in memory route

			this.routes.set( routeName, routeSegments );

			// update persistant browser storage

			this.metadata.saveRoute( routeName, { segments: routeSegments } );

			function _addRoute ( value /*, key */ ) {

				if ( route.has( value.segment ) ) {

					routeSegments.push( {
						start: value.startStation.getPath(),
						end: value.endStation.getPath()
					} );

				}

			}

		}

		getRouteNames () {

			return this.routeNames;

		}

		toggleSegment ( index ) {

			const self = this;
			const route = this.currentRoute;
			const segment = this.legs.vertexSegment( index );

			this.adjacentSegments.clear();

			if ( route.has( segment ) ) {

				route.delete( segment );

			} else {

				route.add( segment );

				// handle adjacent segments to the latest segment toggled 'on'

				const segmentInfo = this.segments.getSegmentInfo( segment );

				if ( segmentInfo !== undefined ) {

					segmentInfo.startStation.linkedSegments.forEach( _setAdjacentSegments );
					segmentInfo.endStation.linkedSegments.forEach( _setAdjacentSegments );

				}

			}

			return;

			function _setAdjacentSegments ( segment ) {

				if ( ! route.has( segment ) ) self.adjacentSegments.add( segment );

			}

		}

		inCurrentRoute ( segment ) {

			return this.currentRoute.has( segment );

		}

		adjacentToRoute ( segment ) {

			return this.adjacentSegments.has( segment );

		}

	}

	const img = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white' width='36px' height='36px'%3E%3Cpath d='M0 0h24v24H0z' fill='none'/%3E%3Cpath d='M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z'/%3E%3C/svg%3E";

	class PointIndicator extends Point {

		constructor ( ctx, color ) {

			const materials = ctx.materials;

			if ( materials.pointerTexture === undefined ) {

				materials.pointerTexture = new TextureLoader().load( img );

			}

			const material = new PointsMaterial( { size: 32, map: materials.pointerTexture, transparent : true, sizeAttenuation: false, alphaTest: 0.8, color: color } );

			super( material, ctx );

		}

	}

	const _position = new Vector4();
	const _ssOrigin = new Vector4();
	const _mouse = new Vector3();
	const _mvMatrix = new Matrix4();

	class Stations extends Points {

		constructor ( survey ) {

			const ctx = survey.ctx;

			super( new BufferGeometry, ctx.materials.getExtendedPointsMaterial() );

			this.type = 'CV.Stations';
			this.stationCount = 0;
			this.ctx = ctx;

			const cfg = ctx.cfg;

			this.baseColor     = cfg.themeColor( 'stations.default.marker' );
			this.junctionColor = cfg.themeColor( 'stations.junctions.marker' );
			this.entranceColor = cfg.themeColor( 'stations.entrances.marker' );

			this.vertices = [];
			this.pointSizes = [];
			this.instanceData = [];

			this.survey = survey;
			this.selected = null;
			this.selectedSize = 0;
			this.selection = survey.selection;
			this.splaysVisible = false;
			this.ssThresholdSq = Math.pow( cfg.value( 'stationSelectionDistance', 12 ), 2 );

			const point = new PointIndicator( ctx, 0xff0000 );

			point.visible = false;

			this.addStatic( point );
			this.highlightPoint = point;
		}

		raycast( raycaster, intersects ) {

			// screen space raycasing for stations

			if ( ! this.visible ) return intersects;

			const matrixWorld = this.matrixWorld;
			const ray = raycaster.ray;

			// test against survey section bounding boxes

			const surveyTree = this.survey.surveyTree;
			const searchNodes = surveyTree.findIntersects( matrixWorld, ray );

			const camera = raycaster.camera;
			const projectionMatrix = camera.projectionMatrix;
			const skipSplays = ! this.splaysVisible;
			const near = - camera.near;

			ray.at( 1, _ssOrigin );

			// ndc space [ - 1.0, 1.0 ]
			const container = this.ctx.container;

			const scale = new Vector3( container.clientWidth / 2, container.clientHeight / 2, 1 );

			_ssOrigin.w = 1;

			_ssOrigin.applyMatrix4( camera.matrixWorldInverse );
			_ssOrigin.applyMatrix4( camera.projectionMatrix );
			_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );

			// screen space
			_mouse.copy( _ssOrigin );
			_mouse.multiply( scale );

			_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );

			const ssThresholdSq = this.ssThresholdSq;

			for ( const node of searchNodes ) {

				const vertices = node.children;

				for ( let i = 0, l = vertices.length; i < l; i ++ ) {

					const station = vertices[ i ];

					// skip splay end stations if not visible
					if ( skipSplays && station.connections === 0 && station.type === 1 ) continue;

					_position.copy( station );
					_position.w = 1;

					_position.applyMatrix4( _mvMatrix );

					if ( _position.z > near ) {

						continue;

					}

					_position.applyMatrix4( projectionMatrix );
					_position.multiplyScalar( 1 / _position.w );

					_position.x *= scale.x;
					_position.y *= scale.y;

					testPoint( _position, station, i, ssThresholdSq, intersects, this );

				}

			}

		}

		addStation ( node ) {

			if ( node.stationVertexIndex != -1 ) return; // duplicated entry

			const instanceData = this.instanceData;
			const offset = instanceData.length;

			let pointSize = 0.0;
			let color;

			if ( node.type & STATION_ENTRANCE ) {

				color = this.entranceColor;
				pointSize = 12.0;

			} else {

				color = node.effectiveConnections() > 2 ? this.junctionColor : this.baseColor;
				pointSize = 8.0;

			}

			this.vertices.push( node );

			node.toArray( instanceData, offset );
			color.toArray( instanceData, offset + 3 );

			this.pointSizes.push( pointSize );

			node.stationVertexIndex = this.stationCount++;

		}

		isStationVisible ( node ) {

			return ( this.selection.contains( node.parent.id ) &&
				( node.connections > 0 || this.splaysVisible )
			);

		}

		getStationByIndex ( index ) {

			return this.vertices[ index ];

		}

		clearSelected () {

			if ( this.selected !== null ) {

				const pSize = this.geometry.getAttribute( 'pSize' );

				pSize.setX( this.selected, this.selectedSize );
				pSize.needsUpdate = true;

				this.selected = null;

			}

		}

		highlightStation ( node ) {

			const highlightPoint = this.highlightPoint;

			highlightPoint.position.copy( node );
			highlightPoint.updateMatrix();

			highlightPoint.visible = true;

			return node;

		}

		clearHighlight () {

			this.highlightPoint.visible = false;

		}

		selectStation ( node ) {

			this.selectStationByIndex( node.stationVertexIndex );

		}

		selectStationByIndex ( index ) {

			const pSize = this.geometry.getAttribute( 'pSize' );

			if ( this.selected !== null ) {

				pSize.setX( this.selected, this.selectedSize );

			}

			this.selectedSize = pSize.getX( index );

			pSize.setX( index, this.selectedSize * 2 );
			pSize.needsUpdate = true;

			this.selected = index;

		}

		selectStations ( selection ) {

			const vertices = this.vertices;
			const l = vertices.length;
			const pSize = this.geometry.getAttribute( 'pSize' );
			const splaySize = this.splaysVisible ? 6.0 : 0.0;
			const idSet = selection.getIds();
			const isEmpty = selection.isEmpty();

			for ( let i = 0; i < l; i++ ) {

				const node = vertices[ i ];

				let size = 8;

				if ( isEmpty || idSet.has( node.parent.id ) ) {

					if ( node.type & STATION_ENTRANCE ) {

						size = 12;

					} else if ( node.connections === 0 ) {

						size = splaySize;

					}

					pSize.setX( i, size );

				} else {

					pSize.setX( i, 0 );

					if ( node.label !== undefined ) node.label.visible = false;

				}

			}

			pSize.needsUpdate = true;

		}

		finalise () {

			const bufferGeometry = this.geometry;

			const buffer = new Float32Array( this.instanceData );
			const instanceBuffer = new InterleavedBuffer( buffer, 6 ); // position, color

			bufferGeometry.setAttribute( 'position', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) );
			bufferGeometry.setAttribute( 'color', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) );

			// non-interleaved to avoid excess data uploads to GPU
			bufferGeometry.setAttribute( 'pSize', new Float32BufferAttribute( this.pointSizes, 1 ) );

			this.instanceData = null;

		}

		setSplaysVisibility ( visible ) {

			this.splaysVisible = visible;
			const splaySize = visible ? 6.0 : 0.0;

			const vertices = this.vertices;
			const pSize = this.geometry.getAttribute( 'pSize' );
			const l = vertices.length;
			const selection = this.selection;

			for ( let i = 0; i < l; i++ ) {

				const node = vertices[ i ];

				if ( node.connections === 0 && ( splaySize === 0 || selection.contains( node.id ) ) ) {

					pSize.setX( i, splaySize );

				}

			}

			pSize.needsUpdate = true;
		}

		resetPaths () {

			this.vertices.forEach( node => node.shortestPath = Infinity );

		}

		forEach ( callback ) {

			this.vertices.forEach( station => {

				if ( station.connections !== 0 ) callback( station );

			} );

		}

	}

	function testPoint( point, station, index, localThresholdSq, intersects, object ) {

		const dX = point.x - _mouse.x;
		const dY = point.y - _mouse.y;

		const distanceSq = dX * dX + dY * dY;

		if ( distanceSq < localThresholdSq ) {

			intersects.push( {
				distance: Math.sqrt( distanceSq ),
				point: point,
				index: index,
				station: station,
				face: null,
				object: object
			} );

		}

	}

	const _tmpVector3 = new Vector3();

	class StationLabels extends Group {

		constructor ( ctx, stations, commentCount ) {

			super();

			this.type = 'CV.StationLabels';
			this.stations = stations;
			this.commentCount = commentCount;
			this.ctx = ctx;

			const materials = ctx.materials;

			this.defaultLabelMaterial = materials.getLabelMaterial( 'stations.default' );
			this.splayLabelMaterial = materials.getLabelMaterial( 'stations.default' );
			this.junctionLabelMaterial = materials.getLabelMaterial( 'stations.junctions' );
			this.linkedLabelMaterial = materials.getLabelMaterial( 'stations.linked' );

		}

		update ( camera, target, inverseWorld ) {

			const cameraPosition = _tmpVector3.copy( camera.position );

			if ( camera.isOrthographicCamera ) {

				// if orthographic, calculate 'virtual' camera position

				cameraPosition.sub( target ); // now vector from target

				cameraPosition.setLength( CAMERA_OFFSET / camera.zoom ); // scale for zoom factor
				cameraPosition.add( target ); // relocate in world space

			}

			// transform camera position into model coordinate system

			cameraPosition.applyMatrix4( inverseWorld );

			const stations = this.stations;
			const points = stations.vertices;
			const l = points.length;

			const showName = ( ( camera.layers.mask & 1 << LABEL_STATION ) !== 0 );
			const showComments = ( ( camera.layers.mask & 1 << LABEL_STATION_COMMENT ) !== 0 );
			const commentRatio = l / this.commentCount;

			for ( let i = 0; i < l; i++ ) {

				const station = points[ i ];
				const comment = station.comment;
				const label = station.label;

				const showComment = showComments && comment !== undefined;

				if ( ! stations.isStationVisible( station ) ) {

					if ( label ) label.visible = false;
					continue;

				}

				const connections = station.effectiveConnections();
				let d2 = 40000;

				if ( label?.visible ) {

					if ( connections === 0 ) {

						d2 = 600;

					} else if ( connections < 3 ) {

						d2 = 10000;

					} else {

						d2 = 50000;

					}

				} else {

					if ( connections === 0 ) {

						d2 = 250;

					} else if ( connections < 3 ) {

						d2 = 5000;

					}

				}

				// eager display of comments scaled by density of comments in survey
				if ( showComment ) d2 *= commentRatio;

				// show labels for network vertices at greater distance than intermediate stations
				const visible = ( station.distanceToSquared( cameraPosition ) < d2 );

				if ( visible ) {

					let name = '';

					if ( showName ) name += station.name;
					if ( showName && showComment ) name += ' ';
					if ( showComment ) name += comment;

					if ( label && label.name !== name ) {

						// remove label with the wrong text
						this.remove( label );
						station.label = null;

					}

					if ( ! station.label ) {

						this.addLabel( station, name, connections );

					}

					if ( station.label ) station.label.visible = true;

				} else {

					if ( label ) label.visible = false;

				}

			}

		}

		addLabel ( station, name, connections ) {

			let material;

			if ( station.next !== null ) {

				let next = station.next;

				// skip labels for all expect lowest id station
				while ( next !== station ) {

					if ( Math.abs( station.id ) > Math.abs( next.id ) ) return;
					next = next.next;

				}

				material = this.linkedLabelMaterial;

			} else if ( connections === 0 ) {

				material = this.splayLabelMaterial;

			} else if ( connections < 3 ) {

				material = this.defaultLabelMaterial;

			} else {

				material = this.junctionLabelMaterial;

			}

			const label = new GlyphString( name, material, this.ctx );

			label.layers.mask = this.layers.mask;
			label.position.copy( station );

			station.label = label;

			this.addStatic( label );

		}

	}

	class StationMarkers extends Group {

		constructor ( ctx, color ) {

			super();

			this.markers = new Map();
			this.markerColor = color;
			this.ctx = ctx;

		}

		mark ( node ) {

			const markers = this.markers;

			if ( markers.has( node ) ) return;

			const marker = new PointIndicator( this.ctx, this.markerColor );

			marker.position.copy( node );
			marker.station = node;
			marker.layers = this.layers;

			this.add( marker );

			markers.set( node, marker );

		}

		unmark ( node ) {

			const markers = this.markers;

			const marker = markers.get( node );

			if ( marker === undefined ) return;

			this.remove( marker );

			markers.delete( node );

		}

		clear () {

			this.markers.forEach( marker => this.remove( marker ) );
			this.markers.clear();

		}

		getStations () {

			return this.markers.keys();

		}

		setVisibility ( visible ) {

			this.markers.forEach( marker => marker.visible = visible );

		}

	}

	class SurveyBox extends LineSegments2 {

		constructor ( ctx, box3, color = 0xffff00 ) {

			const v0 = new Vector3(  0.5,  0.5,  0.5 );
			const v1 = new Vector3( -0.5,  0.5,  0.5 );
			const v2 = new Vector3( -0.5, -0.5,  0.5 );
			const v3 = new Vector3(  0.5, -0.5,  0.5 );
			const v4 = new Vector3(  0.5,  0.5, -0.5 );
			const v5 = new Vector3( -0.5,  0.5, -0.5 );
			const v6 = new Vector3( -0.5, -0.5, -0.5 );
			const v7 = new Vector3(  0.5, -0.5, -0.5 );

			const vertices = [
				v0, v1,
				v1, v2,
				v2, v3,
				v3, v0,
				v4, v5,
				v5, v6,
				v6, v7,
				v7, v4,
				v0, v4,
				v1, v5,
				v2, v6,
				v3, v7
			];

			const positions = new Float32BufferAttribute( vertices.length * 3, 3 );
			const geometry = new LineSegmentsGeometry();

			positions.copyVector3sArray( vertices );
			geometry.setPositions( positions.array );

			super( geometry, ctx.materials.getLine2Material( { color: color } ) );

			if ( box3 ) this.update( box3 );
			this.type = 'CV.SurveyBox';

		}

		update ( box3 ) {

			box3.getSize( this.scale );
			box3.getCenter( this.position );
			this.updateMatrix();
			this.updateWorldMatrix( true, true );

			this.geometry.computeBoundingSphere();

		}

		removed () {

			if ( this.geometry ) this.geometry.dispose();

		}

	}

	class Selection extends SurveyBox {

		constructor ( ctx, color ) {

			const survey = ctx.survey;

			const root = survey.surveyTree;
			let selectedNode = root;

			super( ctx, root.boundingBox, color );

			const material = this.material;

			material.stencilWrite = true;
			material.stencilZPass = IncrementStencilOp;

			this.layers.set( FEATURE_SELECTED_BOX );

			survey.addStatic( this );

			const selectedSectionIds = new Set();

			this.set = function ( node ) {

				selectedNode = node;
				selectedSectionIds.clear();

				if ( selectedNode === root ) {

					this.visible = false;

				} else {

					node.getSubtreeIds( selectedSectionIds );
					this.visible = true;

					if ( ! node.isStation() && node.boundingBox !== undefined ) {

						this.update( node.boundingBox );

					}

				}

			};

			this.getByName = function ( name ) {

				return root.getByPath( name ) || root;

			};

			this.getIds = function () {

				return selectedSectionIds;

			};

			this.isEmpty = function () {

				return ( selectedNode === root );

			};

			this.contains = function ( id ) {

				return ( selectedNode === root || selectedSectionIds.has( id ) );

			};

			this.getWorldBoundingBox = function () {

				if ( this.isEmpty() ) {

					return survey.getWorldBoundingBox();

				} else {

					if ( ! selectedNode.worldBoundingBox ) selectedNode.updateWorld( survey.matrixWorld );
					return selectedNode.worldBoundingBox;

				}

			};

			this.getName = function () {

				return this.isEmpty() ? '' : selectedNode.getPath();

			};

			this.getNode = function () {

				return selectedNode;

			};

			this.isStation = function () {

				return selectedNode.isStation();

			};

		}

	}

	function SurveyColourMapper ( ctx ) {

		let map = [];
		let selectedSection = 0;

		this.getColour = function ( surveyId ) {

			const surveyColours = ctx.materials.colourCache.getColorSet( 'survey' );

			return surveyColours[ surveyId % surveyColours.length ];

		};

		this.getColourMap = function ( newSelectedSection ) {

			if ( selectedSection === newSelectedSection && map.length > 0 ) {

				// use cached mapping
				return map;

			}

			map = [];
			selectedSection = newSelectedSection;

			// create mapping of survey id to colour
			// map each child id _and_ all its lower level survey ids to the same colour

			let subTree = selectedSection;
			let colour = this.getColour( selectedSection.id );

			_addMapping( subTree );

			let children = subTree.children;

			while ( children.length === 1 ) {

				subTree = children[ 0 ];
				_addMapping( subTree );
				children = subTree.children;

			}

			for ( let i = 0, l = children.length; i < l; i++ ) {

				const node = children[ i ];

				colour = this.getColour( node.id );

				node.traverse( _addMapping );

			}

			return map;

			function _addMapping ( node ) {

				// only add values for sections - not stations
				if ( ! node.isStation() ) map[ node.id ] = colour;

			}

		};

	}

	class SurveyMetadata extends EventDispatcher {

		constructor ( name, metadata ) {

			super();

			this.name = name;

			let routes = {};
			let traces = [];
			let entrances = {};

			if ( metadata !== null ) {

				if ( metadata.routes ) routes = metadata.routes;
				if ( metadata.traces ) traces = metadata.traces;
				if ( metadata.entrances ) entrances = metadata.entrances;

			}

			let localMetadata = window.localStorage.getItem( name );

			if ( localMetadata !== null ) {

				localMetadata = JSON.parse( localMetadata );

				const localRoutes = localMetadata.routes;

				// add local routes to any routes in metadata (if any)

				for ( const routeName in localRoutes ) {

					const route = localRoutes[ routeName ];
					route.local = true;

					routes[ routeName ] = route;

				}

				if ( localMetadata.traces !== undefined ) traces = localMetadata.traces; // FIXME - merge with preexisting
				if ( localMetadata.entrances !== undefined ) entrances = localMetadata.entrances;

			}

			this.routes = routes;
			this.traces = traces;
			this.entrances = entrances;

		}

		getRoutes () {

			return this.routes;

		}

		saveRoute ( routeName, route ) {

			this.routes[ routeName ] = route;

			this.saveLocal();
			this.dispatchEvent( { name: 'change', type: 'routes' } );

		}

		saveLocal () {

			const localMetadata = {
				routes: this.routes,
				traces: this.traces,
				entrances: this.entrances
			};

			window.localStorage.setItem( this.name, JSON.stringify( localMetadata ) );

		}

		getURL () {

			// dump of json top window for cut and paste capture

			return dataURL( {
				name: 'test',
				version: 1.0,
				routes: this.routes,
				traces: this.traces,
				entrances: this.entrances
			} );

		}

	}

	const __set = new Set();
	const white = new Color( 0xffffff );
	const __v0 = new Vector3();
	const __v1 = new Vector3();
	const __v2 = new Vector3();

	class Survey extends Object3D {

		constructor ( ctx, cave ) {

			super();

			this.highlightBox = null;
			this.highlightPath = null;
			this.lastMarkedStation = null;
			this.markers = new StationMarkers( ctx, 0x00ff00 );
			this.featureBox = null;
			this.surveyTree = null;
			this.projection = null;
			this.projectionWGS84 = null;
			this.caveShading = SHADING_HEIGHT;
			this.surfaceShading = SHADING_SINGLE;
			this.duplicateShading = SHADING_DUPLICATE;
			this.wallsMode = false;
			this.hideMode = false;
			this.ctx = ctx;

			// objects targeted by raycasters and objects with variable LOD

			this.pointTargets = [];
			this.entranceTargets = [];

			this.type = 'CV.Survey';
			this.cutInProgress = false;
			this.features = new Map();
			this.routes = null;
			this.stations = null;
			this.terrain = null;
			this.segments = null;
			this.inverseWorld = new Matrix4();

			this.lightDirection = new Vector3( -1, -1, 2 ).normalize();

			const self = this;

			this.gradientName = ctx.cfg.value( 'saturatedGradient', false ) ? 'gradientHi' : 'gradientLow';

			ctx.surveyColourMapper = new SurveyColourMapper( ctx );
			ctx.survey = this;

			let survey = cave.getSurvey();

			if ( survey.limits.isEmpty() ) throw new Error( 'Empty survey or region of survey' );

			this.name = survey.title;
			this.CRS = survey.sourceCRS;
			this.displayCRS = survey.displayCRS;

			this.limits = survey.limits;

			if ( ! survey.hasTerrain ) this.expand( this.limits );

			this.offsets = survey.offsets;

			const modelLimits = this.limits.clone();

			modelLimits.min.sub( this.offsets );
			modelLimits.max.sub( this.offsets );

			this.modelLimits = modelLimits;
			this.combinedLimits = modelLimits.clone();
			this.maxDistance = 0;

			// this needs to be defined before loading the leg data to
			// allow correct leg lengths to be calculated

			_setProjectionScale();

			this.loadCave( survey, cave.messages );

			this.loadWarnings( cave.messages );

			this.loadEntrances();

			this.setFeatureBox();

			this.addStatic( this.markers );

			this.addFeature( new Grid( ctx ), FEATURE_GRID, 'Grid' );

			this.addEventListener( 'removed', this.onRemoved );

			let zScale = 0.5;

			survey = null;

			Object.defineProperty( this, 'zScale', {
				get() { return zScale; },
				set( scale ) {

					// scale - in range 0 - 1

					const lastScale = Math.pow( 2, ( zScale - 0.5 ) * 4 );
					const newScale  = Math.pow( 2, ( scale - 0.5 ) * 4 );

					self.applyMatrix4( new Matrix4().makeScale( 1, 1, newScale / lastScale ) );
					self.updateMatrix();

					zScale = scale;

				}
			} );

			return;

			function _setProjectionScale () {

				// calculate scaling distortion if we have required CRS definitions
				const displayCRS = survey.displayCRS;

				if ( survey.sourceCRS === null || displayCRS === null || displayCRS === 'ORIGINAL' ) {

					self.scaleFactor = 1;

					if ( survey.sourceCRS !== null ) {

						self.projectionWGS84 = proj4( 'WGS84', survey.sourceCRS );

					}

					return;

				}

				// set up projection from model to original CRS
				const transform = proj4( displayCRS, survey.sourceCRS );
				self.projection = transform;

				// calculate lat/long distortion between CRS and display
				const p1 = self.limits.min.clone();
				const p2 = self.limits.max.clone();

				p1.z = 0;
				p2.z = 0;

				const l1 = p1.distanceTo( p2 );

				p1.copy( transform.forward( p1 ) );
				p2.copy( transform.forward( p2 ) );

				const l2 = p1.distanceTo( p2 );

				self.scaleFactor = l1 / l2;

				self.projectionWGS84 = proj4( 'WGS84', survey.displayCRS );

			}

		}

		expand ( box3 ) {

			const size = box3.getSize( __v0 );
			const scale = __v1;

			size.multiply( scale.set( 0.05, 0.05, 0 ) );

			box3.expandByVector( size );

		}

		onRemoved ( /* event */ ) {

			if ( this.cutInProgress ) {

				// avoid disposal phase when a cut operation is taking place.
				// this survey is being redisplayed.

				this.cutInProgress = false;

				return;

			}

			this.traverse( _dispose );

			while ( this.children.length > 0 ) { this.remove( this.children[ 0 ] ); }

			return;

			function _dispose ( object ) { if ( object.geometry ) object.geometry.dispose(); }

		}

		loadWarnings ( messages ) {

			const selection = this.selection;

			if ( messages.length > 0 ) {

				let errorMarkers = this.getFeature( SURVEY_WARNINGS );

				if ( ! errorMarkers ) errorMarkers = new StationMarkers( this.ctx, 0xff00ff );

				messages.forEach( message => {

					const node = message.station;

					if ( node !== undefined && selection.contains( node.id ) ) {

						errorMarkers.mark( node );
						node.messageText = message.text;

					}

				} );

				this.addFeature( errorMarkers, SURVEY_WARNINGS, 'CV.Survey:warnings' );

			}

		}

		refreshColors () {

			this.removeFeature( this.entrances );
			this.entrances = null;

			this.loadEntrances();

			this.removeFeature( this.featureBox );
			this.featureBox = null;

			this.setFeatureBox();

			this.setShadingMode( this.caveShading );
			this.setSurfaceShading( this.surfaceShading );
			this.setDuplicateShading( this.duplicateShading );

		}

		loadEntrances () {

			const entrances = new Entrances( this.ctx, this );

			this.addFeature( entrances, FEATURE_ENTRANCES, 'CV.Survey:entrances' );

			this.entranceTargets = [ entrances.markers ];
			this.entrances = entrances;

		}

		setupTerrain ( terrain ) {

			// expand limits with terrain
			this.combinedLimits.union( terrain.boundingBox );

			this.setFeatureBox();

			if ( terrain.isFlat ) return;

			this.removeFeature( this.getFeature( FEATURE_GRID ) );

			this.addFeature( new Grid( this.ctx ), FEATURE_GRID );

			// find height difference between all entrance locations and terrain
			// find average differences and use to alter height of terrain

			const points = [];

			this.surveyTree.traverse( _getSurfacePoints );

			if ( this.hasFeature( LEG_SURFACE) ) {

				this.getFeature( LEG_SURFACE ).legVertices.forEach( point => points.push( point ) );

			}

			terrain.fitSurface( points, this.offsets );

			if ( this.terrain === null ) this.terrain = terrain;

			// if we have a terrain we can make sure cluster markers can adjust to avoid terrain

			const markers = this.getFeature( FEATURE_ENTRANCES );

			if ( markers !== undefined ) {

				markers.addHeightProvider( terrain.getHeight.bind( terrain ) );

			}

			return;

			function _getSurfacePoints( node ) {

				if ( ! ( node.type & STATION_ENTRANCE ) ) return;
				points.push( node );

			}

		}

		loadCave ( survey, messages ) {

			const self = this;
			const ctx = this.ctx;
			const splayFix = survey.splayFix;

			const surveyTree = survey.surveyTree;

			this.surveyTree = surveyTree;

			this.selection = new Selection( ctx, ctx.cfg.themeValue( 'box.select' ) );
			this.highlightBox = new Selection( this.ctx, this.ctx.cfg.themeValue( 'box.highlight' ) );

			_loadSegments( survey.lineSegments );

			this.loadStations( surveyTree );

			_loadTerrain( survey );

			this.computeBoundingBoxes( surveyTree );

			this.pointTargets.push( this.stations );

			const metadata = new SurveyMetadata( this.name, survey.metadata );

			this.metadata = metadata;

			this.loadDyeTraces();

			this.segments = this.getFeature( LEG_CAVE ).findTopology();

			this.routes = new Routes( this );

			buildWallsSync( survey, this );

			return;

			function _loadSegments ( srcSegments ) {

				const l = srcSegments.length;
				const typeLegs = [];

				typeLegs[ LEG_CAVE    ] = { vertices: [], runs: [] };
				typeLegs[ LEG_SURFACE ] = { vertices: [], runs: [] };
				typeLegs[ LEG_SPLAY   ] = { vertices: [], runs: [] };
				typeLegs[ LEG_DUPLICATE ] = { vertices: [], runs: [] };

				let legs, run;
				let currentType;
				let currentSurvey;

				if ( l === 0 ) return null;

				for ( let i = 0; i < l; i++ ) {

					const leg = srcSegments[ i ];
					const survey = leg.survey;

					let type = leg.type;

					legs = typeLegs[ type ];

					if ( legs === undefined ) {

						console.warn( 'unknown segment type: ', type );
						break;

					}

					if ( splayFix && type === LEG_SPLAY ) {

						if ( leg.to.splays > -1 ||
							( leg.from.connections != 0 && leg.to.connections != 0 ) ) {

							leg.to.connections++;

							messages.push( { station: leg.to, text: 'splay fault' } );

							legs = typeLegs[ LEG_CAVE ];
							type = LEG_CAVE;

						}

					}

					if ( survey !== currentSurvey || type !== currentType ) {

						// complete last run data

						if ( run !== undefined ) {

							const lastLegs = typeLegs[ currentType ];

							run.end = lastLegs.vertices.length;
							lastLegs.runs.push( run );

						}

						// start new run

						run = {};

						run.survey = survey;
						run.start  = legs.vertices.length;

						currentSurvey = survey;
						currentType   = type;

					}

					legs.vertices.push( leg.from );
					legs.vertices.push( leg.to );

				}

				// add vertices run for last survey section encountered

				if ( run.end === undefined ) {

					run.end = legs.vertices.length;
					legs.runs.push( run );

				}

				_addModelSegments( LEG_CAVE, 'CV.Survey:cave:cave' );
				_addModelSegments( LEG_SURFACE, 'CV.Survey:surface:surface' );
				_addModelSegments( LEG_SPLAY, 'CV.Survey:cave:splay' );
				_addModelSegments( LEG_DUPLICATE, 'CV.Survey:cave:duplicate' );

				return;

				function _addModelSegments ( tag, name ) {

					const legs = typeLegs[ tag ];

					if ( legs.vertices.length === 0 ) return;

					const legObject = new Legs( ctx );

					legObject.addLegs( self, legs.vertices, legs.runs );

					self.addFeature( legObject, tag, name + ':g' );

				}

			}

			function _loadTerrain ( cave ) {

				if ( cave.hasTerrain === false ) return;

				const terrain = new LoxTerrain( ctx, cave.terrains, self.offsets );

				self.terrain = terrain;

				return;

			}

		}

		getFeature ( tag ) {

			return this.features.get( tag );

		}

		update ( cameraManager, target  ) {

			const camera = cameraManager.activeCamera;

			const entrances = this.features.get( FEATURE_ENTRANCES );

			if ( entrances && cameraManager.testCameraLayer( FEATURE_ENTRANCES ) ) {

				cameraManager.setCameraLayer( CLUSTER_MARKERS, true );
				entrances.cluster( cameraManager, target, this.selection );

			} else {

				cameraManager.setCameraLayer( CLUSTER_MARKERS, false );

			}

			const stationLabels = this.features.get( LABEL_STATION );

			if ( ! stationLabels ) return;

			if ( ( cameraManager.testCameraLayer( LABEL_STATION ) ) ||
				stationLabels.commentCount > 0 && cameraManager.testCameraLayer( LABEL_STATION_COMMENT ) ) {

				stationLabels.update( camera, target, this.inverseWorld );

			}

		}

		addFeature ( obj, tag, name ) {

			obj.name = name;
			obj.layers.set( tag );

			this.features.set( tag, obj );

			this.addStatic( obj );

			return obj;

		}

		removeFeature ( obj ) {

			if ( obj === null ) return;

			const features = this.features;

			features.forEach( ( value, key ) => { if ( value === obj ) features.delete( key ); } );

			this.layers.mask &= ~ obj.layers.mask;
			obj.removeFromParent();

		}

		hasFeature ( tag ) {

			return this.features.has( tag );

		}

		loadStations ( surveyTree ) {

			const stations = new Stations( this );

			let commentCount = 0;

			surveyTree.traverse( _addStation );

			// we have finished adding stations.
			stations.finalise();

			const stationLabels = new StationLabels( this.ctx, stations, commentCount );

			this.addFeature( stations, FEATURE_STATIONS, 'CV.Stations' );
			this.addFeature( stationLabels, LABEL_STATION, 'CV.StationLabels' );

			if ( commentCount > 0 ) {

				this.features.set( LABEL_STATION_COMMENT, stationLabels );
				stationLabels.layers.enable( LABEL_STATION_COMMENT );

			}

			this.stations = stations;

			return;

			function _addStation ( node ) {

				if ( node.comment !== undefined ) commentCount++;
				if ( ! node.isStation() ) return;

				stations.addStation( node );

			}

		}

		computeBoundingBoxes ( surveyTree ) {

			surveyTree.traverseDepthFirst( _computeBoundingBox );

			return;

			function _computeBoundingBox ( node ) {

				const parent = node.parent;

				if ( node.isStation() ) {

					parent.boundingBox.expandByPoint( node );
					parent.stationCount++;

				} else if ( parent ) {

					if ( node.children.length === 0 || node.boundingBox.isEmpty() ) return;

					parent.boundingBox.union( node.boundingBox );

				}

			}

		}

		loadDyeTraces () {

			const dyeTraces = new DyeTraces( this.ctx );

			this.addFeature( dyeTraces, FEATURE_TRACES, 'CV.DyeTraces' );

			this.dyeTraces = dyeTraces;

		}

		setScale ( hScale, vScale ) {

			this.scale.set( hScale, hScale, vScale );

			this.updateMatrix();
			this.updateWorldMatrix( true, true );
			this.inverseWorld.copy( this.matrixWorld ).invert();

		}

		getLegs () {

			return this.getFeature( LEG_CAVE ).legVertices;

		}

		getRoutes () {

			return this.routes;

		}

		getWorldPosition ( position ) {

			return position.applyMatrix4( this.matrixWorld );

		}

		getGeographicalPosition ( position, vector = false ) {

			const offsets = this.offsets;
			const projection = this.projection;

			__v0.x = position.x + offsets.x;
			__v0.y = position.y + offsets.y;

			// convert to original survey CRS
			const p = ( projection == null ) ? __v0 : projection.forward( __v0 );

			return vector !== false
				? vector.set( p.x, p.y, position.z + offsets.z )
				: new Vector3( p.x, p.y, position.z + offsets.z );

		}

		getGeographicalDistance ( v1, v2 ) {

			const p1 = this.getGeographicalPosition( v1, __v1 );
			const p2 = this.getGeographicalPosition( v2, __v2 );

			return p1.distanceTo( p2 );

		}

		getModelSurfaceFromWGS84 ( position, callback ) {

			const offsets = this.offsets;

			position.copy( this.projectionWGS84.forward( position ) );

			this.terrain.getHeights( [ position ], _handleResult );

			return;

			function _handleResult ( points ) {

				position.z = points[ 0 ].z;
				position.sub( offsets );

				callback();

			}

		}

		setShortestPaths ( station ) {

			const legs = this.getFeature( LEG_CAVE );

			this.highlightPath = null;

			this.markers.clear();

			// reset distances to unknown
			this.stations.resetPaths();

			this.maxDistance = legs.setShortestPaths( station );

			this.markers.mark( station );

			this.setShadingMode( SHADING_DISTANCE );

		}

		showShortestPath ( station ) {

			const legs = this.getFeature( LEG_CAVE );

			this.highlightPath = legs.getShortestPath( station );

			if ( this.lastMarkedStation !== null ) this.markers.unmark( this.lastMarkedStation );

			this.markers.mark( station );

			this.lastMarkedStation = station;

			this.setLegShading( LEG_CAVE, SHADING_DISTANCE );

		}

		getMaxDistance () {

			return this.maxDistance;

		}

		selectStation ( station ) {

			this.stations.selectStation( station );

		}

		highlightSelection ( node ) {

			const box = this.highlightBox;

			if ( node.isStation() ) {

				this.stations.highlightStation( node );
				box.set( this.surveyTree );

			} else {

				box.set( node );
				this.stations.clearHighlight();

				if ( node === this.surveyTree ) {

					this.entrances.setSelection( this.selection );

				} else {

					this.entrances.setSelection( box );

				}

			}

		}

		selectSection ( node ) {

			const selection = this.selection;

			this.highlightSelection( this.surveyTree );

			selection.set( node );

			this.stations.selectStations( selection );
			this.entrances.setSelection( selection );
			this.setShadingMode( this.caveShading );

			return node;

		}

		setFeatureBox () {

			if ( this.featureBox === null ) {

				const box = new SurveyBox( this.ctx, this.combinedLimits, this.ctx.cfg.themeColorCSS( 'box.bounding' ) );

				this.addFeature( box, FEATURE_BOX, 'survey-boundingbox' );
				this.featureBox = box;

			} else {

				this.featureBox.update( this.combinedLimits );

			}

		}

		getWorldBoundingBox () {

			return this.combinedLimits.clone().applyMatrix4( this.matrixWorld );

		}

		cutSection ( node ) {

			const selection = this.selection;
			const self = this;

			selection.set( node );

			if ( selection.isEmpty() ) return;

			// clear target lists

			this.pointTargets = [];
			this.entranceTargets = [];

			this.terrain = null;
			this.highlightBox = null;

			// iterate through objects replace geometries and remove bounding boxes;

			const cutList = []; // list of Object3D's to remove from survey - workaround for lack of traverseReverse

			this.traverse( _cutObject );

			cutList.forEach( obj => {

				// dispose of all geometry of this object and descendants

				if ( obj.geometry ) obj.geometry.dispose();
				this.removeFeature( obj );

			} );

			this.surveyTree = node;

			this.selection = new Selection( this.ctx, this.ctx.cfg.themeValue( 'box.select' ) );
			this.highlightBox = new Selection( this.ctx, this.ctx.cfg.themeValue( 'box.highlight' ) );

			// reset vertex indices to allow stations to be displayed.
			node.traverse( node => { if ( node.isStation() ) node.stationVertexIndex = -1; } );

			this.loadStations( node );

			this.pointTargets.push( this.stations );

			// ordering is important here

			this.selectSection( node );

			this.loadEntrances();

			this.modelLimits.copy( node.boundingBox );
			this.expand( this.modelLimits );

			this.combinedLimits.copy( this.modelLimits );

			this.limits.copy( this.modelLimits ).translate( this.offsets );

			this.featureBox = null;

			this.setFeatureBox();
			this.addFeature( new Grid( this.ctx ), FEATURE_GRID );

			// this.loadWarnings();
			// this.loadDyeTraces();

			this.sections = this.getFeature( LEG_CAVE ).findTopology();
			this.maxDistance = 0;

			this.cutInProgress = true;

			return;

			function _cutObject ( obj ) {

				switch ( obj.type ) {

				case 'Legs':
				case 'Walls':

					if ( ! obj.cutRuns( self, selection ) ) cutList.push( obj );

					break;

				case 'CV.SurveyBox':
				case 'CV.Stations':
				case 'CV.StationLabels':
				case 'CV.ClusterMarker':
				case 'CV.Grid':
				case 'CV.GlyphString':
				case 'Point':
				case 'Points':
				case 'LineSegments2':
					cutList.push( obj );

					break;

				}

			}

		}

		setWallsMode ( mode ) {

			this.getFeature( FACE_WALLS )?.setFlat( mode );
			this.getFeature( FACE_SCRAPS )?.setFlat( mode );

			this.wallsMode = mode;

		}

		setHideMode ( mode ) {

			this.getFeature( LEG_CAVE )?.hide( mode );

			this.hideMode = mode;

		}

		setShadingMode ( mode, filterConnected ) {

			const materials = this.ctx.materials;

			let material;

			switch ( mode ) {

			case SHADING_HEIGHT:

				material = materials.getHeightMaterial();

				break;

			case SHADING_CURSOR:

				material = materials.getCursorMaterial();

				break;

			case SHADING_SINGLE:

				material = materials.getSingleWallMaterial();

				break;

			case SHADING_DEPTH:

				if ( this.terrain === null ) return false;

				material = materials.getDepthMaterial();

				if ( ! material ) return false;

				break;

			case SHADING_DEPTH_CURSOR:

				if ( this.terrain === null ) return false;

				material = materials.getDepthCursorMaterial();

				if ( ! material ) return false;

				break;

			case SHADING_DISTANCE:
			case SHADING_SURVEY:

				material = false;

				break;

			}

			this.markers.setVisibility( ( mode === SHADING_DISTANCE ) );

			if ( this.setLegShading( LEG_CAVE, mode, false, filterConnected ) ) {

				this.setWallShading( this.features.get( FACE_WALLS  ), material );
				this.setWallShading( this.features.get( FACE_SCRAPS ), material );

				this.caveShading = mode;

			}

			return this.caveShading;

		}

		getShadingMode () {

			return this.caveShading;

		}

		setWallShading ( mesh, selectedMaterial ) {

			if ( ! mesh ) return;

			if ( selectedMaterial ) {

				mesh.setShading( this.selection, selectedMaterial );

			} else {

				mesh.visible = false;

			}

		}

		setSurfaceShading ( mode ) {

			if ( this.setLegShading( LEG_SURFACE, mode, true ) ) {

				this.surfaceShading = mode;

			}

			return this.surfaceShading;

		}

		setDuplicateShading ( mode ) {

			if ( this.setLegShading( LEG_DUPLICATE, mode, true ) ) {

				this.duplicateShading = mode;

			}

			return this.duplicateShading;

		}

		setLegShading ( legType, legShadingMode, dashed, filterConnected ) {

			const legs = this.features.get( legType );

			if ( legs === undefined ) return false;

			const cfg = this.ctx.cfg;

			switch ( legShadingMode ) {

			case SHADING_HEIGHT:

				this.setLegColourByMaterial( legs, 'height', dashed, filterConnected );
				break;

			case SHADING_LENGTH:

				this.setLegColourByLength( legs, filterConnected );
				break;

			case SHADING_INCLINATION:

				this.setLegColourByInclination( legs, filterConnected );
				break;

			case SHADING_CURSOR:

				this.setLegColourByMaterial( legs, 'cursor', filterConnected );
				break;

			case SHADING_DEPTH_CURSOR:

				this.setLegColourByMaterial( legs, 'depth-cursor', filterConnected );
				break;

			case SHADING_SINGLE:

				this.setLegColourByColour( legs, cfg.themeColor( 'shading.single' ), dashed, filterConnected );
				break;

			case SHADING_SURFACE:

				this.setLegColourByColour( legs, cfg.themeColor( 'shading.surface' ), dashed, filterConnected );
				break;

			case SHADING_DUPLICATE:

				this.setLegColourByColour( legs, cfg.themeColor( 'shading.duplicate' ), dashed, filterConnected );
				break;

			case SHADING_CUSTOM:

				this.setLegCustomColor( legs, dashed, filterConnected );
				break;

			case SHADING_SURVEY:

				this.setLegColourBySurvey( legs, filterConnected );
				break;

			case SHADING_PATH:

				this.setLegColourByPath( legs );
				break;

			case SHADING_OVERLAY:

				break;

			case SHADING_SHADED:

				break;

			case SHADING_DEPTH:

				this.setLegColourByMaterial( legs, 'depth', dashed, filterConnected );
				break;

			case SHADING_DISTANCE:

				this.setLegColourByDistance( legs );
				break;

			default:

				console.warn( 'invalid leg shading mode' );
				return false;

			}

			return true;

		}

		setLegColourByMaterial ( mesh, mode, dashed, filterConnected ) {

			mesh.setShading( this.selection.getIds(), _colourSegment, mode, dashed, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2 ) {

				white.toArray( colors, v1 * 3 );
				white.toArray( colors, v2 * 3 );

			}

		}

		setLegColourByColour ( mesh, colour, dashed, filterConnected ) {

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic', dashed, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2 ) {

				colour.toArray( colors, v1 * 3 );
				colour.toArray( colors, v2 * 3 );

			}

		}

		setLegCustomColor ( mesh, dashed, filterConnected ) {

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic', dashed, filterConnected );

			function _colourSegment() {}

		}

		setLegColourByLength ( mesh, filterConnected ) {

			const materials = this.ctx.materials;
			const colours = materials.colourCache.getColorSet( this.gradientName );
			const colourRange = colours.length - 1;
			const stats = mesh.stats;
			const legLengths = mesh.legLengths;

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic', false, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2 ) {

				const relLength = ( legLengths[ v1 / 2 ] - stats.minLegLength ) / stats.legLengthRange;
				const colour = colours[ Math.floor( relLength * colourRange ) ];

				colour.toArray( colors, v1 * 3 );
				colour.toArray( colors, v2 * 3 );

			}

		}

		setLegColourByDistance ( mesh, filterConnected ) {

			const cfg = this.ctx.cfg;
			const materials = this.ctx.materials;

			const colours = materials.colourCache.getColorSet( this.gradientName );
			const unconnected = cfg.themeColor( 'shading.unconnected' );
			const pathColor = cfg.themeColor( 'routes.active' );

			const colourRange = colours.length - 1;

			if ( this.maxDistance === 0 ) {

				if ( this.entrances ) {

					let maxDistance = 0;

					// reset distances to unknown
					this.stations.resetPaths();

					this.highlightPath = null;
					this.markers.clear();

					this.entrances.forEachEntrance( e => maxDistance = Math.max( maxDistance, mesh.setShortestPaths( e ) ) );

					this.maxDistance = maxDistance;

				}

			}

			const maxDistance = this.maxDistance;
			const path = this.highlightPath;

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic', false, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2 ) {

				const onPath = ( path !== null && path.has( v1 ) );

				const c1 = onPath ? pathColor : _setDistanceColour( vertices, v1 );
				const c2 = onPath ? pathColor : _setDistanceColour( vertices, v2 );

				c1.toArray( colors, v1 * 3 );
				c2.toArray( colors, v2 * 3 );

			}

			function _setDistanceColour( vertices, vertexIndex ) {

				const vertex = vertices[ vertexIndex ];
				const distance = vertex.shortestPath;

				return ( distance === Infinity ) ? unconnected : colours[ Math.floor( colourRange * distance / maxDistance ) ];

			}

		}

		setLegColourBySurvey ( mesh, filterConnected ) {

			let node = this.selection.getNode();

			while ( node.children.length === 1 ) node = node.children[ 0 ];

			__set.clear();
			node.getSubtreeIds( __set );

			const surveyToColourMap = this.ctx.surveyColourMapper.getColourMap( node );

			mesh.setShading( __set, _colourSegment, 'basic', false, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2, survey ) {

				const colour = surveyToColourMap[ survey ];

				colour.toArray( colors, v1 * 3 );
				colour.toArray( colors, v2 * 3 );

			}

		}

		setLegColourByPath ( mesh ) {

			const routes = this.routes;
			const cfg = this.ctx.cfg;

			const c1 = cfg.themeColor( 'routes.active' );
			const c2 = cfg.themeColor( 'routes.adjacent' );
			const c3 = cfg.themeColor( 'routes.default' );

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic');

			function _colourSegment ( vertices, colors, v1, v2 /*, survey */ ) {

				const segment = mesh.vertexSegment( v1 );
				let colour;

				if ( routes.inCurrentRoute( segment ) ) {

					colour = c1;

				} else if ( routes.adjacentToRoute( segment ) ) {

					colour = c2;

				} else {

					colour = c3;
				}

				colour.toArray( colors, v1 * 3 );
				colour.toArray( colors, v2 * 3 );

			}

		}

		setLegColourByInclination ( mesh, filterConnected ) {

			const colourCache = this.ctx.materials.colourCache;
			const colours = colourCache.getColorSet( 'inclination' );

			const colourRange = colours.length - 1;
			const hueFactor = colourRange * 2 / Math.PI;
			const legNormal = new Vector3();

			mesh.setShading( this.selection.getIds(), _colourSegment, 'basic', false, filterConnected );

			function _colourSegment ( vertices, colors, v1, v2 ) {

				const vertex1 = vertices[ v1 ];
				const vertex2 = vertices[ v2 ];

				legNormal.subVectors( vertex1, vertex2 ).normalize();

				const dotProduct = legNormal.dot( Object3D.DefaultUp );

				const hueIndex = Math.floor( hueFactor * Math.acos( Math.abs( dotProduct ) ) );
				const colour = colours[ hueIndex ];

				colour.toArray( colors, v1 * 3 );
				colour.toArray( colors, v2 * 3 );

			}

		}

	}

	class ViewState {

		static default = {
			autoRotate: false,
			autoRotateSpeed: 0.5,
			box: true,
			cameraType: CAMERA_PERSPECTIVE,
			duplicateShading: SHADING_DUPLICATE,
			editMode: MOUSE_MODE_NORMAL,
			entrances: true,
			entrance_dots: true,
			fog: false,
			fullscreen: false,
			grid: false,
			HUD: true,
			linewidth: 0,
			scaleLinewidth: false,
			scraps: false,
			shadingMode: SHADING_HEIGHT,
			splays: false,
			stations: false,
			stationLabels: false,
			stationLabelOver: false,
			surfaceLegs: false,
			surfaceShading: SHADING_HEIGHT,
			terrain: false,
			terrainDatumShift: false,
			terrainLightingMode: LM_SINGLE,
			terrainOpacity: 0.5,
			terrainShading: SHADING_RELIEF,
			traces: false,
			view: VIEW_PLAN,
			walls: false,
			warnings: false,
			zoomToCursor: true
		};

		constructor ( cfg, viewer ) {

			const properties = [];

			Object.keys( viewer ).forEach( name => {

				const pDesc = Object.getOwnPropertyDescriptor( viewer, name );

				if ( pDesc.set !== undefined && pDesc.get !== undefined ) properties.push( name );

			} );

			this.getState = function () {

				const state = {};

				properties.forEach( name => {

					const value = viewer[ name ];

					if ( typeof value === 'object' ) return;

					state[ name ] = value;

				} );

				return state;

			};

			this.saveState = function () {

				window.localStorage.setItem( 'cv-state', JSON.stringify( this.getState() ) );

			};

			this.clear = function () {

				window.localStorage.removeItem( 'cv-state' );

			};

			this.getDefaultState = function () {

				const userSettings = JSON.parse( window.localStorage.getItem( 'cv-state' ) ) || {} ;

				return Object.assign( {}, ViewState.default, cfg.value( 'view', {} ), userSettings );

			};

		}

	}

	class EPSG4326TileSet {

		static workerScript = 'webMeshWorker.js';
		static defaultTileSet = {
			title: 'Cesium',
			initialZoom: 12,
			overlayMaxZoom: 16,
			maxZoom: 17,
			minZoom: 10,
			divisions: 1,
			subdirectory: null,
			dtmScale: 64,
			minX: 0,
			maxX: 2048,
			minY: 0,
			maxY: 1023,
			attributions: [],
			log: true,
			valid: false
		};

		constructor ( ctx, crs ) {

			this.CRS = crs;
			this.transform = proj4( crs, 'EPSG:4326' );

			// survey limits

			this.transformedLimits = null;

			const accessToken = ctx.cfg.value( 'cesiumAccessToken', false );

			if ( ! accessToken ) {

				return Promise.reject( this );

			}

			const url = 'https://api.cesium.com/v1/assets/1/endpoint?access_token=' + accessToken;

			return new Promise( ( resolve, reject ) => {

				new FileLoader().setResponseType( 'text' ).load(
					url,
					// success handler
					text => {

						const endpoint = JSON.parse( text );

						this.url = endpoint.url;
						this.accessToken = endpoint.accessToken;
						this.attributions = endpoint.attributions;

						EPSG4326TileSet.defaultTileSet.valid = true;
						resolve( this );

					},
					// progress handler
					function () {},
					// error handler
					() => { console.warn( 'cesium api error' ); reject( this ); }
				);

			} );

		}

		workerScript () {

			return EPSG4326TileSet.workerScript;

		}

		getTileSets () {

			return [ EPSG4326TileSet.defaultTileSet ];

		}

		getScreenAttribution () {

			const attributions = this.attributions;

			if ( attributions.length === 0 ) return null;

			const div = document.createElement( 'div' );

			div.classList.add( 'overlay-branding' );

			for ( let i = 0; i < attributions.length; i++ ) {

				const attribution = attributions[ i ];

				div.innerHTML = attribution.html;

			}

			return div;

		}

		getCoverage ( limits, zoom ) {

			const coverage = { zoom: zoom };

			const S = - 90;
			const W = - 180;

			if ( this.transformedLimits === null ) {

				this.transformedLimits = new Box2();

			}

			const transformedLimits = this.transformedLimits;

			transformedLimits.expandByPoint( this.transform.forward( limits.min.clone() ) );
			transformedLimits.expandByPoint( this.transform.forward( limits.max.clone() ) );

			const min = transformedLimits.min;
			const max = transformedLimits.max;

			const tileCount = Math.pow( 2, zoom ) / 180; // tile count per degree

			coverage.minX = Math.floor( ( min.x - W ) * tileCount );
			coverage.maxX = Math.floor( ( max.x - W ) * tileCount );

			coverage.minY = Math.floor( ( min.y - S ) * tileCount );
			coverage.maxY = Math.floor( ( max.y - S ) * tileCount );

			coverage.count = ( coverage.maxX - coverage.minX + 1 ) * ( coverage.maxY - coverage.minY + 1 );

			return coverage;

		}

		getTileSpec ( x, y, z, limits ) {

			const tileBox = new Box2();

			const S = - 90;
			const W = - 180;

			// ensure tile is within survey limits

			const tileSize = 180 / Math.pow( 2, z ); // tileSize

			tileBox.min.x = W + x * tileSize;
			tileBox.min.y = S + y * tileSize;

			tileBox.max.x = W + ( x + 1) * tileSize;
			tileBox.max.y = S + ( y + 1 ) * tileSize;

			if ( ! this.transformedLimits.intersectsBox( tileBox ) ) return null;

			const clippedSize = new Vector2();

			tileBox.clone().intersect( this.transformedLimits ).getSize( clippedSize );

			return {
				tileSet: this.tileSet,
				divisions: 1,
				resolution: tileSize,
				x: x,
				y: y,
				z: z,
				clip: limits,
				offsets: null,
				flatZ: null,
				displayCRS: this.CRS,
				url: this.url,
				accessToken: this.accessToken,
				clippedFraction: clippedSize.x * clippedSize.y / tileSize * tileSize,
				request: 'tile'
			};

		}

	}

	const halfMapExtent = 6378137 * Math.PI; // from EPSG:3875 definition

	class EPSG3857TileSet {

		static workerScript = 'webTileWorker.js';
		static defaultTileSet = {
			isFlat: true,
			title: 'flat',
			overlayMaxZoom: 18,
			maxZoom: 18,
			minZoom: 10,
			divisions: 128,
			subdirectory: null,
			dtmScale: 64,
			minX: 0,
			maxX: 1023,
			minY: 0,
			maxY: 1023,
			attributions: [],
			log: true
		};

		constructor ( ctx ) {

			this.tileSets = [ EPSG3857TileSet.defaultTileSet ];

			return fetch( ctx.cfg.value( 'terrainDirectory', '' ) + '/tileSets.json' )
				.then( response => {
					return response.ok ? response.json() : [];
				} ).then( ts => {
					this.tileSets = ts.concat( this.tileSets );
					return this;
				}, () => { return this; } );

		}

		workerScript () {

			return EPSG3857TileSet.workerScript;

		}

		getTileSets () {

			return this.tileSets;

		}

		getScreenAttribution () {

			return null;

		}

		getCoverage ( limits, zoom ) {

			const coverage = { zoom: zoom };

			const N = halfMapExtent;
			const W = -halfMapExtent;

			const tileCount = Math.pow( 2, zoom - 1 ) / halfMapExtent; // tile count per metre

			coverage.minX = Math.floor( ( limits.min.x - W ) * tileCount);
			coverage.maxX = Math.floor( ( limits.max.x - W ) * tileCount);

			coverage.maxY = Math.floor( ( N - limits.min.y ) * tileCount);
			coverage.minY = Math.floor( ( N - limits.max.y ) * tileCount);

			coverage.count = ( coverage.maxX - coverage.minX + 1 ) * ( coverage.maxY - coverage.minY + 1 );

			return coverage;

		}

		getTileSpec ( x, y, z, limits ) {

			const tileSet = this.tileSet;
			const scale = ( z > tileSet.maxZoom ) ? Math.pow( 2, tileSet.maxZoom - z ) : 1;

			// don't zoom in with no overlay - no improvement of terrain rendering in this case

			if ( scale !== 1 && this.activeOverlay === null ) return null;

			if ( this.log ) console.log( `load: [ ${z}/${x}/${y} ]` );

			const tileWidth = halfMapExtent / Math.pow( 2, z - 1 );

			const clip = { top: 0, bottom: 0, left: 0, right: 0 };

			const tileMinX = tileWidth * x - halfMapExtent;
			const tileMaxX = tileMinX + tileWidth;

			const tileMaxY = halfMapExtent - tileWidth * y;
			const tileMinY = tileMaxY - tileWidth;

			const divisions = ( tileSet.divisions ) * scale;
			const resolution = tileWidth / divisions;

			// trim excess off sides of tile where overlapping with region

			if ( tileMaxY > limits.max.y ) clip.top = Math.floor( ( tileMaxY - limits.max.y ) / resolution);

			if ( tileMinY < limits.min.y ) clip.bottom = Math.floor( ( limits.min.y - tileMinY ) / resolution);

			if ( tileMinX < limits.min.x ) clip.left = Math.floor( ( limits.min.x - tileMinX ) / resolution);

			if ( tileMaxX > limits.max.x ) clip.right = Math.floor( ( tileMaxX - limits.max.x ) / resolution);

			if ( clip.top >= divisions || clip.bottom >= divisions || clip.left >= divisions || clip.right >= divisions ) return null;

			const clippedFraction = ( divisions - clip.top - clip.bottom ) * ( divisions - clip.left - clip.right ) / (divisions * divisions );

			return {
				tileSet: tileSet,
				divisions: divisions,
				resolution: resolution,
				x: x,
				y: y,
				z: z,
				clip: clip,
				offsets: null,
				flatZ: null,
				clippedFraction: clippedFraction,
				request: 'tile'
			};

		}

		findTile ( point ) {

			const tileSet = this.tileSet;

			const tileWidth = halfMapExtent / Math.pow( 2, tileSet.maxZoom - 1 );

			const xTc = ( point.x + halfMapExtent ) / tileWidth;
			const yTc = ( halfMapExtent - point.y ) / tileWidth;

			const tileX = Math.floor( xTc );
			const tileY = Math.floor( yTc );
			const tileZ = tileSet.maxZoom;

			const offsetX = xTc - tileX;
			const offsetY = yTc - tileY;
			const samples = tileSet.divisions + 1;

			const dataOffset = Math.floor( samples * offsetX ) + samples * Math.floor( samples * offsetY );

			// construct a tileSpec for passing to web worker
			return {
				x: tileX,
				y: tileY,
				z: tileZ,
				tileSet: tileSet,
				dataOffsets: [ dataOffset ],
				points: [ point ],
				request: 'height',
				clip: {}
			};

		}

	}

	// preallocated for projected area calculations

	const __a = new Vector3();
	const __b = new Vector3();
	const __c = new Vector3();
	const __d = new Vector3();

	const __t1 = new Triangle( __a, __b, __c );
	const __t2 = new Triangle( __a, __c, __d );

	const TILE_NEW      = 0;
	const TILE_PENDING  = 1;
	const TILE_ACTIVE   = 2;
	const TILE_EVICTED  = 3;
	const TILE_REPLACED = 4;
	const TILE_FAILED   = 5;

	class Tile extends Mesh {

		static liveTiles = 0;

		constructor ( ctx, x, y, zoom, tileSpec ) {

			super( new BufferGeometry(), ctx.materials.getSurfaceMaterial() );

			this.x = x;
			this.y = y;

			this.zoom    = zoom;
			this.tileSet = tileSpec.tileSet;
			this.clip    = tileSpec.clip;
			this.clippedFraction = tileSpec.clippedFraction;

			this.canZoom = ( zoom < tileSpec.tileSet.overlayMaxZoom );
			this.state = TILE_NEW;
			this.evictionCount = 0;
			this.lastFrame = 0;
			this.childrenLoading = 0;
			this.childErrors = 0;
			this.area = 0;

			this.boundingBox = null;
			this.worldBoundingBox = null;

			this.type = 'Tile';
			this.isTile = false;

		}

		onBeforeRender ( renderer ) {

			this.lastFrame = renderer.info.render.frame;

		}

		createFromTileData ( tileData, material ) {

			const attributes = tileData.attributes;
			const index = tileData.index;
			const boundingBox = tileData.boundingBox;
			const bufferGeometry = this.geometry;

			let attributeName;
			let attribute;

			// assemble BufferGeometry from binary buffer objects transfered from worker

			for ( attributeName in attributes ) {

				attribute = attributes[ attributeName ];
				bufferGeometry.setAttribute( attributeName, new Float32BufferAttribute( attribute.array, attribute.itemSize ) );

			}

			bufferGeometry.setIndex( new Uint16BufferAttribute( index, 1 ) );

			// use precalculated bounding box rather than recalculating it here.

			bufferGeometry.boundingBox = new Box3(
				new Vector3().copy( boundingBox.min ),
				new Vector3().copy( boundingBox.max ),
			);

			this.boundingBox = bufferGeometry.boundingBox;

			// discard javascript attribute buffers after upload to GPU
			this.dropBuffers();

			this.layers.set( FEATURE_TERRAIN );

			this.material = material;
			this.isTile = true;

			// handle specific tile data (Cesium has leaf status tiles)
			this.canZoom = tileData.canZoom && this.canZoom;

			// this is safe, we are already in the scene graph from .setPending()
			if ( this.worldBoundingBox === null ) {

				this.updateWorldMatrix( true, false );
				this.worldBoundingBox = this.boundingBox.clone().applyMatrix4( this.matrixWorld );

			}

			return this;

		}

		empty () {

			this.isMesh = false;

			if ( this.geometry ) {

				this.geometry.dispose();
				this.geometry = new BufferGeometry();

			}

			--Tile.liveTiles;

		}

		evict () {

			this.evictionCount = 0;
			this.state = TILE_EVICTED;

			this.children.forEach( tile => tile.evict() );
			this.empty();

		}

		setReplaced () {

			if ( this.state == TILE_REPLACED ) return;

			this.state = TILE_REPLACED;

			this.empty();

		}

		setSkipped () {

			this.parent.childrenLoading--;

			this.state = TILE_REPLACED;

		}

		setPending ( parentTile ) {

			if ( parentTile && this.parent === null ) {

				parentTile.addStatic( this );

			}

			this.parent.childrenLoading++;

			this.isMesh = false;
			this.state = TILE_PENDING;
			this.evictionCount = 0;

		}

		setFailed () {

			const parent = this.parent;

			parent.childErrors++;
			parent.childrenLoading--;
			parent.canZoom = false;

			parent.remove( this );

			this.state = TILE_FAILED;

		}

		setActive () {

			this.isMesh = true;
			this.state = TILE_ACTIVE;

			Tile.liveTiles++;

		}

		setLoaded ( overlay, renderCallback ) {

			const parent = this.parent;

			let tilesWaiting = 0;

			if ( --parent.childrenLoading === 0 ) { // this tile and all siblings loaded

				if ( parent.childErrors === 0 ) { // all loaded without error

					const siblings = parent.children;

					siblings.forEach( sibling => {

						if ( sibling.state !== TILE_PENDING ) return;

						if ( overlay === null ) {

							sibling.setActive();

						} else {

							// delay finalising until overlays loaded - avoids flash of raw surface
							tilesWaiting++;

							sibling
								.setOverlay( overlay )
								.then( () => {

									if ( --tilesWaiting === 0 ) {

										siblings.forEach( tile => {

											if ( tile.state !== TILE_PENDING ) return;

											tile.setActive();

										} );

										if ( parent.isTile ) parent.setReplaced();
										renderCallback( this.canZoom );

										return;

									}

								} );

						}

					} );

					if ( tilesWaiting === 0 ) {

						if ( parent.isTile ) parent.setReplaced();

						renderCallback( false ); // we have no overlay so don't encourage zooming

					}

					return;

				} else {

					parent.remove( this );
					renderCallback( false );

				}

			}

		}

		removed () {

			if ( this.geometry ) this.geometry.dispose();

		}

		setMaterial ( material ) {

			this.material = material;

		}

		setOverlay ( overlay ) {

			return overlay
				.getTile( this )
				.then( material => {

					if ( material !== null ) this.material = material;

					return this;

				} );

		}

		computeProjectedArea ( camera ) {

			const boundingBox = this.worldBoundingBox;
			const z = boundingBox.max.z;

			__a.copy( boundingBox.min ).setZ( z );
			__c.copy( boundingBox.max );

			__b.set( __a.x, __c.y, z );
			__d.set( __c.x, __a.y, z );

			// clamping reduces accuracy of area but stops offscreen area contributing to zoom pressure
			// .clampScalar( -1, 1 );

			__a.project( camera );
			__b.project( camera );
			__c.project( camera );
			__d.project( camera );

			this.area = ( __t1.getArea() + __t2.getArea() ) / this.clippedFraction;

			return this;

		}

	}

	const __frustum = new Frustum();
	const __matrix4 = new Matrix4();

	const __startEvent = { type: 'progress', name: 'start' };
	const __endEvent = { type: 'progress', name: 'end' };

	function __sortTilesByPressure( tileA, tileB ) {

		const zoomDiff = tileB.zoom - tileA.zoom;

		if ( zoomDiff !== 0 ) {

			return zoomDiff;

		}

		const frameDiff = tileA.lastFrame - tileB.lastFrame;

		if ( frameDiff !== 0 ) {

			return frameDiff;

		}

		const xDiff = tileA.x - tileB.x;

		return ( xDiff !== 0 ) ? xDiff : tileA.y - tileB.y;

	}

	class WebTerrain extends CommonTerrain {

		isTiled = true;
		name = 'WebTerrain';
		type = 'CV.WebTerrain';

		constructor ( ctx, survey, onLoaded ) {

			super( ctx );

			this.attributions = [];
			this.log = false;
			this.ctx = ctx;

			this.displayCRS = survey.displayCRS;
			this.surveyCRS = survey.CRS;
			this.limits = survey.limits;
			this.flatZ = survey.modelLimits.max.z;
			this.offsets = survey.offsets;

			this.onLoaded        = onLoaded;
			this.childrenLoading = 0;
			this.childErrors     = 0;
			this.isLoaded        = false;
			this.material        = null;
			this.initialZoom     = null;
			this.dying = false;
			this.tilesLoading = 0;
			this.maxTilesLoading = 0;
			this.coverage = null;
			this.TS = null;
			this.maxTiles = ctx.cfg.value( 'maxTiles', 128 );

			// tile zoom properties
			this.retile_timeout = 80;
			this.retileScaler = 4;
			this.lastActivityTime = 0;
			this.timerId = null;

			this.material = ctx.materials.getCursorMaterial();
			this.canZoom = true;

			this.watcher = this.scheduleRetile.bind( this );
			this.updateFunc = this.zoomCheck.bind( this );

			let promise;

			switch ( this.displayCRS ) {

			case 'EPSG:3857':

				promise = new EPSG3857TileSet( ctx );
				break;

			case 'EPSG:4326':
			case 'ORIGINAL':

				promise = new EPSG4326TileSet( ctx, this.surveyCRS );
				break;

			default:

				onLoaded( this );
				return;

			}

			promise.then( TS => {

				this.workerPool = ctx.workerPools.getPool( TS.workerScript() );
				this.TS = TS;
				this.tileSets = TS.getTileSets();
				this.screenAttribution = TS.getScreenAttribution();

				if ( this.hasCoverage() ) {

					this.tileArea();

				} else {

					console.log( 'no terrain found' );
					onLoaded( this );

				}

			} ).catch( () => {

				console.log( 'error loading tile set' );

			} );

			return;

		}

		hasCoverage () {

			// iterate available tileSets and pick the first match

			const limits = this.limits;
			const baseDirectory = this.ctx.cfg.value( 'terrainDirectory', '' );
			const tileSets = this.tileSets;
			const TS = this.TS;

			for ( let i = 0, l = tileSets.length; i < l; i++ ) {

				const tileSet = tileSets[ i ];

				if ( tileSet.valid === false ) continue;

				const coverage = TS.getCoverage( limits, tileSet.minZoom );

				if (
					coverage.minX >= tileSet.minX &&
					coverage.maxX <= tileSet.maxX &&
					coverage.minY >= tileSet.minY &&
					coverage.maxY <= tileSet.maxY
				) {

					tileSet.directory = baseDirectory + tileSet.subdirectory;

					TS.tileSet = tileSet;

					this.isFlat = tileSet.isFlat;
					this.log = tileSet.log === undefined ? false : tileSet.log;
					this.attributions = tileSet.attributions;

					console.log( 'selected tile set:', tileSet.title );

					return true;

				}

			}

			return false;

		}

		tileDataLoaded ( tile, tileData ) {

			--this.tilesLoading;

			// the survey/region in the viewer may have changed while the height maps are being loaded.
			// bail out in this case to avoid errors

			if ( this.dying ) {

				this.dispatchEvent( __endEvent );
				return;

			}

			if ( tileData.status === 'zoom' ) {

				tile.setSkipped();
				this.zoomTile( tile, tile.parent );

				return;

			}

			// error out early if we or other tiles have failed to load.

			if ( tileData.status !== 'ok' || tile.parent.childErrors !== 0 ) {

				tile.setFailed();

				// signal error to caller
				if ( this.tilesLoading === 0 && ! this.isLoaded ) {

					this.onLoaded( this );

				}

				this.dispatchEvent( __endEvent );

				return;

			}

			tile.createFromTileData( tileData, this.material );

			this.dispatchEvent( { type: 'progress', name: 'set', progress: 100 * ( this.maxTilesLoading - this.tilesLoading ) / this.maxTilesLoading } );

			tile.setLoaded( this.activeOverlay, canZoom => this.tileLoaded( tile, canZoom ) );

		}

		tileLoaded ( tile, canZoom ) {

			if ( canZoom && this.activeOverlay !== null && tile.zoom < this.activeOverlay.getMinZoom() ) {

				this.zoomTile( tile );

			}

			if ( this.tilesLoading !== 0 ) return;

			this.dispatchEvent( __endEvent );

			if ( ! this.isLoaded ) {

				this.isLoaded = true;
				this.onLoaded( this );

			}

		}

		loadTile ( x, y, z, parentTile, existingTile ) {

			if ( existingTile === undefined ) {

				existingTile = parentTile.children.find( function ( tile ) {
					return ( tile.x === x && tile.y === y && tile.zoom === z );
				} );

			}

			if ( existingTile?.state === TILE_PENDING ) return;

			const tileSpec = this.TS.getTileSpec( x, y, z, this.limits );

			if ( tileSpec === null ) return;

			tileSpec.offsets = this.offsets,
			tileSpec.flatZ = this.flatZ;

			if ( this.tilesLoading === 0 ) {

				this.dispatchEvent( __startEvent );
				this.maxTilesLoading = 0;

			}

			this.maxTilesLoading = Math.max( this.maxTilesLoading, ++this.tilesLoading );

			if ( !this.log ) console.log( `load: [ ${z}/${x}/${y} ]`, this.tilesLoading );

			// get Tile instance.

			const tile = existingTile ? existingTile : new Tile( this.ctx, x, y, z, tileSpec );

			tile.setPending( parentTile ); // tile load/reload pending

			this.workerPool.queueWork( tileSpec, tileData => this.tileDataLoaded( tile, tileData ) );

		}

		tileArea () {

			const limits = this.limits;
			const tileSet = this.TS.tileSet;

			let zoom = tileSet.initialZoom || tileSet.overlayMaxZoom + 1;
			let coverage;

			do {

				coverage = this.TS.getCoverage( limits, --zoom );

			} while ( coverage.count > 4 && zoom > tileSet.minZoom );


			this.initialZoom = zoom;
			this.coverage = coverage;

			for ( let x = coverage.minX; x < coverage.maxX + 1; x++ ) {

				for ( let y = coverage.minY; y < coverage.maxY + 1; y++ ) {

					this.loadTile( x, y, zoom, this );

				}

			}

		}

		tileSet () {

			const tileSet = Object.assign( {}, EPSG3857TileSet.defaultTileSet );
			const coverage = this.TS.getCoverage( this.limits, tileSet.maxZoom );

			delete tileSet.isFlat;
			delete tileSet.directory;

			tileSet.title = 'new tile set';
			tileSet.subdirectory = 'new_tile_set';

			tileSet.usedZoom = coverage.zoom;

			tileSet.minX = coverage.minX;
			tileSet.maxX = coverage.maxX;
			tileSet.minY = coverage.minY;
			tileSet.maxY = coverage.maxY;

			return dataURL( tileSet );

		}

		zoomTile ( tile, parent = tile ) {

			const zoom = tile.zoom + 1;
			const x = tile.x * 2;
			const y = tile.y * 2;

			this.loadTile( x,     y,     zoom, parent );
			this.loadTile( x + 1, y,     zoom, parent );
			this.loadTile( x,     y + 1, zoom, parent );
			this.loadTile( x + 1, y + 1, zoom, parent );

		}

		setOverlay ( overlay, overlayLoadedCallback ) {

			if ( this.tilesLoading > 0 ) return;

			const currentOverlay = this.activeOverlay;

			if ( currentOverlay !== null ) {

				if ( currentOverlay === overlay ) return;

				currentOverlay.setInactive();

			}

			overlay.setActive();

			this.activeOverlay = overlay;

			const overlayMinZoom = overlay.getMinZoom();
			let overlaysLoading = 0;

			this.traverse( tile => {

				if ( tile.state !== TILE_ACTIVE  ) return;

				if ( tile.zoom < overlayMinZoom ) {

					// no overlay for this zoom layer, zoom to next level
					this.zoomTile( tile );

				} else {

					overlaysLoading++;
					tile
						.setOverlay( overlay )
						.then(
							() => { if ( --overlaysLoading === 0 ) overlayLoadedCallback(); }
						);

				}

			} );

		}

		removed () {

			this.dying = true;

			this.traverse( obj => { if ( obj !== this ) obj.removed( obj ); } );

			this.commonRemoved();

		}

		setMaterial ( material ) {

			if ( this.tilesLoading > 0 ) return;

			this.traverse( obj => { if ( obj.isTile ) obj.setMaterial( material ); } );

			this.activeOverlay = null;

			material.needsUpdate = true;
			material.fog = false;

			this.material = material;

		}

		zoomCheck ( cameraManager ) {

			if ( this.tilesLoading > 0 || performance.now() - this.lastActivityTime < this.retile_timeout ) return;

			const frustum = __frustum;
			const camera = cameraManager.activeCamera;
			const lastFrame = cameraManager.getLastFrame();

			const candidateTiles      = [];
			const candidateEvictTiles = [];
			const resurrectTiles      = [];

			let retry = false;

			frustum.setFromProjectionMatrix( __matrix4.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse ) );

			// scan scene graph of terrain

			this.traverse( _scanTiles );

			const resurrectCount = resurrectTiles.length;
			const candidateCount = candidateTiles.length;
			const candidateEvictionCount = candidateEvictTiles.length;

			// evict offsreen tiles

			let evictTarget = Tile.liveTiles - this.maxTiles;

			if ( Math.min( candidateEvictionCount, evictTarget ) > 0 ) {

				candidateEvictTiles.sort( __sortTilesByPressure );

				const now = performance.now();
				const l = candidateEvictTiles.length;

				for ( let i = 0; i < l; i++ ) {

					const tile = candidateEvictTiles[ i ];

					if ( tile.evictionCount === 0 ) {

						tile.evictionCount = now;

					} else if ( now - tile.evictionCount > 1000 ) {

						tile.evict();
						if ( --evictTarget ) break;

					}

				}

			}

			if ( resurrectCount !== 0 ) {

				// resurrect old tiles

				for ( let i = 0; i < resurrectCount; i++ ) {

					const tile = resurrectTiles[ i ];

					// reload tile (use exiting tile object to preserve canZoom).
					this.loadTile( tile.x, tile.y, tile.zoom, tile.parent, tile );

				}

				retry = true;

			} else if ( candidateCount !== 0 ) {

				// or zoom into area

				for ( let i = 0; i < candidateCount; i++ ) {

					this.zoomTile( candidateTiles[ i ] );

				}

				retry = true;

			}

			if ( retry ) {

				this.timerId = setTimeout( this.updateFunc, this.retile_timeout * this.retileScaler, cameraManager );
				this.retileScaler *= 2;

			}

			return;

			function _scanTiles( tile ) {

				const parent = tile.parent;

				if ( ! tile.isTile || ! parent.canZoom || tile.state === TILE_PENDING ) return;

				if ( tile.isMesh && tile.canZoom && tile.lastFrame === lastFrame ) {

					// this tile intersects the screen

					// this tile is loaded, maybe increase resolution?
					// now safe if tile has evicted children or not

					tile.computeProjectedArea( camera );
					if ( tile.area / 4 > 0.81 ) candidateTiles.push( tile );

				} else if ( ! parent.isMesh && tile.state == TILE_EVICTED && frustum.intersectsBox( tile.worldBoundingBox ) ) {

					// this tile is not loaded, but has been previously

					// flag subtiles to prevent premature resurrection
					// and indicate replaced by superior

					tile.traverse( function ( subtile ) {

						if ( subtile === tile ) return; // ignore this tile
						subtile.setReplaced();

					} );

					resurrectTiles.push( tile );

				} else {

					// off screen tile
					if ( tile.isMesh && tile.lastFrame !== lastFrame ) candidateEvictTiles.push( tile );

				}

			}

		}

		getHeights ( points, callback ) {

			const tileSet = this.TS;
			const tileSpecs = {};
			const results = [];

			// sort points in to requests per tile

			points.forEach( function ( point, i ) {

				const tileSpec = tileSet.findTile( point );
				const key = `${tileSpec.x}:${tileSpec.y}:${tileSpec.z}`;
				// index used to map point height results with starting points.
				point.index = i;

				if ( tileSpecs[ key ] === undefined ) {

					// new tile query
					tileSpecs[ key ] = tileSpec;

				} else {

					// merge requested point with existing query
					tileSpecs[ key ].dataOffsets.push( tileSpec.dataOffsets[ 0 ] );
					tileSpecs[ key ].points.push( tileSpec.points[ 0 ] );

				}

			} );

			// dispatch requests

			let requestCount = 0;

			for ( const key in tileSpecs ) {

				this.workerPool.queueWork( tileSpecs[ key ], _mapLoaded );
				requestCount++;

			}

			return;

			function _mapLoaded ( data ) {

				const resultPoints = data.points;

				resultPoints.forEach( point => results[ point.index ] = point );

				if ( --requestCount === 0 ) {

					callback( results );

				}

			}

		}

		fitSurface ( modelPoints, offsets ) {

			if ( this.TS.findTile === undefined ) {

				this._fitSurface( modelPoints );
				return;

			}

			// adjust to geographical values
			const points = modelPoints.map( point => point.clone().add( offsets) );

			this.getHeights( points, ret => {

				let n = 0, s1 = 0, s2 = 0;

				ret.forEach( a => {

					const v = points[ a.index ].z - a.z;
					s1 += v;
					s2 += v * v;
					n++;

				} );

				const sd = Math.sqrt( s2 / n - Math.pow( s1 / n, 2 ) );

				// simple average
				// this.datumShift = s1 / n;
				// hack to update ui async
				this.ctx.viewer.terrainDatumShiftValue = s1 / n;

				console.log( `Adjustmenting terrain height by: ${this.datumShift} sd: ${sd} n: ${n}` );


			} );

		}

		scheduleRetile ( event ) {

			if ( ! this.visible ) return;

			if ( this.timerId !== null ) clearTimeout( this.timerId );

			this.retileScaler = 4;
			this.lastActivityTime = performance.now();
			this.timerId = setTimeout( this.updateFunc, this.retile_timeout, event.cameraManager );

		}

		watch ( obj ) {

			obj.addEventListener( 'moved', this.watcher );

		}

		unwatch ( obj ) {

			obj.removeEventListener( 'moved', this.watcher );

		}

	}

	const cpuCount = window.navigator.hardwareConcurrency;

	class WorkerPool {

		static pendingWork = [];
		static activeWorkerCount = 0;
		static maxActive = cpuCount === undefined ? 4 : cpuCount;

		constructor ( script ) {

			this.script = script;
			this.workers = [];
			this.activeWorkers = new Set();

		}

		terminateActive () {

			const activeWorkers = this.activeWorkers;

			activeWorkers.forEach( worker => worker.terminate() );
			activeWorkers.clear();

			// remove any pending work for this pool
			WorkerPool.pendingWork = WorkerPool.pendingWork.filter( p => p.pool != this );

			// remove all the saved workers onmessage handlers to remove references to callbacks
			// which may enclose objects and prevent GC
			this.workers.forEach( w => { w.onmessage = null; } );

		}

		getWorker () {

			let worker;

			if ( this.workers.length === 0 ) {

				worker = new Worker( this.script );

			} else {

				worker = this.workers.pop();

			}

			this.activeWorkers.add( worker );

			worker.pool = this;

			return worker;

		}

		putWorker ( worker ) {

			this.activeWorkers.delete( worker );
			WorkerPool.activeWorkerCount--;

			if ( this.workers.length < 4 ) {

				this.workers.push( worker );

			} else {

				worker.terminate();

			}

			const pendingWork = WorkerPool.pendingWork;

			if ( pendingWork.length > 0 ) {

				const pending = pendingWork.shift();

				// resubmit to orginal pool

				pending.pool.queueWork( pending.message, pending.callback );

			}

		}

		runWorker ( message, callback ) {

			WorkerPool.activeWorkerCount++;
			const worker = this.getWorker();

			worker.onmessage = e => {

				worker.pool.putWorker( worker );
				callback( e.data );

			};

			worker.postMessage( message );

			return worker;

		}

		queueWork ( message, callback ) {

			if ( WorkerPool.activeWorkerCount >= WorkerPool.maxActive ) {

				WorkerPool.pendingWork.push( { pool: this, message: message, callback: callback } );
				return;

			}

			this.runWorker( message, callback );

		}

		dispose () {

			this.workers.forEach( worker => worker.terminate() );

			this.workers = null;
			this.activeWorkers = null;

		}

	}


	class WorkerPoolCache {

		constructor ( cfg ) {

			const pools = new Map();

			this.getPool = function ( scriptFile ) {

				const script = cfg.value( 'home', '' ) + 'js/workers/' + scriptFile;

				let pool = pools.get( script );

				if ( pool === undefined ) {

					// no existing pool
					pool = new WorkerPool( script );
					pools.set( script, pool );

				}

				return pool;

			};

			this.terminateActive = function () {

				pools.forEach( pool => pool.terminateActive() );

			};

			this.dispose = function () {

				pools.forEach( pool => {

					pool.terminateActive();
					pool.dispose();

				} );

				pools.clear();

			};

		}

	}

	class CaveViewer extends EventDispatcher {

		constructor ( domID, configuration ) {

			super();
			console.log( 'CaveView v' + VERSION );

			const container = document.getElementById( domID );

			if ( ! container ) throw new Error( 'No container DOM object [' + domID + '] available' );

			this.container = container;

			const cfg = new Cfg( configuration );

			// target with css for fullscreen on small screen devices
			container.classList.add( 'cv-container' );
			container.style.backgroundColor = cfg.themeColorCSS( 'background' );


			const ctx = {
				cfg: cfg,
				container: container,
				workerPools: new WorkerPoolCache ( cfg ),
				glyphStringCache: new Map(),
				materials: null,
				viewer: this,
				renderUtils: new RenderUtils()
			};

			this.ctx = ctx;

			const materials = new Materials( this );

			ctx.materials = materials;

			let renderer = new WebGLRenderer( { antialias: true, alpha: true } );

			resetRenderer();

			updatePixelRatio();

			renderer.clear();
			renderer.autoClear = false;

			container.appendChild( renderer.domElement );

			const fog = new FogExp2( cfg.themeColorCSS( 'background' ), 0.0025 );

			const scene = new Scene();
			scene.fog = fog;
			scene.name = 'CV.Viewer';

			const cameraManager = new CameraManager( ctx, renderer, scene );

			// setup lighting
			const lightingManager = new LightingManager( ctx, scene );

			// setup controllers
			const controls = new OrbitControls( cameraManager, renderer.domElement, this );

			this.getControls = function () { return controls; };

			controls.maxPolarAngle = cfg.themeAngle( 'maxPolarAngle' );
			controls.addEventListener( 'change', onCameraMoved );
			controls.addEventListener( 'end', onCameraMoveEnd );

			const cameraMove = new CameraMove( controls, onCameraMoved );
			this.cameraMove = cameraMove;

			const moveEndEvent = { type: 'moved', cameraManager: cameraManager };
			const pointerControls = new PointerControls( ctx, renderer.domElement );

			let publicFactory = null;

			const mouse = new Vector2();
			const raycaster = new Raycaster();

			raycaster.layers.enableAll();
			raycaster.params.Points.threshold = 20;

			let terrain = null;
			let survey = null;

			let useFog = false;

			let renderRequired = true;
			let clipped = false;

			// preallocated tmp objects

			const __v = new Vector3();
			const self = this;

			let savedView = null;
			let mouseOver = false;

			// event handler
			window.addEventListener( 'resize', onResize );

			Object.defineProperties( this, {

				'mouseOver': {
					get() { return mouseOver; }
				},

				'reset': {
					set() { setupView( false ); }
				},

				'surveyLoaded': {
					get() { return ( survey !== null ); }
				},

				'terrain': {
					get() { return cameraManager.testCameraLayer( FEATURE_TERRAIN ); },
					set: loadTerrain,
					enumerable: true
				},

				'stationLabelOver': {
					get() { return pointerControls.getStationNameLabelMode(); },
					set: x => { pointerControls.setStationNameLabelMode( x ); },
					enumerable: true
				},

				'terrainShading': {
					get() { return terrain !== null ? terrain.shadingMode : null; },
					set: stateSetter( setTerrainShadingMode, 'terrainShading'),
					enumerable: true
				},

				'hasTerrain': {
					get() { return !! terrain; }
				},

				'hasRealTerrain': {
					get() { return ( terrain && ! terrain.isFlat ); }
				},

				'terrainAttributions': {
					get() { return terrain !== null ? terrain.attributions : []; }
				},

				'terrainDirectionalLighting': {
					get() { return ( lightingManager.lightingMode !== LM_NONE ); },
					set: x => { lightingManager.lightingMode = x ? LM_SINGLE : LM_NONE; }
				},

				'terrainLightingMode': {
					get() { return lightingManager.lightingMode; },
					set: stateSetter( mode => { lightingManager.lightingMode = mode; }, 'terrainLightingMode' ),
					enumerable: true
				},

				'terrainShadingModes': {
					get() { return terrain !== null ? terrain.terrainShadingModes : {}; }
				},

				'terrainTileSet': {
					get() { return terrain?.tileSet.bind( terrain ); }
				},

				'terrainDatumShift': {
					get() { return !! terrain?.activeDatumShift; },
					set: stateSetter( x => { terrain?.applyDatumShift( x ); }, 'terrainDatumShift' ),
					enumerable: true
				},

				'terrainDatumShiftValue': {
					get() { return Math.round( terrain.datumShift ); },
					set: stateSetter( x => { terrain.datumShift = x; }, 'terrainDatumShiftValue' )
				},

				'terrainOpacity': {
					get() { return ( terrain !== null ) ? terrain.getOpacity() : 0; },
					set: stateSetter( x => { terrain?.setOpacity( x ); }, 'terrainOpacity' ),
					enumerable: true
				},

				'shadingMode': {
					get() { return survey?.caveShading; },
					set: stateSetter( mode => survey.setShadingMode( mode, false ), 'shadingMode' ),
					enumerable: true
				},

				'hideMode': {
					get() { return survey?.hideMode; },
					set: x => { survey.setHideMode( x ); renderView(); }
				},

				'flatShading': {
					get() { return survey?.wallsMode; },
					set: x => { survey.setWallsMode( x ); renderView(); },
					enumerable: true
				},

				'route': {
					get() { return survey?.getRoutes().setRoute; },
					set: x => { survey.getRoutes().setRoute = x; }
				},

				'routeNames': {
					get() { return survey?.getRoutes().getRouteNames(); },
				},

				'surfaceShading': {
					get() { return survey?.surfaceShading; },
					set: stateSetter( mode => survey.setSurfaceShading( mode ), 'surfaceShading' ),
					enumerable: true
				},

				'duplicateShading': {
					get() { return survey?.duplicateShading; },
					set: stateSetter( mode => survey.setDuplicateShading( mode ), 'duplicateShading' ),
					enumerable: true
				},

				'cameraType': {
					get() { return cameraManager.mode; },
					set: stateSetter( mode => cameraManager.setCamera( mode, controls.target ), 'cameraType' ),
					enumerable: true
				},

				'eyeSeparation': {
					get() { return cameraManager.eyeSeparation; },
					set: stateSetter( x => { cameraManager.eyeSeparation = x; }, 'eyeSeparation' )
				},

				'view': {
					get() { return VIEW_PLAN; },
					set: stateSetter( setViewMode, 'view' ),
					enumerable: true
				},

				'cursorHeight': {
					get() { return materials.cursorHeight; },
					set: stateSetter( x => { materials.cursorHeight = x; }, 'cursorHeight' )
				},

				'linewidth': {
					get() { return ( materials.linewidth - 1 ) / 10; },
					set: stateSetter( x => { materials.linewidth = x * 10 + 1; }, 'linewidth' ),
					enumerable: true
				},

				'scaleLinewidth': {
					get() { return materials.scaleLinewidth; },
					set: stateSetter( x => { materials.scaleLinewidth = !! x; }, 'scaleLinewidth' )
				},

				'maxDistance': {
					get() { return ( survey === null ) ? 0 :  survey.getMaxDistance(); }
				},

				'maxHeight': {
					get() { return ( survey === null ) ? 0 : survey.limits.max.z; }
				},

				'minHeight': {
					get() { return ( survey === null ) ? 0 : survey.limits.min.z; }
				},

				'section': {
					get() { return ( survey === null ) ? null : survey.selection.getNode(); },
					set: stateSetter( selectSection, 'section' )
				},

				'sectionByName': {
					get: () => survey?.selection.getName(),
					set: name => { selectSection( survey.selection.getByName( name ) ); }
				},

				'popup': {
					set: x => { pointerControls.setPopup( x ); }
				},

				'highlight': {
					set: stateSetter( node => survey.highlightSelection( node ), 'highlight' )
				},

				'polarAngle': {
					get() { return controls.getPolarAngle(); },
					set: x => { cameraMove.setPolarAngle( x ); }
				},

				'azimuthAngle': {
					set: x => { cameraMove.setAzimuthAngle( x ); }
				},

				'editMode': {
					get() { return pointerControls.getEditMode(); },
					set: stateSetter( x => { pointerControls.setEditMode( x ); }, 'editMode' )
				},

				'setPOI': {
					set: stateSetter( () => cameraMove.start( true ), 'setPOI' )
				},

				'HUD': {
					get() { return hud.getVisibility(); },
					set: x => { hud.setVisibility( x ); },
					enumerable: true
				},

				'cut': {
					set: cutSection
				},

				'zScale': {
					get() { return survey?.zScale; },
					set: stateSetter( x => { survey.zScale = x; }, 'zScale' ),
					enumerable: true
				},

				'autoRotate': {
					get() { return controls.autoRotate; },
					set: stateSetter( x => cameraMove.setAutoRotate( !! x ), 'autoRotate' )
				},

				'wheelTilt': {
					get() { return controls.wheelTilt; },
					set( x ) {
						controls.wheelTilt = !! x;
						self.dispatchEvent( { type: 'change', name: 'wheelTilt' } );
					},
					enumerable: true
				},

				'svxControlMode': {
					get() { return controls.svxControlMode; },
					set( x ) {
						controls.svxControlMode = !! x;
						// force refresh of help tab
						self.dispatchEvent( { type: 'newCave', name: 'newCave' } );
					},
					enumerable: true
				},

				'zoomToCursor': {
					get() { return controls.zoomToCursor; },
					set( x ) {
						controls.zoomToCursor = !! x;
						self.dispatchEvent( { type: 'change', name: 'zoomToCursor' } );
					},
					enumerable: true
				},

				'autoRotateSpeed': {
					get() { return controls.autoRotateSpeed / 11; },
					set: stateSetter( setAutoRotateSpeed, 'autoRotateSpeed' )
				},

				'fullscreen': {
					get: isFullscreen,
					set: setFullscreen
				},

				'fog': {
					get() { return useFog; },
					set: stateSetter( setFog, 'fog' ),
					enumerable: true
				},

				'isClipped': {
					get() { return clipped; }
				},

				'maxSnapshotSize': {
					get() {
						const context = renderer.getContext();
						return context.getParameter( context.MAX_RENDERBUFFER_SIZE );
					}
				},

				'focalLength': {
					get() { return cameraManager.focalLength; },
					set: setFocalLength,
					enumerable: true
				}
			} );

			enableLayer( FEATURE_BOX,       'box' );
			enableLayer( FEATURE_ENTRANCES, 'entrances' );
			enableLayer( FEATURE_ENTRANCE_DOTS, 'entrance_dots' );
			enableLayer( FEATURE_STATIONS,  'stations' );
			enableLayer( FEATURE_TRACES,    'traces' );
			enableLayer( FEATURE_GRID,      'grid' );
			enableLayer( FACE_SCRAPS,       'scraps' );
			enableLayer( FACE_WALLS,        'walls' );
			enableLayer( LEG_CAVE,          'legs' );
			enableLayer( LEG_SPLAY,         'splays' );
			enableLayer( LEG_SURFACE,       'surfaceLegs' );
			enableLayer( LEG_DUPLICATE,     'duplicateLegs' );
			enableLayer( LABEL_STATION,     'stationLabels' );
			enableLayer( LABEL_STATION_COMMENT, 'stationComments' );
			enableLayer( SURVEY_WARNINGS,     'warnings' );

			container.addEventListener( 'pointerover', onPointerOver );
			container.addEventListener( 'pointerleave', onPointerLeave );

			container.addEventListener( 'fullscreenchange', onFullscreenChange );
			container.addEventListener( 'webkitfullscreenchange', onFullscreenChange );

			this.addEventListener( 'change', viewChanged );

			cfg.addEventListener( 'colors', () => {

				container.style.backgroundColor = cfg.themeColorCSS( 'background' );
				renderer.setClearColor( cfg.themeColor( 'background' ), 0.0 );

				if ( survey ) survey.refreshColors();

				renderView();

			} );

			function onPointerOver () { mouseOver = true; }

			function onPointerLeave () { mouseOver = false; }

			function viewChanged( event ) {

				if ( survey !== null && event.name === 'splays' ) {

					survey.stations.setSplaysVisibility( self.splays );

				}

			}

			const hud = new HUD( this, renderer );

			const caveLoader = new CaveLoader( ctx, caveLoaded );

			hud.getProgressDial( 0 ).watch( caveLoader );

			const viewState = new ViewState( cfg, this );

			this.renderView = renderView;

			onResize();

			function enableLayer ( layerTag, name ) {

				Object.defineProperty( self, name, {
					get() { return cameraManager.testCameraLayer( layerTag ); },
					set( x ) {

						if ( cameraManager.setCameraLayer( layerTag, x ) ) {

							self.dispatchEvent( { type: 'change', name: name } );

						}

						renderView();
					},
					enumerable: true
				} );

				const hasName = 'has' + name.substr( 0, 1 ).toUpperCase() + name.substr( 1 );

				Object.defineProperty( self, hasName, {
					get() { return survey.hasFeature( layerTag ); }
				} );

			}

			function stateSetter ( modeFunction, name ) {

				return function ( newMode ) {

					modeFunction( isNaN( newMode ) ? newMode : Number( newMode ) );

					self.dispatchEvent( { type: 'change', name: name, value: newMode } );

					renderView();

				};

			}

			function resetRenderer () {

				renderer.setSize( container.clientWidth, container.clientHeight );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setClearColor( cfg.themeColor( 'background' ), 0.0 );
				renderer.setClearAlpha( 0.0 );
				renderer.setRenderTarget( null );

			}

			function updatePixelRatio() {

				const pr = window.devicePixelRatio;
				renderer.setPixelRatio( pr );

				matchMedia( `(resolution: ${pr}dppx)` ).addEventListener( 'change', updatePixelRatio, { once: true } );

			}

			function isFullscreen () {

				return (
					window.innerHeight === container.clientHeight &&
					window.innerWidth === container.clientWidth
				);

			}

			function onFullscreenChange () {

				if ( document.fullscreenElement || document.webkitFullscreenElement ) {

					container.classList.add( 'toggle-fullscreen' );

				} else {

					container.classList.remove( 'toggle-fullscreen' );

				}

				onResize();
				self.dispatchEvent( { type: 'change', name: 'fullscreen' } );

			}

			function setFullscreen ( targetState ) {

				if ( isFullscreen() === targetState ) return;

				if ( targetState ) {

					container.classList.add( 'toggle-fullscreen' );

					if ( document.fullscreenElement === null ) {

						container.requestFullscreen();

					} else if ( document.webkitFullscreenElement === null) {

						container.webkitRequestFullscreen();

					}

				} else {

					container.classList.remove( 'toggle-fullscreen' );

					if ( document.fullscreenElement ) {

						document.exitFullscreen();

					} else if ( document.webkitFullscreenElement ) {

						if ( document.webkitExitFullscreen ) {

							document.webkitExitFullscreen();

						} else if ( document.webkitCancelFullScreen ) {

							document.webkitCancelFullScreen();

						}

					}

				}

			}

			function setAutoRotateSpeed ( speed ) {

				controls.autoRotateSpeed = Math.max( Math.min( speed, 1.0 ), -1.0 ) * 11;

			}

			function setTerrainShadingMode ( mode ) {

				if ( terrain === null ) return;

				terrain.setShadingMode( mode, renderView );

				if ( terrain.isTiled ) terrain.zoomCheck( cameraManager );

			}


			function setupTerrain ( newTerrain ) {

				if ( newTerrain.isLoaded ) {

					terrain = newTerrain;

					terrain.setup( renderer, scene, survey );

					if ( terrain.isTiled ) {

						terrain.addEventListener( 'progress', onEnd );
						terrain.watch( self );

					}

				}

				setScale();
				setupView( true );

			}

			function setFocalLength( f ) {

				const fChange = f / cameraManager.focalLength;

				cameraManager.focalLength = f;

				// adjust camera position to maintain view
				controls.scaleDolly( fChange );

			}

			function onCameraMoved () {

				if ( survey === null ) return;

				lightingManager.setRotation( cameraManager.getRotation() );

				if ( cameraManager.activeCamera.isOrthographicCamera ) {

					ctx.materials.scale =  cameraManager.activeCamera.zoom * survey.scale.z;

				}

				renderView( true );

			}

			function setViewMode ( mode ) {

				const targetAxis = __v;

				switch ( mode ) {

				case VIEW_NONE:

					return;

				case VIEW_PLAN:

					targetAxis.set( 0, 0, -1 );

					break;

				case VIEW_ELEVATION_N:

					targetAxis.set( 0, 1, 0 );

					break;

				case VIEW_ELEVATION_S:

					targetAxis.set( 0, -1, 0 );

					break;

				case VIEW_ELEVATION_E:

					targetAxis.set( 1, 0, 0 );

					break;

				case VIEW_ELEVATION_W:

					targetAxis.set( -1, 0, 0 );

					break;

				default:

					console.warn( 'invalid view mode specified: ', mode );
					return;

				}

				cameraMove.prepare( survey.getWorldBoundingBox(), targetAxis );
				cameraMove.start( renderRequired );

			}

			function setFog ( enable ) {

				useFog = enable;
				fog.density = useFog ? 0.0025 : 0;

			}

			this.addOverlay = function ( name, overlayProvider ) {

				CommonTerrain.addOverlay( ctx, name, overlayProvider );

			};

			this.addFormatters = function ( stationFormatter ) {

				pointerControls.formatters.station = stationFormatter;

			};

			function cutSection () {

				const selection = survey.selection;

				if ( selection.isEmpty() || selection.isStation() ) return;

				cameraMove.cancel();

				survey.remove( terrain );
				survey.cutSection( selection.getNode() );

				// grab a reference to prevent survey being destroyed in clearView()
				const cutSurvey = survey;

				savedView = viewState.getState();

				// reset view
				self.clearView();

				clipped = true;

				loadSurvey( cutSurvey );

				// move to plan view - required to set zoom limits atm
				cameraMove.prepare( survey.getWorldBoundingBox(), __v.set( 0, 0, -1 ) );
				cameraMove.start( false );

			}

			function selectSection ( node ) {

				if ( node.isStation() ) {

					if ( pointerControls.getEditMode() === MOUSE_MODE_TRACE_EDIT ) {

						pointerControls.selectTraceStation( node );

					} else {

						survey.selectStation( node );

						cameraMove.preparePoint( survey.getWorldPosition( node.clone() ) );

					}

				} else {

					survey.selectSection( node );

					cameraMove.cancel();
					cameraMove.prepare( survey.selection.getWorldBoundingBox() );

					if ( survey.selection.isEmpty() ) cameraMove.start( renderRequired );

				}

			}

			function onResize () {

				// adjust the renderer to the new canvas size
				const w = container.clientWidth;
				const h = container.clientHeight;

				renderer.setSize( w, h );

				self.dispatchEvent( { type: 'resized', name: 'rts', 'width': w, 'height': h } );

				renderView();

			}

			this.addPlugin = function ( plugin ) {

				new plugin( ctx, renderer, scene );

			};

			this.clearView = function () {

				// clear the current cave model, and clear the screen
				renderer.clear();

				hud.setVisibility( false );

				// terminate all running workers (tile loading/wall building etc)
				ctx.workerPools.terminateActive();

				if ( terrain && terrain.isTiled ) {

					terrain.unwatch( self );

				}

				scene.remove( survey );

				controls.enabled = false;

				survey  = null;
				terrain = null;

				cameraManager.resetCameras();

				controls.reset();

				this.dispatchEvent( { type: 'clear' } );

			};

			this.loadSource = function ( source, section ) {

				caveLoader.loadSource( source, section );

				clipped = ( section !== null && section !== '' );

			};

			this.loadCave = function ( file, section ) {

				this.loadSource( new ModelSource( [ { name: file } ], false ), section );

			};

			this.loadCaves = function ( files ) {

				caveLoader.loadSource( ModelSource.makeModelSourceFiles( files ) );

			};

			function caveLoaded ( cave ) {

				if ( ! cave ) {

					alert( 'failed loading cave information' );
					return;

				}

				onResize();

				try {

					loadSurvey( new Survey( ctx, cave ) );

				} catch ( e ) {

					alert( e );

				}

			}

			this.setView = function ( properties ) {

				// don't render until all settings made.

				renderRequired = false;

				Object.assign( this, properties );

				renderRequired = true;

				renderView();

			};

			this.saveView = function () {

				viewState.saveState();

			};

			this.resetView = function () {

				viewState.clear();
				this.setView( viewState.getDefaultState() );

			};

			this.getView = function () {

				return viewState.getState();

			};

			function setupView ( final ) {

				if ( savedView === null ) {

					self.setView( viewState.getDefaultState() );

				} else {

					self.setView( savedView );

				}

				if ( final ) {

					savedView = null;
					// signal any listeners that we have a new cave

					self.dispatchEvent( { type: 'newCave', name: 'newCave', survey: survey } );

					controls.setLimits( survey.combinedLimits.getSize( __v ) );

				}

			}

			function loadSurvey ( newSurvey ) {

				// only render after first SetupView()
				renderRequired = false;

				survey = newSurvey;

				hud.getProgressDial( 1 ).watch( survey );

				setScale();

				materials.flushCache();
				publicFactory = new PublicFactory( survey );

				scene.addStatic( survey );
				scene.matrixAutoUpdate = false;

				controls.enabled = true;

				survey.getRoutes().addEventListener( 'changed', onSurveyChanged );
				survey.addEventListener( 'changed', onSurveyChanged );

				self.dispatchEvent( { type: 'newSurvey', name: 'newSurvey', survey: survey, publicFactory: publicFactory } );

				// have we got built in terrain
				let terrain = survey.terrain;

				if ( terrain !== null ) {

					setupTerrain( terrain );

				} else if ( navigator.onLine ) {

					terrain = new WebTerrain( ctx, survey, setupTerrain );

					hud.getProgressDial( 0 ).watch( terrain );

					setupView( false );

				} else {

					setupView( true );

				}

			}

			function onEnd ( event ) {

				if ( event.name === 'end' ) renderView();

			}

			function onSurveyChanged ( /* event */ ) {

				survey.setShadingMode( survey.caveShading );

			}

			function loadTerrain ( mode ) {

				if ( terrain !== null ) {

					terrain.setVisibility( mode );

					cameraManager.setCameraLayer( FEATURE_TERRAIN, mode );

					self.dispatchEvent( { type: 'change', name: 'terrain' } );

					renderView();

				}

			}

			function renderView ( autorotate = false ) {

				if ( ! renderRequired || renderer.xr.isPresenting ) return;

				// ignore render requests if we are autorotating so don't need
				// extra render calls

				if ( controls.autoRotate && ! autorotate ) return;

				renderer.clear();

				if ( survey !== null ) {

					survey.update( cameraManager, controls.target );

					if ( useFog ) materials.setFog( true );

					cameraManager.activeRenderer();

				}

				if ( useFog ) materials.setFog( false );

				hud.renderHUD();

			}

			this.selectSection = selectSection;
			this.resetRenderer = resetRenderer;
			this.renderView = renderView;
			this.resize = onResize;

			function onCameraMoveEnd () {

				self.dispatchEvent( moveEndEvent );

			}

			function setScale () {

				const range = survey.combinedLimits.getSize( __v );

				let hScale = Math.min( container.clientWidth / range.x, container.clientHeight / range.y );

				if ( hScale === Infinity ) hScale = 1;

				// scaling to compensate distortion introduced by projection ( x and y coords only ) - approx only
				const vScale = hScale * survey.scaleFactor;

				survey.setScale( hScale, vScale );

				hud.setScale( vScale );

			}

			this.getMouse = function ( x, y ) {

				const boundingRect = container.getBoundingClientRect();

				mouse.set(
					( ( x - boundingRect.left ) / container.clientWidth ) * 2 - 1,
					- ( ( y - boundingRect.top ) / container.clientHeight ) * 2 + 1
				);

				return mouse;

			};

			this.getStationUnderMouse = function ( mouse, station ) {

				if ( survey === null ) return null;

				this.setRaycaster( raycaster, mouse );

				const hit = raycaster.intersectObject( survey.stations, false )[ 0 ];

				return ( hit !== undefined ) ? survey.getWorldPosition( station.copy( hit.station ) ) : null;

			};

			this.setRaycaster = function ( raycaster, mouse ) {

				raycaster.setFromCamera( mouse, cameraManager.activeCamera );

			};

			this.getLegStats = function ( type ) {

				const legs = survey.getFeature( type );

				return ( legs !== undefined ) ? legs.stats : {
					legs: 0,
					legLength: 0,
					minLegLength: 0,
					maxLegLength: 0
				};

			};

			this.getMetadata = function () {

				return survey.metadata;

			};

			this.getGLTFExport = function ( selection, options, callback ) {

				new ExportGltf( ctx, survey, selection, options, callback );

			};

			this.getSurveyTree = function () {

				return survey.surveyTree;

			};

			this.getStation = function ( path ) {

				const node = survey.surveyTree.getByPath( path );

				if ( node && node.isStation() && node.connections > 0 ) {

					return publicFactory.getStation( node );

				} else {

					return null;

				}

			};

			this.showImagePopup = function ( event, imageUrl ) {

				pointerControls.showImagePopup( event, imageUrl );

			};

			this.getSnapshot = function ( exportSize, lineScale ) {

				return new Snapshot( ctx, renderer ).getSnapshot( exportSize, lineScale );

			};

			this.forEachStation = function ( callback ) {

				survey.stations.forEach( station => callback( publicFactory.getStation( station ) ) );

			};

			this.forEachLeg = function ( callback ) {

				const legs = survey.getFeature( LEG_CAVE );
				legs.forEachLeg( legId => callback( publicFactory.getLeg( legId ) ) );

			};

			this.dispose = function () {

				this.dispatchEvent( { type: 'dispose' } );

				ctx.workerPools.dispose();
				scene.remove( survey );
				controls.dispose();
				hud.dispose();

				ctx.glyphStringCache = null;
				ctx.cfg = null;
				ctx.workerPools = null;
				ctx.materials = null;
				ctx.container = null;

				window.removeEventListener( 'resize', onResize );

				container.removeChild( renderer.domElement );

				container.removeEventListener( 'pointerover', onPointerOver );
				container.removeEventListener( 'pointerleave', onPointerLeave );

				container.removeEventListener( 'fullscreenchange', onFullscreenChange );
				container.removeEventListener( 'webkitfullscreenchange', onFullscreenChange );

				renderer.clear();
				renderer.dispose();

				renderer = null;

			};

		}

	}

	class Page {

		constructor ( id, x18nPrefix, onTop, onLeave ) {

			const tab  = document.createElement( 'div' );
			const page = document.createElement( 'div' );

			page.classList.add( 'page' );

			tab.classList.add( id );
			tab.classList.add( 'tab' );

			this.page = page;
			this.tab = tab;
			this.onTop = onTop;
			this.frame = null;
			this.onLeave = onLeave;
			this.slide = undefined;
			this.x18nPrefix = x18nPrefix + '.';
			this.onChange = null;
			this.id = id;
			this.lastScrollY = 0;

		}

		i18n ( text ) {

			const cfg = this.frame.ctx.cfg;
			const tr = cfg.i18n( this.x18nPrefix + text );

			return ( tr === undefined ) ? text : tr;

		}

		addListener ( obj, name, handler ) {

			this.frame.addListener( obj, name, handler );
			// redirect to frame method - allows later rework to page specific destruction

		}

		tabHandleClick ( event ) {

			event.preventDefault();
			event.stopPropagation();

			this.open();

		}

		open () {

			const thisTab = this.tab;
			const pages = this.frame.pages;
			const frameDiv = this.frame.frame;

			thisTab.classList.add( 'toptab' );

			this.frame.onScreen( this.i18n( 'title' ) );
			this.frame.openPageId = this.id;

			pages.forEach( page => {

				const pageDiv = page.page;
				const tabDiv = page.tab;
				const owner = page.owner;

				if ( tabDiv !== thisTab ) {

					if ( tabDiv.classList.contains( 'toptab' ) ) {

						// previously open page
						owner.lastScrollY = frameDiv.scrollTop;
						tabDiv.classList.remove( 'toptab' );

						if ( owner.id !== this.id && owner.onLeave !== undefined ) owner.onLeave();

					}

					pageDiv.style.display = 'none';

				}

			} );

			this.page.style.display = 'block';
			frameDiv.scrollTo( 0, this.lastScrollY );

			if ( this.onTop ) this.onTop();

		}

		appendChild ( domElement ) {

			this.page.appendChild( domElement );

			return domElement;

		}

		addHeader ( text ) {

			const div = document.createElement( 'div' );

			div.classList.add( 'header' );
			div.textContent = this.i18n( text );

			this.page.appendChild( div );

			return div;

		}

		addCollapsingHeader ( text, collapsed = false ) {

			const div = this.addHeader( text );

			div.classList.add( 'header_full' );
			if ( collapsed ) div.classList.add( 'header_collapsed' );

			const container = document.createElement( 'div' );

			container.classList.add( 'container_full' );
			if ( collapsed ) container.classList.add( 'container_collapsed' );

			this.page.appendChild( container );

			this.addListener( div, 'click', () => {

				if ( div.classList.contains( 'header_collapsed' ) ) {

					this.addListener( container, 'transitionend', _onReveal );
					container.classList.remove( 'container_collapsed' );

				} else {

					this.addListener( container, 'transitionend', _onCollapse );
					container.classList.add( 'container_collapsed' );

				}

				function _onReveal () {

					container.removeEventListener( 'transitionend', _onReveal );
					div.classList.remove( 'header_collapsed' );

				}

				function _onCollapse () {

					container.removeEventListener( 'transitionend', _onCollapse );
					div.classList.add( 'header_collapsed' );

				}

			} );

			return container;

		}

		addText ( text ) {

			const p = this.addLine( text );

			p.classList.add( 'spaced' );

			return p;

		}

		addLine ( text ) {

			const p = document.createElement( 'p' );

			p.textContent = text;

			this.page.appendChild( p );

			return p;

		}

		addBlankLine () {

			const b = document.createElement( 'br' );

			this.page.appendChild( b );

			return b;

		}

		addLink ( url, text ) {

			const a = document.createElement( 'a' );

			a.href = url;
			a.textContent = text;
			a.target = '_blank';

			this.page.appendChild( a );

			return a;

		}

		makeLabel ( title, labelClass, idFor = 'na' ) {

			const label = document.createElement( 'label' );

			label.textContent = this.i18n( title );
			label.htmlFor = idFor;
			label.classList.add( labelClass );

			return label;

		}

		addSelect ( title, obj, trgObj, property, replace ) {

			const div    = document.createElement( 'div' );
			const select = document.createElement( 'select' );

			div.classList.add( 'control' );

			if ( obj instanceof Array ) {

				obj.forEach( element => {

					const opt = document.createElement( 'option' );

					opt.value = element;
					opt.text = element;

					if ( opt.value === trgObj[ property ] ) opt.selected = true;

					select.add( opt, null );

				} );

			} else {

				for ( const p in obj ) {

					const opt = document.createElement( 'option' );

					// translate each space delimited substring of ui text
					opt.text = p.split( ' ' ).reduce( ( res, val ) => { return res + ' ' + this.i18n( val ); }, '' ).trim();
					opt.value = obj[ p ];

					if ( opt.value == trgObj[ property ] ) opt.selected = true;

					select.add( opt, null );

				}

			}

			const frame = this.frame;

			this.addListener( select, 'change', function onChange ( event ) {

				frame.inHandler = true;
				trgObj[ property ] = event.target.value;
				frame.inHandler = false;

			} );

			frame.controls[ property ] = select;

			div.appendChild( this.makeLabel( title, 'cv-select' ) );
			div.appendChild( select );

			if ( replace === undefined ) {

				this.page.appendChild( div );

			} else {

				this.page.replaceChild( div, replace );

			}

			return div;

		}

		addFileSelect ( title, fileSelector ) {

			const frame = this.frame;
			const id = 'cv-' + frame.getSeq();
			const sourceList = fileSelector.sourceList;
			const div = document.createElement( 'div' );
			const select = document.createElement( 'select' );
			const label = this.makeLabel( title, 'cv-select', id );

			div.classList.add( 'control' );
			label.classList.add( 'cv-file-label' );

			sourceList.forEach( source => {

				const opt = document.createElement( 'option' );

				opt.text = source.name;
				opt.value = source.id;

				if ( opt.value == fileSelector.loadedSource.id ) opt.selected = true;

				select.add( opt, null );

			} );

			this.addListener( select, 'change', function onChange ( event ) {


				frame.inHandler = true;

				fileSelector.selectSource( sourceList.find( source => source.id == event.target.value  ) );

				frame.inHandler = false;

			} );

			frame.controls[ 'fileSelector' ] = select;

			div.appendChild( label );
			div.appendChild( select );


			const input = document.createElement( 'input' );

			input.id = id;
			input.classList.add( 'cv-file' );
			input.type = 'file';
			input.accept = '.3d,.lox,.plt';
			input.multiple = true;

			this.addListener( input, 'change', function _handleFileChange () {

				fileSelector.loadLocalFiles( input.files );

			} );

			label.appendChild( input );
			this.page.appendChild( div );

			return div;

		}

		addCheckbox ( title, obj, property ) {

			const frame = this.frame;
			const cb    = document.createElement( 'input' );
			const div   = document.createElement( 'div' );

			const id = 'cv-' + frame.getSeq();

			div.classList.add( 'control' );

			cb.type = 'checkbox';
			cb.checked = obj[ property ];
			cb.id = id;

			this.addListener( cb, 'change', _checkboxChanged );

			frame.controls[ property ] = cb;

			div.appendChild( cb );
			div.appendChild( this.makeLabel( title, 'check', id ) );

			this.page.appendChild( div );

			return div;

			function _checkboxChanged ( event ) {

				frame.inHandler = true;

				obj[ property ] = event.target.checked;

				frame.inHandler = false;

			}

		}

		addNumber ( title, obj, property ) {

			const frame = this.frame;
			const number    = document.createElement( 'input' );
			const div   = document.createElement( 'div' );

			const id = 'cv-' + frame.getSeq();

			div.classList.add( 'control' );

			number.type = 'number';
			number.value = obj[ property ];
			number.id = id;
			number.disabled = true;


			frame.controls[ property ] = number;

			div.appendChild( number );
			div.appendChild( this.makeLabel( title, 'check', id ) );

			this.page.appendChild( div );

			return div;

		}

		addRange ( title, obj, property ) {

			const frame = this.frame;
			const div = document.createElement( 'div' );
			const range = document.createElement( 'input' );

			div.classList.add( 'control' );

			range.type = 'range';

			range.min = 0;
			range.max = 1;

			range.step = 0.05;
			range.value = obj[ property ];

			this.addListener( range, 'input', _rangeChanged );

			frame.controls[ property ] = range;

			div.appendChild( this.makeLabel( title, 'cv-range' ) );
			div.appendChild( range );

			this.page.appendChild( div );

			return div;

			function _rangeChanged ( event ) {

				frame.inHandler = true;

				obj[ property ] = event.target.value;

				frame.inHandler = false;

			}

		}

		addSlide ( domElement, depth ) {

			const slide = document.createElement( 'div' );

			slide.classList.add( 'slide' );
			slide.style.zIndex = 200 - depth;

			slide.appendChild( domElement );

			this.page.appendChild( slide );

			this.slide = slide;
			this.slideDepth = depth;

			return slide;

		}

		replaceSlide ( domElement, depth ) {

			const newSlide = document.createElement( 'div' );
			const page = this.page;

			let oldSlide = this.slide;

			newSlide.classList.add( 'slide' );
			newSlide.style.zIndex = 200 - depth;

			if ( depth < this.slideDepth ) {

				newSlide.classList.add( 'slide-out' );

			}

			newSlide.appendChild( domElement );

			page.appendChild( newSlide );

			if ( depth > this.slideDepth ) {

				oldSlide.addEventListener( 'transitionend', afterSlideOut );
				oldSlide.classList.add( 'slide-out' );

				oldSlide.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

			} else if ( depth < this.slideDepth ) {

				newSlide.addEventListener( 'transitionend', afterSlideIn );

				newSlide.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

				newSlide.classList.remove( 'slide-out' );

			} else {

				page.removeChild( oldSlide );

			}

			this.slide = newSlide;
			this.slideDepth = depth;

			return newSlide;

			function afterSlideOut () {

				oldSlide.removeEventListener( 'transitionend', afterSlideOut );
				page.removeChild( oldSlide );

				oldSlide = null;

			}

			function afterSlideIn () {

				page.removeChild( oldSlide );
				newSlide.removeEventListener( 'transitionend', afterSlideIn );

				oldSlide = null;

			}

		}

		addButton ( title, func ) {

			const button = document.createElement( 'button' );

			button.type = 'button';
			button.textContent = this.i18n( title );

			this.addListener( button, 'click', func );

			this.page.appendChild( button );

			return button;

		}

		addTextBox ( title, placeholder, getResultGetter ) {

			const div = document.createElement( 'div' );
			const input = document.createElement( 'input' );

			let value;

			input.type = 'text';
			input.placeholder = placeholder;

			div.appendChild( this.makeLabel( title, 'text' ) );
			div.appendChild( input );

			this.page.appendChild( div );

			this.addListener( input, 'change', function ( e ) { value = e.target.value; return true; } );

			getResultGetter( _result );

			return div;

			function _result() {

				input.value = '';
				return value;

			}

		}

		addDownloadButton ( title, urlProvider, fileName ) {

			const a = document.createElement( 'a' );

			this.addListener( a, 'click', () => { a.href = urlProvider( a ); } );

			a.textContent = this.i18n( title );
			a.type = 'download';
			a.download = fileName;
			a.href = 'javascript:void();';

			a.classList.add( 'download' );

			this.page.appendChild( a );

			return a;

		}

		download ( data, fileName ) {

			const a = document.createElement( 'a' );

			a.type = 'download';
			a.download = fileName;
			a.href = data;
			a.click();

		}

		addColor ( title, name ) {

			const frame = this.frame;
			const cb    = document.createElement( 'input' );
			const div   = document.createElement( 'div' );
			const cfg = frame.ctx.cfg;

			const id = 'cv-' + frame.getSeq();

			div.classList.add( 'control' );
			div.classList.add( 'color' );

			cb.type = 'color';
			cb.value = cfg.themeColorHex( name ),

			cb.id = id;

			this.addListener( cb, 'change', _colorChanged );

			frame.controls[ name ] = cb;

			div.appendChild( cb );
			div.appendChild( this.makeLabel( title, 'color', id ) );

			this.page.appendChild( div );

			this.addListener( cfg, 'colors', e => { if (e.name === 'all' ) cb.value = cfg.themeColorHex( name ); } );

			return div;

			function _colorChanged ( event ) {

				frame.inHandler = true;

				cfg.setThemeColorCSS( name, event.target.value );

				frame.inHandler = false;

			}

		}

		addLogo () {

			const img = document.createElement( 'div' );

			img.classList.add( 'logo' );
			img.title = 'logo';

			this.appendChild( img );

		}

		dispose () {
			if ( this._dispose ) this._dispose();
		}

	}

	class Panel {

		constructor ( page ) {

			this.page = page;
			this.elements = [];
			this.dynamic = [];

			this.onShow = function () {

				this.dynamic.forEach( element => element.parentElement.removeChild( element ) );
				this.dynamic = [];

			};

		}

		add ( element ) {

			this.elements.push( element );

			return element;

		}

		addDynamic ( element ) {

			this.dynamic.push( element );

			return element;

		}

		setVisibility ( visible ) {

			const frame = this.page.frame;

			frame.setControlsVisibility( this.elements, visible );
			frame.setControlsVisibility( this.dynamic, visible );

			if ( visible && this.onShow !== null ) this.onShow();

		}

	}

	class RoutePanel extends Panel {

		constructor ( page, viewer, fileSelector ) {

			super( page );

			const self = this;
			const metadata = viewer.getMetadata();
			const routeNames = viewer.routeNames;

			this.add( page.addHeader( 'route.header' ) );

			let routeSelector = page.addSelect( 'route.current', routeNames, viewer, 'route' );
			let getNewRouteName;

			this.add( routeSelector );

			this.add( page.addButton( 'route.save', _saveRoute ) );

			this.add( page.addTextBox( 'route.new', '---', function ( getter ) { getNewRouteName = getter; } ) );

			this.add( page.addButton( 'route.add', _newRoute ) );

			this.add( page.addDownloadButton( 'route.download', metadata.getURL, replaceExtension( fileSelector.file, 'json' ) ) );

			function _newRoute () {

				console.log( getNewRouteName );
				//routes.addRoute( getNewRouteName() );

				// update selector

				routeSelector = self.addSelect( 'Current Route', viewer.routeNames, viewer, 'route', routeSelector );

			}

			function _saveRoute () {

				//routes.saveCurrent();

			}

		}

	}

	class TracePanel extends Panel {

		constructor ( page, viewer ) {

			super( page );

			const self = this;

			const start = page.i18n( 'trace.start' ) + ':';
			const end = page.i18n( 'trace.end' ) + ':';

			page.addListener( viewer, 'selectedTrace', _onSelect );

			this.add( page.addHeader( 'trace.header' ) );

			const line1 = this.add( page.addLine( start ) );
			const line2 = this.add( page.addLine( end ) );

			function _initPanel () {

				self.onShow();
				line1.textContent = start;
				line2.textContent = end;

			}

			function _onSelect ( event ) {

				if ( event.add !== undefined ) {

					_showStations( event );

				} else if ( event.delete !== undefined ) {

					_showTrace ( event );

				}

			}

			function _showTrace ( event ) {

				const traceInfo = event.trace;

				_initPanel();

				line1.textContent = start + ' ' + traceInfo.start;
				line2.textContent = end + ' ' + traceInfo.end;

				self.addDynamic( page.addButton( 'trace.delete', function() {
					event.delete();
					_initPanel();
				} ) );

			}

			function _showStations ( event ) {

				_initPanel();

				if ( event.start !== undefined ) line1.textContent = start + ' ' + event.start;

				if ( event.end !== undefined ) {

					line2.textContent = end + ' ' + event.end;

					self.addDynamic( page.addButton( 'trace.add', function() {
						event.add();
						_initPanel();
					} ) );

				}

			}

		}

	}

	const mode = {
		'modes.none': MOUSE_MODE_NORMAL,
		'modes.route': MOUSE_MODE_ROUTE_EDIT,
		'modes.trace': MOUSE_MODE_TRACE_EDIT
	};

	class EditPage extends Page {

		constructor ( frame, viewer, fileSelector ) {

			super( 'icon_route', 'edit', _onTop, _onLeave );

			frame.addPage( this );

			const self = this;
			const intro = [];

			let initialState;

			let routePanel = null;
			let tracePanel = null;

			this.addSelect( 'mode', mode, viewer, 'editMode' );

			intro.push( this.addText( this.i18n( 'intro' ) ) );

			this.onChange = _onChange;

			return;

			function _onChange ( event ) {

				// change UI dynamicly to only display appropriate controls
				if ( event.name === 'editMode' ) {

					const newState = Object.assign( {}, initialState );

					switch ( viewer.editMode ) {

					case MOUSE_MODE_TRACE_EDIT:

						if ( tracePanel === null ) tracePanel = new TracePanel( self, viewer );

						newState.traces = true;

						break;

					case MOUSE_MODE_ROUTE_EDIT:

						if ( routePanel === null ) routePanel = new RoutePanel( self, viewer, fileSelector );

						newState.shadingMode = SHADING_PATH;

						break;

					}

					viewer.setView( newState );

					frame.setControlsVisibility( intro, viewer.editMode === MOUSE_MODE_NORMAL );

					if ( routePanel !== null ) routePanel.setVisibility( viewer.editMode === MOUSE_MODE_ROUTE_EDIT );
					if ( tracePanel !== null ) tracePanel.setVisibility( viewer.editMode === MOUSE_MODE_TRACE_EDIT );

				}

			}

			function _onTop () {

				// save initial view settings

				initialState = {
					shadingMode: viewer.shadingMode,
					stations: viewer.stations,
					traces: viewer.traces
				};

				_onChange( { type: 'change', name: 'editMode' } );

			}

			function _onLeave () {

				// restore inital view settings

				viewer.setView( initialState );

			}

		}

	}

	class ExportPage extends Page {

		constructor ( frame, viewer, fileSelector ) {

			super( 'icon_export', 'exports' );

			frame.addPage( this );

			this.addHeader( 'png_export.header' );

			const sizes = [];
			let mss = viewer.maxSnapshotSize;

			do { sizes.push( mss ); } while ( (mss /= 2) > 512 );

			const scales = [ 1, 2, 3, 4, 5, 6 ];

			const pngParams = {
				exportSize: sizes[ 0 ],
				lineScale: 1
			};

			this.addSelect( 'png_export.line_scale', scales, pngParams, 'lineScale' );
			this.addSelect( 'png_export.size', sizes, pngParams, 'exportSize' );

			this.addDownloadButton(
				'png_export.export',
				() => {
					const url = viewer.getSnapshot( pngParams.exportSize, pngParams.lineScale );
					return url;
				},
				'snapshot.png'
			);

			this.addHeader( 'gltf_export.header' );

			const selection = { legs: false, walls: false, scraps: false  };
			const options = { rotate: false, binary: false };

			if ( viewer.hasWalls ) {

				selection.walls = true;
				this.addCheckbox( 'gltf_export.walls', selection, 'walls' );

			}

			if ( viewer.hasScraps ) {

				selection.scraps = true;
				this.addCheckbox( 'gltf_export.scraps', selection, 'scraps' );

			}

			this.addCheckbox( 'gltf_export.legs', selection, 'legs' );

			this.addCheckbox( 'gltf_export.rotate_axes', options, 'rotate' );
			this.addCheckbox( 'gltf_export.binary_format', options, 'binary' );

			this.addButton( 'gltf_export.export', function () {

				viewer.getGLTFExport( selection, options, handleExport );

			} );

			const self = this;

			return;

			function handleExport ( gltfData, binary ) {

				const filename = replaceExtension( fileSelector.localFilename, ( binary ? 'glb' : 'gltf' ) );

				self.download( URL.createObjectURL( gltfData ), filename );

			}

		}

	}

	class FileSelector extends EventDispatcher {

		constructor ( container, ctx ) {

			super();

			this.sourceList = [];
			this.sourceCount = 0;
			this.currentIndex = Infinity;
			this.loadedSource = null;

			this.splash = null;

			const self = this;

			container.addEventListener( 'drop', _handleDrop );
			container.addEventListener( 'dragenter', _handleDragenter );
			container.addEventListener( 'dragover', _handleDragover );
			container.addEventListener( 'dragleave', _handleDragleave );

			function _closeSpash () {

				const splash = self.splash;
				container.classList.remove( 'cv-splash' );

				if ( splash !== null ) {

					splash.parentNode.removeChild( splash );
					self.splash = null;

				}

			}

			function _handleDragenter ( event ) {

				event.preventDefault();

				if ( self.splash !== null ) return;

				const splash = document.createElement( 'div' );

				splash.innerHTML = ctx.cfg.i18n( 'dnd.splash_text' ) || 'dnd.splash_text';
				splash.id = 'cv-splash';

				container.appendChild( splash );
				container.classList.add( 'cv-splash' );

				self.splash = splash;

			}

			function _handleDragover ( event ) {

				event.preventDefault();
				event.dataTransfer.dropEffect = 'copy';

			}


			function _handleDragleave ( event ) {

				event.preventDefault();
				if ( event.relatedTarget === container.parentNode ) _closeSpash();

			}

			function _handleDrop ( event ) {

				_closeSpash();

				const dt = event.dataTransfer;

				event.preventDefault();

				self.loadLocalFiles( dt.files );

			}

			this.dispose = function () {

				container.removeEventListener( 'drop', _handleDrop );
				container.removeEventListener( 'dragover', _handleDragover );
				container.removeEventListener( 'dragleave', _handleDragleave );
				container.removeEventListener( 'dragenter', _handleDragenter );

			};

		}

		loadLocalFiles ( list ) {

			const count = list.length;
			const source = new ModelSource( [], true );

			if ( count > 0 ) {

				for ( let i = 0; i < count; i++ ) {

					source.addFile( list[ i ] );

				}

				source.name = count === 1 ? '*' + list[ 0 ].name : '*multiple';

				// FIXME ( add to list??)
				this.sourceList.push( source );
				this.selectSource( source, null );

			}

		}

		addNetList ( list ) {

			const sourceList = this.sourceList;

			list.forEach( name => {

				const source = new ModelSource( [], false );

				if ( name instanceof Object ) {

					name.files.forEach( file => source.addFile( { name: file } ) );
					source.name = name.name;

				} else {

					source.addFile( { name: name } );
					source.name = name;

				}

				sourceList.push( source );

			} );

			this.sourceCount = list.length;

		}

		nextSource () {

			const sourceList = this.sourceList;

			//cycle through caves in list provided
			if ( this.sourceCount === 0 ) return false;

			if ( ++this.currentIndex >= this.sourceCount ) this.currentIndex = 0;

			this.selectSource( sourceList[ this.currentIndex ] );

		}

		selectSource ( source, section = null ) {

			this.loadedSource = source;

			this.dispatchEvent( { type: 'selected', source: source, section: section } );

		}

		reload () {

			this.selectSource( this.loadedSource );

		}

	}

	class Frame {

		static seq = 0;

		constructor ( ctx ) {

			this.ctx = ctx;
			this.openPageId = null;
			this.reset();

		}

		reset () {

			const self = this;

			// create UI side panel and reveal tabs
			const frame = document.createElement( 'div' );
			frame.classList.add( 'cv-frame' );

			const frameHeader = document.createElement( 'div' );
			frameHeader.classList.add( 'cv-frame-header' );
			frameHeader.textContent = 'frame header';
			frame.appendChild( frameHeader );

			// create UI box to contain tabs - reorients for small screen widths
			const tabBox = document.createElement( 'div' );
			tabBox.classList.add( 'cv-tab-box' );

			if ( this.pages ) this.pages.forEach( p => p.owner.dispose() );

			this.frame = frame;
			this.header = frameHeader;
			this.tabBox = tabBox;
			this.pages = [];
			this.listeners = [];
			this.inHandler = false;
			this.controls = [];
			this.seq = 0;

			const close = document.createElement( 'div' );
			close.classList.add( 'close' );
			close.classList.add( 'tab' );

			this.addListener( close, 'click', _closeFrame );

			tabBox.appendChild( close );

			function _closeFrame ( /* event */ ) {

				self.openPageId = null;
				tabBox.classList.remove( 'onscreen' );
				frame.classList.remove( 'onscreen' );

			}

		}

		addPage ( page ) {

			const pageDiv = page.page;
			const tab = page.tab;

			page.frame = this;

			this.addListener( tab, 'click', page.tabHandleClick.bind( page ) );

			if ( page.onTop !== undefined ) {

				// callback when this page is made visible
				this.addListener( tab, 'click', page.onTop );

			}

			this.tabBox.appendChild( tab );
			this.frame.appendChild( pageDiv );

			this.pages.push( { tab: tab, page: pageDiv, owner: page } );

			if ( this.openPageId === page.id ) page.open();

			return this;

		}

		getSeq () {

			return Frame.seq++;

		}

		onScreen ( title ) {

			this.tabBox.classList.add( 'onscreen' );
			this.frame.classList.add( 'onscreen' );
			this.header.textContent = title;

		}

		setParent ( parent ) {

			parent.appendChild( this.tabBox );
			parent.appendChild( this.frame );

		}

		setControlsVisibility ( list, visible ) {

			const display = visible ? 'block' : 'none';

			list.forEach( element => {

				if ( element === null ) return;
				element.style.display = display;

			} );

		}

		clear () {

			const frame  = this.frame;
			const tabBox = this.tabBox;

			if ( frame  !== null && frame.parentElement  !== null ) frame.parentElement.removeChild( frame );
			if ( tabBox !== null && tabBox.parentElement !== null ) tabBox.parentElement.removeChild( tabBox );

			this.listeners.forEach( listener => listener.obj.removeEventListener( listener.name, listener.handler ) );

			this.reset();

			return;

		}

		addFullscreenButton ( id, obj, property ) {

			const tabBox = this.tabBox;
			const fullscreen = document.createElement( 'div' );

			fullscreen.classList.add( id );
			fullscreen.classList.add( 'tab' );

			this.addListener( fullscreen, 'click', _toggleButton );

			this.addListener( obj, 'change', _setButton );

			tabBox.appendChild( fullscreen );

			_setButton();

			return fullscreen;

			function _toggleButton () {

				obj[ property ] = ! obj[ property ];

				_setButton();

			}

			function _setButton () {

				if ( obj[ property ] ) {

					fullscreen.classList.remove( 'expand' );
					fullscreen.classList.add( 'collapse' );

				} else {

					fullscreen.classList.add( 'expand' );
					fullscreen.classList.remove( 'collapse' );

				}

			}

		}

		addListener ( obj, name, handler ) {

			obj.addEventListener( name, handler, false );

			this.listeners.push( {
				obj: obj,
				name: name,
				handler: handler
			} );

		}

		handleChange ( event ) {

			const obj = event.target;
			const property = event.name;

			if ( ! this.displayinHandle ) {

				if ( this.controls[ property ] ) {

					const ctrl = this.controls[ property ];

					switch ( ctrl.type ) {

					case 'checkbox':

						ctrl.checked = obj[ property ];

						break;

					case 'select-one':
					case 'range':
					case 'number':

						ctrl.value = obj[ property ];

						break;

					case 'download':

						ctrl.href = obj[ property ];

						break;

					}

				}

			}

			this.pages.forEach( p => {

				const page = p.owner;

				if ( page.onChange !== null ) page.onChange( event );

			} );

		}

	}

	class HelpPage extends Page {

		constructor ( frame, avenControls ) {

			super( 'icon_help', 'help' );

			frame.addPage( this );
			const self = this;

			let dl;

			this.addHeader( avenControls ? 'header_svx' : 'header_native' );

			this.addHeader( 'shading.header' );

			dl = document.createElement( 'dl' );

			_addKey( '1', 'shading.height' );
			_addKey( '2', 'shading.inclination' );
			_addKey( '3', 'shading.length' );
			_addKey( '4', 'shading.height_cursor' );
			_addKey( '5', 'shading.single' );
			_addKey( '6', 'shading.survey' );
			_addKey( '7', 'shading.route' );
			_addKey( '8', 'shading.depth' );
			_addKey( '9', 'shading.depth_cursor' );
			_addKey( '0', 'shading.distance' );
			_addKey( '<alt>f', 'shading.flat' );

			if ( ! avenControls ) {

				_addKey( '[', 'shading.cursor_up' );
				_addKey( ']', 'shading.cursor_down' );

			}

			this.appendChild( dl );

			this.addHeader( 'view.header' );

			dl = document.createElement( 'dl' );

			if ( avenControls ) {

				_addKey( 'P', 'view.plan' );
				_addKey( 'L', 'view.elevation' );

				_addKey( '', '-' );

				_addKey( 'N', 'view.north' );
				_addKey( 'E', 'view.east' );
				_addKey( 'S', 'view.south' );
				_addKey( 'W', 'view.west' );

				_addKey( '', '-' );

				_addKey( 'C', 'view.rotate_clockwise' );
				_addKey( 'V', 'view.rotate_anticlockwise' );

				_addKey( ']', 'view.zoom_in' );
				_addKey( '[', 'view.zoom_out' );

				_addKey( 'F', 'view.full_screen' );

				_addKey( '', '-' );

				_addKey( '" "', 'view.auto_rotate' );
				_addKey( 'Z', 'view.rotate_speed_up' );
				_addKey( 'X', 'view.rotate_speed_down' );
				_addKey( 'R', 'view.reverse_rotation' );

				_addKey( '', '-' );

				_addKey( '<del>', 'view.reset' );

			} else {

				_addKey( 'F', 'view.full_screen' );
				_addKey( 'O', 'view.orthogonal' );
				_addKey( 'P', 'view.perspective' );
				_addKey( 'R', 'view.reset' );
				_addKey( '.', 'view.center' );
				_addKey( 'N', 'view.next' );

			}

			_addKey( '<alt>L', 'view.show_labels' );
			_addKey( '<alt>S', 'view.control_mode' );
			_addKey( '<alt>X', 'view.zoom_to_cursor' );
			_addKey( '(', 'view.decrease_focal_length' );
			_addKey( ')', 'view.increase_focal_length' );

			this.appendChild( dl );

			this.addHeader( 'visibility.header' );

			dl = document.createElement( 'dl' );

			if ( avenControls ) {

				_addKey( 'J', 'visibility.station_labels' );
				_addKey( 'Q', 'visibility.splays' );
				_addKey( 'T', 'visibility.terrain' );
				_addKey( '<ctrl>B', 'visibility.bounding_box' );
				_addKey( '<ctrl>N', 'visibility.station_labels' );
				_addKey( '<ctrl>X', 'visibility.stations' );
				_addKey( '<ctrl>L', 'visibility.survey' );
				_addKey( '<ctrl>F', 'visibility.surface' );
				_addKey( '<alt>E',  'visibility.entrance_labels' );

				_addKey( '', '-' );

				_addKey( '<', 'visibility.opacity_down' );
				_addKey( '>', 'visibility.opacity_up' );

			} else {

				_addKey( 'C', 'visibility.scraps' );
				_addKey( 'J', 'visibility.station_labels' );
				_addKey( 'L', 'visibility.entrance_labels' );
				_addKey( 'Q', 'visibility.splays' );
				_addKey( 'S', 'visibility.surface' );
				_addKey( 'T', 'visibility.terrain' );
				_addKey( 'W', 'visibility.walls' );
				_addKey( 'Z', 'visibility.stations' );

				_addKey( '', '-' );

				_addKey( '<', 'visibility.opacity_down' );
				_addKey( '>', 'visibility.opacity_up' );

			}

			this.appendChild( dl );

			if ( ! avenControls ) {

				this.addHeader( 'selection.header' );

				dl = document.createElement( 'dl' );

				_addKey( 'V', 'selection.remove' );

				this.appendChild( dl );

			}

			function _addKey( key, description ) {

				const dt = document.createElement( 'dt' );
				const dd = document.createElement( 'dd' );

				dt.textContent = key;
				dd.textContent = self.i18n( description );

				dl.appendChild( dt );
				dl.appendChild( dd );

			}

		}

	}

	class InfoPage extends Page {

		constructor ( frame, viewer, fileSelector ) {

			super( 'icon_info', 'info' );

			frame.addPage( this );

			this.addHeader( 'header' );

			this.addHeader( 'stats.header' );

			this.addText( this.i18n( 'file' ) + ': ' + fileSelector.file );

			const stats = viewer.getLegStats( LEG_CAVE );

			this.addBlankLine();

			this.addLine( this.i18n( 'stats.legs' ) + ': ' + stats.legCount );
			this.addLine( this.i18n( 'stats.totalLength' ) + ': ' + stats.legLength.toFixed( 2 ) + '\u202fm' );
			this.addLine( this.i18n( 'stats.minLength' ) + ': ' + stats.minLegLength.toFixed( 2 ) + '\u202fm' );
			this.addLine( this.i18n( 'stats.maxLength' ) + ': ' + stats.maxLegLength.toFixed( 2 ) + '\u202fm' );

			if ( viewer.hasSplays || viewer.hasDuplicateLegs || viewer.hasSurfaceLegs ) {

				this.addBlankLine();
				this.addLine( this.i18n( 'stats.otherLegs' ) );
				this.addBlankLine();

			}

			if ( viewer.hasSplays ) {

				const splayStats = viewer.getLegStats( LEG_SPLAY );
				this.addLine( this.i18n( 'stats.splayCount' ) + ': ' + splayStats.legCount );

			}

			if ( viewer.hasDuplicateLegs ) {

				const duplicateStats = viewer.getLegStats( LEG_DUPLICATE );
				this.addLine( this.i18n( 'stats.duplicateCount' ) + ': ' + duplicateStats.legCount );

			}

			if ( viewer.hasSurfaceLegs ) {

				const surfaceStats = viewer.getLegStats( LEG_SURFACE );
				this.addLine( this.i18n( 'stats.surfaceCount' ) + ': ' + surfaceStats.legCount );

			}

			this.addHeader( 'CaveView v' + VERSION + '.' );

			this.addLogo();
			this.addText( this.i18n( 'summary' ) );

			this.addText( this.i18n( 'more' ) + ': ' );
			this.addLink( 'https://aardgoose.github.io/CaveView.js/', this.i18n( 'github' ) );
			this.addText( ' Angus Sawyer, 2021' );

		}

	}

	let lastSign = 1;

	function clampedInc( value, inc ) {

		let sign = Math.sign( value );

		if ( sign === 0 ) {

			sign = lastSign;

		} else {

			lastSign = sign;

		}

		return sign * Math.max( Math.abs( value ) + inc, 0 );

	}

	function KeyboardControls ( viewer, fileSelector, avenControls ) {

		document.addEventListener( 'keydown', keyDown );

		function keyDown ( event ) {

			if ( ! viewer.surveyLoaded || ! viewer.mouseOver ) return;

			event.preventDefault(); // enables F5, ctrl+<F5>, ctrl+<F> and other keys on the control's host page

			if ( handleKeyCommon( event ) ) return;

			if ( avenControls ) {

				handleKeyAven( event );

			} else {

				handleKeyDefault( event );

			}

		}

		function handleKeyAven( event ) {

			if ( event.ctrlKey ) {

				switch ( event.key ) {

				case 'b':

					viewer.box = ! viewer.box;
					break;

				case 'e':

					viewer.wheelTilt = ! viewer.wheelTilt;
					break;

				case 'f':

					if ( viewer.hasSurfaceLegs ) viewer.surfaceLegs = ! viewer.surfaceLegs;
					break;

				case 'l':

					if ( viewer.hasLegs ) viewer.legs = ! viewer.legs;
					break;

				case 'n': // (not available in Chrome)

					if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;
					break;

				case 'x':

					viewer.stations = ! viewer.stations;
					break;

				}

			} else {

				switch ( event.key ) {

				case 'Delete': // '<delete>' reset view

					viewer.reset = true;
					break;

				case 'Enter':

					viewer.autoRotate = true;
					break;

				case ' ':

					viewer.autoRotate = ! viewer.autoRotate;
					break;

				case 'l': // elevation

					viewer.polarAngle = Math.PI / 2;
					break;

				case 'e': // East

					viewer.azimuthAngle = 3 * Math.PI / 2;
					break;

				case 'n': // North

					viewer.azimuthAngle = 0;
					break;

				case 'p': // plan

					viewer.polarAngle = 0;
					break;

				case 'r': // reverse rotation direction

					viewer.autoRotateSpeed *= -1;
					break;

				case 's': // South

					viewer.azimuthAngle = Math.PI;
					break;

				case 'w': // West

					viewer.azimuthAngle = Math.PI / 2;
					break;

				case 'c': // rotate clockwise

					viewer.autoRotateSpeed = - Math.abs( viewer.autoRotateSpeed );
					break;

				case 'v': // rotate anticlockwise

					viewer.autoRotateSpeed = Math.abs( viewer.autoRotateSpeed );
					break;

				case 'x': // decrease rotation speed

					viewer.autoRotateSpeed = clampedInc( viewer.autoRotateSpeed, -0.1 );
					break;

				case 'z': // increase rotation speed

					viewer.autoRotateSpeed = clampedInc( viewer.autoRotateSpeed, 0.1 );
					break;

				}

			}

		}

		function handleKeyDefault( event ) {

			if ( event.ctrlKey ) return;

			switch ( event.key ) {

			case 'c': // toggle scraps visibility

				if ( viewer.hasScraps ) viewer.scraps = ! viewer.scraps;
				break;

			case 'd': // toggle dye traces visibility

				if ( viewer.hasTraces ) viewer.traces = ! viewer.traces;
				break;

			case 'f': // toggle full screen

				viewer.fullscreen = ! viewer.fullscreen;
				break;

			case 'j': // toggle entrance labels

				if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;
				break;

			case 'l': // toggle entrance labels

				if ( viewer.hasEntrances ) viewer.entrances = ! viewer.entrances;
				break;

			case 'n': // load next cave in list

				fileSelector.nextSource();
				break;

			case 'o': // switch view to orthoganal'

				viewer.cameraType = CAMERA_ORTHOGRAPHIC;
				break;

			case 'p': // switch view to perspective

				viewer.cameraType = CAMERA_PERSPECTIVE;
				break;

			case 'q': // switch view to perspective

				if ( viewer.hasSplays ) viewer.splays = ! viewer.splays;
				break;

			case 'r': // reset camera positions and settings to initial plan view

				viewer.view = VIEW_PLAN;
				break;

			case 's': // surface leg visibility

				if ( viewer.hasSurfaceLegs ) viewer.surfaceLegs = ! viewer.surfaceLegs;
				break;

			case 't': // switch terrain on/off

				if ( viewer.hasTerrain ) viewer.terrain = ! viewer.terrain;
				break;

			case 'v': // cut selected survey section

				Page.clear();
				viewer.cut = true;

				break;

			case 'w': // switch walls on/off

				if ( viewer.hasWalls ) viewer.walls = ! viewer.walls;
				break;

			case 'x': // look at last POI

				viewer.setPOI = true; // actual value here is ignored.
				break;

			case 'z': // show station markers

				viewer.stations = ! viewer.stations;
				break;

			case ']':

				viewer.cursorHeight++;
				break;

			case '[':

				viewer.cursorHeight--;
				break;

			}

		}

		function handleKeyCommon( event ) {

			if ( event.ctrlKey ) return false;

			let handled = true;

			if ( event.altKey ) {

				switch ( event.key ) {

				case 's':

					viewer.svxControlMode = ! viewer.svxControlMode;
					break;

				case 'e': // toggle entrance labels

					viewer.entrances = ! viewer.entrances;
					break;

				case 'f':

					viewer.flatShading = ! viewer.flatShading;
					break;

				case 'h':

					viewer.hideMode = ! viewer.hideMode;
					break;

				case 'l':

					viewer.stationLabelOver = ! viewer.stationLabelOver;
					break;

				case 'x':

					viewer.zoomToCursor = ! viewer.zoomToCursor;
					break;

				default:

					handled = false;

				}

			} else {

				switch ( event.key ) {

				case '0': // change colouring scheme to distance

					viewer.shadingMode = SHADING_DISTANCE;
					break;

				case '1': // change colouring scheme to depth

					viewer.shadingMode = SHADING_HEIGHT;
					break;

				case '2': // change colouring scheme to angle

					viewer.shadingMode = SHADING_INCLINATION;
					break;

				case '3': // change colouring scheme to length

					viewer.shadingMode = SHADING_LENGTH;
					break;

				case '4': // change colouring scheme to height cursor

					viewer.shadingMode = SHADING_CURSOR;
					break;

				case '5': // change colouring scheme to white

					viewer.shadingMode = SHADING_SINGLE;
					break;

				case '6': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_SURVEY;
					break;

				case '7': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_PATH;
					break;

				case '8': // change colouring scheme to per survey section

					viewer.shadingMode = SHADING_DEPTH;
					break;

				case '9': // change colouring scheme to depth

					viewer.shadingMode = SHADING_DEPTH_CURSOR;
					break;

				case 'f': // toggle full screen

					viewer.fullscreen = ! viewer.fullscreen;
					break;

				case 'j': // toggle entrance labels

					if ( viewer.hasStationLabels ) viewer.stationLabels = ! viewer.stationLabels;
					break;

				case 'o': // switch view to orthoganal

					viewer.cameraType = CAMERA_ORTHOGRAPHIC;
					break;

				case 'q': // toggle splays

					if ( viewer.hasSplays ) viewer.splays = ! viewer.splays;
					break;

				case 't': // switch terrain on/off

					if ( viewer.hasTerrain ) viewer.terrain = ! viewer.terrain;
					break;

				case '+': // increase cursor depth

					viewer.cursorHeight++;
					break;

				case '-': // decrease cursor depth

					viewer.cursorHeight--;
					break;

				case '<': // decrease terrain opacity

					if ( viewer.hasTerrain ) viewer.terrainOpacity = Math.max( viewer.terrainOpacity - 0.05, 0 );
					break;

				case '>': // increase terrain opacity

					if ( viewer.hasTerrain ) viewer.terrainOpacity = Math.min( viewer.terrainOpacity + 0.05, 1 );
					break;

				case '(':

					viewer.focalLength = Math.max( 10, viewer.focalLength - 10 );
					break;

				case ')':

					viewer.focalLength = Math.min( 300, viewer.focalLength + 10 );
					break;

				default:

					handled = false;

				}

			}

			return handled;

		}

		this.dispose = function () {

			document.removeEventListener( 'keydown', keyDown );

		};

	}

	class SelectionCommonPage extends Page {

		constructor ( frame, viewer, container, fileSelector ) {

			const _onTop = () => { this.isOntop = true; };
			const _onLeave = () => { this.isOntop = false; };

			super( 'icon_explore', 'selection', _onTop, _onLeave );

			this.isOntop = false;

			frame.addPage( this );

			this.surveyTree = viewer.getSurveyTree();
			this.currentTop = this.surveyTree;

			this.nodes = new WeakMap();
			this.leafSections = new WeakSet();
			this.lastSelected = null;
			this.lastSection = 0;
			this.lastShadingMode = viewer.shadingMode;
			this.currentHover = null;
			this.stringCompare = new Intl.Collator( 'en-GB', { numeric: true } ).compare;

			const titleBar = document.createElement( 'div' );
			const cfg = viewer.ctx.cfg;

			titleBar.id = 'ui-path';
			titleBar.classList.add( 'header' );

			if ( viewer.isClipped ) {

				const span = document.createElement( 'span' );
				span.textContent = '\u25c0 ';

				this.addListener( titleBar, 'click', __handleLoadFull );

				titleBar.classList.add( 'reload' );

				const txt = document.createTextNode( this.currentTop.name );

				titleBar.appendChild( span );
				titleBar.appendChild( txt );

			} else {

				titleBar.textContent = this.currentTop.name;

				this.nodes.set( titleBar, this.currentTop );

			}

			this.titleBar = titleBar;
			this.appendChild( titleBar );

			this.addListener( this.page, 'mouseover', _handleMouseover );
			this.addListener( this.page, 'mouseleave', _handleMouseleave );

			this.addListener( this.page, 'click', _handleSelectSurveyClick );
			this.addListener( this.page, 'dblclick', _handleSelectSurveyDblClick );

			const self = this;

			container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

			this.addLine = function ( ul, child ) {

				if ( child === null ) return;

				const connections = child.isStation() ? child.effectiveConnections() : null;

				// track which sections have stations as children

				if ( connections !== null && ! this.leafSections.has( ul) ) this.leafSections.add( ul );

				// omit splays if now displaying

				if ( connections === 0 && ! viewer.splays && ! ( child.type & STATION_ENTRANCE ) ) return;

				const li  = document.createElement( 'li' );
				const text = ( child.comment === undefined ) ? child.name : child.name + ' ( ' + child.comment + ' )';
				const txt = document.createTextNode( text );

				let key;

				this.nodes.set( li, child );

				if ( viewer.section === child ) li.classList.add( 'selected' );

				if ( child.type === 0 ) {

					key = _makeKey( '\u2588 ', '#444444' );

					li.classList.add( 'section' );

				} else if ( child.type & STATION_ENTRANCE ) {

					key = _makeKey( '\u2229 ', cfg.themeColorCSS( 'stations.entrances.marker' ) );
					key.classList.add( 'cv-entrance' );

				} else if ( connections > 2 ) { // station at junction

					key = _makeKey( '\u25fc ', cfg.themeColorCSS( 'stations.junctions.marker' ) );

				} else if ( connections === 0 ) { // end of splay

					key = _makeKey( '\u25fb ', cfg.themeColorCSS( 'stations.default.marker' ) );

				} else { // normal station in middle or end of leg

					key = _makeKey( '\u25fc ', cfg.themeColorCSS( 'stations.default.marker' ) );

				}

				li.appendChild( key );
				li.appendChild( txt );

				if ( child.next ) {

					let next = child.next;
					let count = 1;

					while ( next && next !== child ) {

						count++;
						next = next.next;

					}

					const duplicateTag = document.createElement( 'span' );

					duplicateTag.textContent = ` [linked station ${count}]`;
					duplicateTag.classList.add( 'duplicate' );

					li.appendChild( duplicateTag );

				}

				if ( child.children.length > 0 ) {

					const descend = document.createElement( 'div' );

					descend.classList.add( 'descend-tree' );

					self.nodes.set( descend, child );

					li.appendChild( descend );

				}

				ul.appendChild( li );

			};

			this.displaySectionCommon = function ( top ) {

				const children = top.children;

				if ( ! top.sorted ) {

					children.sort( ( s1, s2 ) => this.stringCompare( s1.name, s2.name ) );

					top.sorted = true;

				}

				const ul = document.createElement( 'ul' );
				ul.classList.add( 'cv-tree' );

				top.forEachChild( child => this.addLine( ul, child ) );

				_colourSections( ul );

				this.currentTop = top;
				// this.lastSelected = null;
				this.lastShadingMode = viewer.shadingMode;

				return ul;

			};

			this.reloadSections = function () {

				const uls = this.page.getElementsByTagName( 'UL' );
				const targetSections = [];

				// find leaf sections that need reloading

				for ( let i = 0; i < uls.length; i++ ) {

					const ul = uls[ i ];
					if ( this.leafSections.has( ul ) ) targetSections.push( ul );

				}

				targetSections.forEach( ul => {

					const node = this.nodes.get( ul.previousSibling ) || this.currentTop;

					if ( node ) ul.replaceWith( this.displaySectionCommon( node ) );

				} );

			};

			this.onChange = _onChange;


			return;

			function _makeKey ( text, color ) {

				const key = document.createElement( 'span' );

				key.style.color = color;
				key.textContent = text;

				return key;

			}

			function _handleMouseleave ( /* event */ ) {

				viewer.highlight = self.surveyTree;
				viewer.popup = self.surveyTree;

			}

			function _handleMouseover ( event ) {

				const target = event.target;

				if ( target.nodeName !== 'LI' ) return;

				const node = self.nodes.get( target );

				if ( node !== self.currentHover ) {

					viewer.highlight = ( viewer.section !== node ) ? node : self.surveyTree;
					viewer.popup = node;

					self.currentHover = node;

				}

			}

			function _handleSelectSurveyClick ( event ) {

				event.stopPropagation();
				event.preventDefault();

				const target = event.target;
				const node = self.nodes.get( target );

				switch ( target.tagName ) {

				case 'LI':

					viewer.section = node;
					viewer.setPOI = true;

					target.classList.add( 'selected' );

					if ( self.lastSelected !== null ) self.lastSelected.classList.remove( 'selected' );

					self.lastSelected = target;

					break;

				case 'DIV':

					self.handleNext( target, node );
					break;

				case 'SPAN':

					if ( target.classList.contains( 'duplicate' ) ) {

						const node = self.nodes.get( target.parentNode );
						self.selectNode( node.next );

					} else {
						self.handleBack( target );
					}

					break;

				}

			}

			function _handleSelectSurveyDblClick ( event ) {

				event.stopPropagation();
				event.preventDefault();

				const target = event.target;
				const node = self.nodes.get( target );

				if ( ! target.classList.contains( 'section' ) ) return;

				if ( node !== self.surveyTree ) viewer.cut = true;

			}

			function _onChange ( event ) {

				if ( ! viewer.surveyLoaded ) return;

				if ( event.name === 'splays' ) {

					self.reloadSections();
					return;
				}

				if (
					( self.lastSection !== viewer.section ) ||
					( self.lastShadingMode === SHADING_SURVEY && viewer.shadingMode !== SHADING_SURVEY ) ||
					( self.lastShadingMode !== SHADING_SURVEY && viewer.shadingMode === SHADING_SURVEY )
				) {

					_colourSections();

					self.lastShadingMode = viewer.shadingMode;
					self.lastSection = viewer.section;

				}

			}

			function _colourSections ( ul ) {

				const root = ( ul === undefined ) ? self.page : ul;
				const lis = root.getElementsByTagName( 'li' );

				const surveyColourMapper = viewer.ctx.surveyColourMapper;
				const surveyColourMap = ( viewer.shadingMode === SHADING_SURVEY ) ? surveyColourMapper.getColourMap( viewer.section ) : null;

				for ( let i = 0; i < lis.length; i++ ) {

					const li = lis[ i ];
					const node = self.nodes.get( lis[ i ] );

					if ( node !== undefined && ! node.isStation() ) {

						const span = li.firstChild;
						const id = node.id;
						let colour;

						if ( surveyColourMap?.[ id ] !== undefined ) {

							colour = '#' + surveyColourMap[ id ].getHexString();

						} else {

							colour = '#444444';

						}

						span.style.color = colour;

					}

				}

			}

			function __handleLoadFull () {

				fileSelector.reload();

			}

		}

		selectNode () {} // not implemented for side scrolling tree structure

	}

	class SelectionPage extends SelectionCommonPage {

		constructor ( frame, viewer, container, fileSelector ) {

			super( frame, viewer, container, fileSelector );

			const self = this;
			let depth = 0;

			this.addSlide( _displaySection( self.currentTop ), depth );

			container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

			this.handleNext = function ( target, node ) {

				if ( node !== undefined && node !== self.surveyTree ) {

					self.replaceSlide( _displaySection( node ), ++depth );

				} else if ( target.id === 'ui-path' ) {

					viewer.section = self.currentTop;

				}

			};

			this.handleBack = function ( target ) {

				if ( target.id === 'surveyBack' ) {

					if ( self.currentTop === self.surveyTree ) return;

					self.replaceSlide( _displaySection( self.currentTop.parent ), --depth );

				}

			};

			return this;

			function _displaySection ( top ) {

				self.nodes = new WeakMap();

				let tmp;

				while ( tmp = self.titleBar.firstChild ) self.titleBar.removeChild( tmp ); // eslint-disable-line no-cond-assign

				if ( top === self.surveyTree ) {

					self.titleBar.textContent = ( top.name === '' ) ? '[model]' : top.name;
					self.nodes.set( self.titleBar, top );

				} else {

					const span = document.createElement( 'span' );

					span.id ='surveyBack';
					span.textContent = ' \u25C4';

					self.nodes.set( span, top );

					self.titleBar.appendChild( span );
					self.titleBar.appendChild( document.createTextNode( ' ' + top.name ) );

				}

				return self.displaySectionCommon( top );

			}

		}

	}

	class SelectionTreePage extends SelectionCommonPage {

		constructor ( frame, viewer, container, fileSelector ) {

			super( frame, viewer, container, fileSelector );

			const self = this;
			const frameDiv = frame.frame;

			const domTop = this.displaySectionCommon( this.currentTop );

			let hightlitElement = null;
			let lastHighlitScroll = 0;

			this.appendChild( domTop );

			container.clientHeight; /* lgtm[js/unused-local-variable] */ // eslint-disable-line no-unused-vars

			this.handleNext = function ( target, node ) {

				if ( node !== undefined && node !== this.surveyTree ) {

					const li = target.parentNode;

					if ( target.classList.contains( 'open' ) ) {

						li.removeChild( li.lastElementChild );
						target.classList.remove( 'open' );

					} else {

						const ul = this.displaySectionCommon( node );
						li.appendChild( ul );
						target.classList.add( 'open' );

						return ul;

					}

				} else if ( target.id === 'ui-path' ) {

					viewer.section = this.currentTop;

				}

			};

			this.handleBack = function () {};

			this.selectNode = function ( station ) {

				if ( ! this.isOntop) return;

				// traverse DOM to find existing tree elements and add required
				// until selected node is visible and can be highlighted

				const selectedNode = station;

				if ( selectedNode === null  ) {

					_clearHighlitElement();
					return;

				}

				// get list of tree nodes from selectedNode to root - 1

				const path = [];
				let node = selectedNode;

				do {
					path.push( node );
					node = node.parent;
				} while ( node.id !== this.surveyTree.id );

				// search dom tree for list Element <LI> mapped to selected node

				// start from top of dom tree
				let children = domTop.childNodes;

				node = path.pop();

				while ( node !== undefined ) {

					let i = 0;
					let listElement;

					// find matching child
					for ( i = 0; i < children.length; i++ ) {

						listElement = children[ i ];
						if ( this.nodes.get( listElement ) === node ) break;

					}

					if ( i === children.length ) break;

					if ( node === selectedNode ) {

						_setHighlight( listElement );
						break;

					} else {

						let nextTopElement = listElement.lastElementChild;

						// expand tree if not already visible
						if ( nextTopElement.tagName === 'DIV' ) {

							nextTopElement = this.handleNext( nextTopElement, node );

						}

						node = path.pop();
						children = nextTopElement.childNodes;

					}

				}

			};

			this.addListener( viewer, 'station', _selectNode );

			return;


			function _selectNode( event ) {

				self.selectNode( event.node.station );

			}

			function _setHighlight( element ) {

				lastHighlitScroll = 0;
				frameDiv.addEventListener( 'scroll', _onScroll );

				element.classList.add( 'highlight' );
				element.scrollIntoView( { behavior: 'smooth', block: 'center' } );

				if ( hightlitElement !== null ) _clearHighlight();
				hightlitElement = element;

			}

			function _clearHighlitElement () {

				frameDiv.removeEventListener( 'scroll', _onScroll );

				if ( lastHighlitScroll > performance.now() - 1000 ) {

					setTimeout( _clearHighlight, 1000 );

				} else {

					_clearHighlight();

				}

			}

			function _clearHighlight () {

				if ( hightlitElement === null ) return;

				hightlitElement.classList.remove( 'highlight' );
				hightlitElement = null;
				lastHighlitScroll = 0;

			}

			function _onScroll( event ) {

				lastHighlitScroll = event.timeStamp;

			}

		}

	}

	const legShadingModes = {
		'shading.height':        SHADING_HEIGHT,
		'shading.length':        SHADING_LENGTH,
		'shading.inclination':   SHADING_INCLINATION,
		'shading.height_cursor': SHADING_CURSOR,
		'shading.fixed':         SHADING_SINGLE,
		'shading.survey':        SHADING_SURVEY,
		'shading.route':         SHADING_PATH,
		'shading.distance':      SHADING_DISTANCE
	};

	const cameraViews = {
		'view.viewpoints.none':        VIEW_NONE,
		'view.viewpoints.plan':        VIEW_PLAN,
		'view.viewpoints.elevation_n': VIEW_ELEVATION_N,
		'view.viewpoints.elevation_s': VIEW_ELEVATION_S,
		'view.viewpoints.elevation_e': VIEW_ELEVATION_E,
		'view.viewpoints.elevation_w': VIEW_ELEVATION_W
	};

	const cameraModes = {
		'view.camera.orthographic': CAMERA_ORTHOGRAPHIC,
		'view.camera.perspective':  CAMERA_PERSPECTIVE,
		'view.camera.anaglyph':     CAMERA_ANAGLYPH
	};

	class SettingsPage extends Page {

		constructor ( frame, viewer, fileSelector ) {

			super( 'icon_settings', 'settings' );

			frame.addPage( this );

			const routeControls = [];
			const rotateControls = [];

			const cfg = viewer.ctx.cfg;

			const legShadingModesActive = Object.assign( {}, legShadingModes );

			this.addHeader( 'survey.header' );

			this.addFileSelect( 'survey.caption', fileSelector  );

			if ( ! viewer.surveyLoaded ) return this;

			const routeNames = viewer.routeNames;

			if ( viewer.hasRealTerrain ) {

				legShadingModesActive[ 'shading.depth' ] = SHADING_DEPTH;
				legShadingModesActive[ 'shading.depth_cursor' ] = SHADING_DEPTH_CURSOR;

			}

			const cvw = this.addCollapsingHeader( 'view.header' );

			cvw.appendChild( this.addSelect( 'view.camera.caption', cameraModes, viewer, 'cameraType' ) );

			//	controls.push( this.addRange( 'view.eye_separation', viewer, 'eyeSeparation' ) );

			cvw.appendChild( this.addSelect( 'view.viewpoints.caption', cameraViews, viewer, 'view' ) );

			cvw.appendChild( this.addRange( 'view.vertical_scaling', viewer, 'zScale' ) );

			cvw.appendChild( this.addRange( 'view.linewidth', viewer, 'linewidth' ) );
			// cvw.appendChild( this.addCheckbox( 'view.scaleLinewidth', viewer, 'scaleLinewidth' ) );
			cvw.appendChild( this.addCheckbox( 'view.autorotate', viewer, 'autoRotate' ) );

			rotateControls.push( cvw.appendChild( this.addRange( 'view.rotation_speed', viewer, 'autoRotateSpeed' ) ) );

			const sh = this.addCollapsingHeader( 'shading.header' );

			sh.appendChild( this.addSelect( 'shading.caption', legShadingModesActive, viewer, 'shadingMode' ) );

			if ( routeNames.length !== 0 ) {

				if ( ! viewer.route ) viewer.route = routeNames[ 0 ];

				routeControls.push( this.addSelect( 'selected_route', routeNames, viewer, 'route' ) );

			} else {

				routeControls.push( this.addText( this.i18n( 'no_routes') ) );

			}

			const cv = this.addCollapsingHeader( 'visibility.header' );

			if ( viewer.hasLegs            ) cv.appendChild( this.addCheckbox( 'visibility.legs', viewer, 'legs' ) );
			if ( viewer.hasEntrances       ) cv.appendChild( this.addCheckbox( 'visibility.entrances', viewer, 'entrances' ) );
			if ( viewer.hasEntrances       ) cv.appendChild( this.addCheckbox( 'visibility.entrance_dots', viewer, 'entrance_dots' ) );
			if ( viewer.hasStations        ) cv.appendChild( this.addCheckbox( 'visibility.stations', viewer, 'stations' ) );
			if ( viewer.hasStationLabels   ) cv.appendChild( this.addCheckbox( 'visibility.labels', viewer, 'stationLabels' ) );
			if ( viewer.hasStationComments ) cv.appendChild( this.addCheckbox( 'visibility.comments', viewer, 'stationComments' ) );
			if ( viewer.hasSplays          ) cv.appendChild( this.addCheckbox( 'visibility.splays', viewer, 'splays' ) );
			if ( viewer.hasWalls           ) cv.appendChild( this.addCheckbox( 'visibility.walls', viewer, 'walls' ) );
			if ( viewer.hasScraps          ) cv.appendChild( this.addCheckbox( 'visibility.scraps', viewer, 'scraps' ) );
			if ( viewer.hasDuplicateLegs   ) cv.appendChild( this.addCheckbox( 'visibility.duplicates', viewer, 'duplicateLegs' ) );
			if ( viewer.hasTraces          ) cv.appendChild( this.addCheckbox( 'visibility.traces', viewer, 'traces' ) );

			cv.appendChild( this.addCheckbox( 'visibility.fog', viewer, 'fog' ) );
			cv.appendChild( this.addCheckbox( 'visibility.hud', viewer, 'HUD' ) );
			cv.appendChild( this.addCheckbox( 'visibility.box', viewer, 'box' ) );
			cv.appendChild( this.addCheckbox( 'visibility.grid', viewer, 'grid' ) );

			if ( viewer.hasWarnings ) cv.appendChild( this.addCheckbox( 'visibility.warnings', viewer, 'warnings' ) );

			const ch = this.addCollapsingHeader( 'controls.header', true );

			ch.appendChild( this.addCheckbox( 'controls.svx_control_mode', viewer, 'svxControlMode' ) );
			ch.appendChild( this.addCheckbox( 'controls.zoom_to_cursor', viewer, 'zoomToCursor' ) );
			ch.appendChild( this.addCheckbox( 'ui.selection_tree', cfg, 'selectionTree' ) );

			const cs = this.addCollapsingHeader( 'default.header', true );

			cs.appendChild( this.addButton( 'default.save', () => viewer.saveView() ) );
			cs.appendChild( this.addButton( 'default.reset', () => viewer.resetView() ) );

			const cc = this.addCollapsingHeader( 'colors.header', true );

			cc.appendChild( this.addColor( 'colors.background_color', 'background' ) );
			cc.appendChild( this.addColor( 'colors.entrance_text', 'stations.entrances.text' ) );
			cc.appendChild( this.addColor( 'colors.entrance_background', 'stations.entrances.background' ) );
			cc.appendChild( this.addColor( 'colors.entrance_marker', 'stations.entrances.marker' ) );
			cc.appendChild( this.addColor( 'colors.bounding_box', 'box.bounding' ) );
			cc.appendChild( this.addColor( 'colors.legs_fixed', 'shading.single' ) );
			cc.appendChild( this.addColor( 'colors.surface_fixed', 'shading.surface' ) );
			cc.appendChild( this.addColor( 'colors.duplicate_fixed', 'shading.duplicate' ) );
			cc.appendChild( this.addColor( 'colors.hud_text', 'hud.text' ) );

			cc.appendChild( this.addButton( 'colors.defaults', cfg.resetColors.bind( cfg ) ) );

			if ( viewer.svxControlMode ) ch.appendChild( this.addCheckbox( 'controls.wheel_tilt', viewer, 'wheelTilt' ) );

			_onChange( { name: 'cameraType' } );
			_onChange( { name: 'shadingMode' } );
			_onChange( { name: 'autoRotate' } );

			this.onChange = _onChange;

			return this;

			function _onChange ( event ) {

				switch ( event.name ) {

				case 'shadingMode':

					frame.setControlsVisibility( routeControls, ( viewer.shadingMode === SHADING_PATH ) );
					break;

				case 'autoRotate':

					frame.setControlsVisibility( rotateControls, viewer.autoRotate );
					break;


				}

			}

		}

	}

	const surfaceShadingModes = {
		'surface.shading.height':        SHADING_HEIGHT,
		'surface.shading.inclination':   SHADING_INCLINATION,
		'surface.shading.height_cursor': SHADING_CURSOR,
		'surface.shading.fixed':         SHADING_SURFACE
	};

	const lightingModes = {
		'terrain.lightingmodes.none': LM_NONE,
		'terrain.lightingmodes.single': LM_SINGLE,
		'terrain.lightingmodes.multiple': LM_MULTIPLE
	};

	class SurfacePage extends Page {

		constructor ( frame, viewer ) {

			const controls = [];

			super( 'icon_terrain', 'surface' );

			frame.addPage ( this );

			this.addHeader( 'surface.header' );

			if ( viewer.hasSurfaceLegs ) {

				this.addCheckbox( 'surface.legs', viewer, 'surfaceLegs' );
				this.addSelect( 'surface.shading.caption', surfaceShadingModes, viewer, 'surfaceShading' );

			}

			if ( viewer.hasTerrain ) {

				this.addHeader( 'terrain.header' );

				this.addCheckbox( 'terrain.terrain', viewer, 'terrain' );

				controls.push( this.addSelect( 'terrain.shading.caption', viewer.terrainShadingModes, viewer, 'terrainShading' ) );

				controls.push( this.addRange( 'terrain.opacity', viewer, 'terrainOpacity' ) );

				controls.push( this.addSelect( 'terrain.lightingmode', lightingModes, viewer, 'terrainLightingMode' ) );

				if ( ! viewer.hasRealTerrain ) {

					controls.push( this.addDownloadButton( 'terrain.downloadTileSet', viewer.terrainTileSet, 'tileSetEntry.json' ) );

				}

				this.addNumber( 'terrain.datum_shift_value', viewer, 'terrainDatumShiftValue' );
				this.addCheckbox( 'terrain.datum_shift', viewer, 'terrainDatumShift' );

				viewer.terrainAttributions.forEach( attribution => {

					this.addText( attribution );

				} );

			}

			_onChange( { name: 'terrain' } );

			this.onChange = _onChange;

			return this;

			function _onChange ( event ) {

				// change UI dynamicly to only display useful controls
				if ( event.name === 'terrain' ) {

					frame.setControlsVisibility( controls, viewer.terrain );

				}

			}

		}

	}

	function CaveViewUI ( viewer ) {

		const ctx = viewer.ctx;
		const container = viewer.container;
		const frame = new Frame( ctx );
		const cfg = ctx.cfg;

		ctx.ui = this;

		const fileSelector = new FileSelector( container, ctx );
		fileSelector.addEventListener( 'selected', selectFile );

		// add active property for runtime selection mode
		cfg.setPropertyValue( 'selectionTree', true );

		// event handlers
		viewer.addEventListener( 'change', frame.handleChange.bind( frame ) );
		viewer.addEventListener( 'newCave', initUI );

		// make sure we get new language strings if slow loading
		cfg.addEventListener( 'change', initUI );

		const keyboardControls = new KeyboardControls( viewer, fileSelector, cfg.value( 'avenControls', true ) );

		initUI();

		function selectFile( event ) {

			frame.clear();
			viewer.clearView();

			viewer.loadSource( event.source, event.section );

		}

		function initUI () {

			// create UI side panel and reveal tabs
			frame.clear();

			new SettingsPage( frame, viewer, fileSelector );

			if ( viewer.surveyLoaded ) {

				if ( viewer.hasSurfaceLegs || viewer.hasTerrain ) new SurfacePage( frame, viewer );

				if ( cfg.selectionTree ) {

					new SelectionTreePage( frame, viewer, container, fileSelector );

				} else {

					new SelectionPage( frame, viewer, container, fileSelector );

				}

				if ( cfg.value( 'showEditPage', false ) && ! fileSelector.isMultiple ) new EditPage( frame, viewer, fileSelector );

				if ( cfg.value( 'showExportPage', false) ) new ExportPage( frame, viewer, fileSelector );

				new InfoPage( frame, viewer, fileSelector );

			}

			new HelpPage( frame, viewer.svxControlMode );

			frame.setParent( container );

			frame.addFullscreenButton( 'fullscreen', viewer, 'fullscreen' );

		}

		this.loadCaveList = function ( list ) {

			fileSelector.addNetList( list );
			fileSelector.nextSource();

		};

		this.loadCave = function ( file, section ) {

			fileSelector.selectSource( new ModelSource( [ { name: file } ], false ), section );

		};

		this.loadCaves = function ( files ) {

			fileSelector.selectSource( new ModelSource.makeModelSourceFiles( files ) );

		};

		this.loadLocalFiles = function ( files ) {

			fileSelector.loadLocalFiles( files );

		};

		this.clearView = function () {

			frame.clear();
			viewer.clearView();

		};

		this.dispose = function () {

			frame.clear();
			viewer.clearView();
			fileSelector.dispose();
			keyboardControls.dispose();
			viewer.dispose();

		};

	}

	exports.CAMERA_ANAGLYPH = CAMERA_ANAGLYPH;
	exports.CAMERA_NONE = CAMERA_NONE;
	exports.CAMERA_OFFSET = CAMERA_OFFSET;
	exports.CAMERA_ORTHOGRAPHIC = CAMERA_ORTHOGRAPHIC;
	exports.CAMERA_PERSPECTIVE = CAMERA_PERSPECTIVE;
	exports.CLUSTER_MARKERS = CLUSTER_MARKERS;
	exports.CaveViewUI = CaveViewUI;
	exports.CaveViewer = CaveViewer;
	exports.FACE_SCRAPS = FACE_SCRAPS;
	exports.FACE_WALLS = FACE_WALLS;
	exports.FEATURE_BOX = FEATURE_BOX;
	exports.FEATURE_ENTRANCES = FEATURE_ENTRANCES;
	exports.FEATURE_ENTRANCE_DOTS = FEATURE_ENTRANCE_DOTS;
	exports.FEATURE_GRID = FEATURE_GRID;
	exports.FEATURE_SELECTED_BOX = FEATURE_SELECTED_BOX;
	exports.FEATURE_STATIONS = FEATURE_STATIONS;
	exports.FEATURE_SURVEY = FEATURE_SURVEY;
	exports.FEATURE_TERRAIN = FEATURE_TERRAIN;
	exports.FEATURE_TRACES = FEATURE_TRACES;
	exports.LABEL_STATION = LABEL_STATION;
	exports.LABEL_STATION_COMMENT = LABEL_STATION_COMMENT;
	exports.LEG_CAVE = LEG_CAVE;
	exports.LEG_DUPLICATE = LEG_DUPLICATE;
	exports.LEG_SPLAY = LEG_SPLAY;
	exports.LEG_SURFACE = LEG_SURFACE;
	exports.LM_MULTIPLE = LM_MULTIPLE;
	exports.LM_NONE = LM_NONE;
	exports.LM_SINGLE = LM_SINGLE;
	exports.MOUSE_MODE_DISTANCE = MOUSE_MODE_DISTANCE;
	exports.MOUSE_MODE_ENTRANCES = MOUSE_MODE_ENTRANCES;
	exports.MOUSE_MODE_NORMAL = MOUSE_MODE_NORMAL;
	exports.MOUSE_MODE_ROUTE_EDIT = MOUSE_MODE_ROUTE_EDIT;
	exports.MOUSE_MODE_TRACE_EDIT = MOUSE_MODE_TRACE_EDIT;
	exports.SHADING_CONTOURS = SHADING_CONTOURS;
	exports.SHADING_CURSOR = SHADING_CURSOR;
	exports.SHADING_CUSTOM = SHADING_CUSTOM;
	exports.SHADING_DEPTH = SHADING_DEPTH;
	exports.SHADING_DEPTH_CURSOR = SHADING_DEPTH_CURSOR;
	exports.SHADING_DISTANCE = SHADING_DISTANCE;
	exports.SHADING_DUPLICATE = SHADING_DUPLICATE;
	exports.SHADING_HEIGHT = SHADING_HEIGHT;
	exports.SHADING_INCLINATION = SHADING_INCLINATION;
	exports.SHADING_LENGTH = SHADING_LENGTH;
	exports.SHADING_OVERLAY = SHADING_OVERLAY;
	exports.SHADING_PATH = SHADING_PATH;
	exports.SHADING_RELIEF = SHADING_RELIEF;
	exports.SHADING_SHADED = SHADING_SHADED;
	exports.SHADING_SINGLE = SHADING_SINGLE;
	exports.SHADING_SURFACE = SHADING_SURFACE;
	exports.SHADING_SURVEY = SHADING_SURVEY;
	exports.STATION_ENTRANCE = STATION_ENTRANCE;
	exports.STATION_NORMAL = STATION_NORMAL;
	exports.STATION_XSECT = STATION_XSECT;
	exports.SURVEY_WARNINGS = SURVEY_WARNINGS;
	exports.VERSION = VERSION;
	exports.VIEW_ELEVATION_E = VIEW_ELEVATION_E;
	exports.VIEW_ELEVATION_N = VIEW_ELEVATION_N;
	exports.VIEW_ELEVATION_S = VIEW_ELEVATION_S;
	exports.VIEW_ELEVATION_W = VIEW_ELEVATION_W;
	exports.VIEW_NONE = VIEW_NONE;
	exports.VIEW_PLAN = VIEW_PLAN;
	exports.WALL_DIAMOND = WALL_DIAMOND;
	exports.WALL_OVAL = WALL_OVAL;
	exports.WALL_SQUARE = WALL_SQUARE;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
